<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #1E242A;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #1E242A;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #F9FAFB;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1aff9697508aebd7b2b0e38335f3a503b5627f2a06f8e4ab5483dba008ef316ab415b541cf5e9c1f4e094c120b0efe33b5d47c7e2aa412649e8c8d41549355b1819888e5a63592bc95d3c9a5ebfc0d78cb54b8a1fd30a914fa1f07ae1384a6708c0ddd6d350383b5454d95eeb9981961168efcced3dda770c40f4768e3f3408d85da8f3ae8034190ff8f3a2150f951e317e29421b18603706a1bcf70a07b27db00e7a96ff353c5aca59982d12a03d80f39d60610a1d0c1b47b8f569acc54bcc88f0d2fb2d3c23df99aefbc7e09b228105f4d7e1805f79c3018d7a3e0767186767084d3b1b952da5779cec3cd884f3c17e158ba6e5bbbd316e922efe08136c5deaf1f210bb3bf019e8c933d4a32d242f4c42cacc66fe1184ffeec8526d7027d7ec1276058af234fd6feb04ef13945ad837b30ef5f0ae8591aff6d2eda6fda5591f2f90d9916b4fc2fae50f87c168352d933da168bf7acab3f6973132eccd091d7a0b97ec1be527a4205955a21d6a4003fd3f2698e6cd1a2004063c7e2ee464c0213f5d645fed4efa13913b74959c4cafaff5d9af4b6f87b7e5eee99021323b84a5e44ab74d749d6c055fc9ac9f9633618a1125a1b38e9bf59b49446dc30508c3a3f30da4f14f0c670f86b4589de891c75ed2aa441bd3620dfa84fc0ee559c8b74ee32be1629650ffd02237592c5057e4f14e39138e18f5c018fefb86cd9061b8c456f851f108154d4ddcf263695610ce426a581f7cc2fb528b66b5b56e38b01d58bddc25d0029332f7af735680af9468904b633bb01bab2a328e4979b1cbbbd9c6f559b80bd3fc4d4ef0d376f0b031a4f161b60e80c44cf341c592b7d12de4a733bbc53fcf02828315948764d87b070ac8d3f59e4a90dc315fc4f21e66a570b610307170bedfa5c19315336ac2fd95f496c47f9fb6125c68f3eab191ad28bcf9a0cdd869909d1f1fc9373981d3d1ac66002495f98633872d1996a051dd44f95538a0c0ba85015c6f5f8a520a93be61dff64daca3751d4665563fbc73b0e67f44c577428e5f4a303a9967d00c70bd445c0880aed01da3168441bd43ab4f6db993727e7813b4c986a2fb325084c5db5764a199f7ff43633a2b37faf5ded19a8b4a47ab0f6f994776f49ad08bbfecbffe0550053cf64e8a1b5d6501c119b7b96b3920ae851a7d043a756198a66c9413f6f4a89244443831e47d6c126e017b715994535945332c4bd8d63df4dabbbbb5ffa2bb62c77984eaf8364b9fafe76376a2ef5b04dbb7d0d6460ce45065b8be5349d209fd1e3230f4f6accdc48f5cdf3748d663db1f5de1efb08dd7de328ee392930e432523423bbbb0f984f09c1aba9463cd55d0a69d3f8a7e678f86954001759bccbfbfabf2ab579ea78c500bcc64b6a319b0a8b6955bf10af692eafb95a8b3e4c7471e32e2cec27c09face5ad785ce57747f00de35574d30c0e4bf6226e76ac6621e6f5ee977acbc4b9dc37f21cefd213114d61f83a8a14b65dcec871d6b01b8b55aacaf53dfe7f708be89c5735166e61e9a36db82e9f1fd31812a681ad6dd408f45deb9172b0babe2f063151942cb2ab4946fb9026b14505438c5bd603e4a2bac9ce75261561d7179c3335d3cdc851ee771a1bae2fc099c1dd8ac0032ad9915b23bbc217bb8bc84415c8a88f6841b341698d146943807b98ebe877df8b9e1590cc9105b17759348f3b72b11a32d50d281fd676a2ff203c469cfc674ff1d2709da6a2511ab859edad77e33f1c01b64d75d1e20fc41ebe0a05de1a6b4b9766efcc0ae25b6fec32e56a479c2f2deee81a5d6b3521cffd5a2e4b04351a8e63617805772c4748389ce61c047bdd3aa881b9379a45ce38722aaf36535fa36c406570480931efbf6127d6fe6e57ab5c3486c3eb81692fda9d430850b8a07cf529353585701af512ede432c333632701c674b6e9ea3ed29c0120b7883f2462be181774417d3a95940a3e3011ab8aeee4b2caa158fc6f4cf130686ae185f65647ee40a4df32896f727c8ee618bf1534d8b3dd38767cf8c7db80f449ec27c8f8691211662e17153f3d8b1d2038ccfef6a6264e080faa0222c61ad7d7612535f72468f0d00848e9099448bacf91125a65fea48ba621070631d5c23a25ee318c818c61b97a7f65c5ec58b0789af5cc182eeaf927d1ad57b7501fce0f2d059f8bbbad708506bad1582a39d6681ea3638027782f8fcd75718c5bba66c478a7e5ef5cb258929e47a61eff108065073ac7fd1dd0e26862fa8fb5e28ad67a125212da99e3d925d52300352dbdb61063bec47e270c16ec587347eb08d3f6e04721d33a4030f9c925f9644b8fe25aba8056e0092cf73269c29c7cec83b169455cfd830b1f1b4456321914cf9bce047917674ffa7121190ca8145c6ea2df2f5bed7be40281846f23535fcb895417abeeb23f44a601bbccb44a71d04c46c0c710c4a50c9fbfaccccbdcf530b2abaf70057d8b477043256709ff10604416c46c7203204bd27d0f4d3ba6adacf7f297a14342099a2b557a6d7560cde8cad241e9878f9962910ac6ce66a50a352de2cab740f5b02bbf9d4eb91769f467f0f109966d87206adabd194c3c84cd82142beebc5ba31fca7fb1987dd8ad253016622d67b4789adc182a2f2c0ff55c580bae691ed6dd3b4d707b14a4ff4a94289d643ddb1360086e6539f5e979f281ad2e99f894bfd91e24f4a34321e1f080d3031248555a6e7781f9599e5271ba3dd868f7ad3d60a90f725d4401b16b4fb319536b7fd18aae1851a3a0342751369f0b9404ad87baa45f39e37dd065d8b06324f32d4fa24b9f2b914101df4b5150c885d2b95782d885086216296d70600179352ee455888a71ec6f5a09499fc434bb9982ae299eb75805cb57424097662aaf54bec5015249d01200b5f1621cabfb71afa5f8359d9a39b0b476e8b642378790c8f2d5815c3031634d5db3687025cb67b347300c42405f5fd8ecce9e12265e05916a291ef519bc6da1b76069d6bc590f68ca63c8e6ef97afdd2c99a24d738348ded92cf4adfa0cd66bf26dfc041523b00b2d8b9a1a5edfcc614981c270d218dedb70b69201153eed014bd3082c5eb5e37bc36a3952ff2ac78e9e904de88e01d092098a6defb0a749fbe42c95e37979ee40512813ca0ae713c283fd0d4ade8b139558e3bd75dd807aa3e0e429704b6adb0419b559d928cbd8367ab399b26efe9e95481fc06226b1e8e8df4414cdff59ecf37a267805424e3f6e91434aa8acce2863761bf6ffdfb819ce5e09361bb38fb3ecd8892b7561a91c81475ebceadfb0ac898fc4de9079a981aaccdbb83457fd360399ff47079e215145b1845056d9b906fb7fd6208c35d8be2ae80029ee12d5d8a02339791be39f36dbf30af0fb445205e96895cc53b6f68be93412615d3553759d68b0f8669d7f7ef2d2f7ce8b224ff9a479819298a3c529a6bbbba6c4a2242a64343b48aa99dcb8d8077caccde2f191d4f5b7128401308b59218619665cdcc8b2de8d94a015a67e2f29ae67e2d88c361861e3e3b6c05aa2f5f3853d691a2604aa152c2a2ac57753aaa6c35faeb400b027612a5b076ece7279d97952c06bc678e9f0f95c171d7d7aebb62110c4f1d3231519cd7d85c349f093c094c3a4a403b5617a30914c50c23927e337a8b46069c76343ead305125c5c8d7642ffdb510f548a78f2e133a5aadcf10f0631c28112e2fa0326e5fda129b2d79314b596df6c941947ccad9b5f6115c08d2c257b10facc0189b38faab711a15f10fbc15aa48c4713ab759c2740d5ef7efc4f1ab2ab4f6e42e032f49950185957165de333c5ecc4242cef3dae1fb701e2a84fcc086a16c491150c0340b042faec13e3285dcd5f6fbf560a151fced4c70b161f05b8fe36d045f3ec74a8890c9ffa4090919cff03c586e8662c7d92af0d7830059cf97ea7afd2d25d6daec2a2ab1ae2b15245a1413d85f24c5aea64369187d5473ff59cdf1febc1c49bc3e1a089c8f92003e403a2f60246cd36a711a7a972affd1a0534d40ffec6d4c40bacda9c664bbe6a53dc26ca9d295a65f676ef10e01a1856dd9a1051750c312ada4b02b13eabed800ddda2805e499cfdafa0c63d3c02557b090c5f5dda703e3485b288e6d9ac38097e5b2f4d7bf24f7179b3f1b64c338639e229de58793e90ce7be527b7453ba1b64d6dd080c4abf89d177c4f01c42f85b065e816c3347625640637cdf2f1d28484603adf275dc0c7553c1dae611f9941660a6b2d5250b11ce95328ca929bb9fa6ccd793ecb9acfc00e6c470193b5b9860457a66778ead1c9c86eb27a24a3d9f8266fb75e65af9d987f3511a751350f3dab57953dd5218c406238929f3484bde92546754ffd7d4c0efc91a1d1199150523e81b489efd7d22082f70fe7455ee0b5fc4eaa5b4b8107c5d1cfb7d3c4fdab354a923fcae0647da46a6b70bb6347855eb9719bbdee24fed13b013bc34dc37d1bdafa41f36337a481e5e20614bec51a98d450665dd9a54730e07c53dd768c9c28dec64b68b80f80aa590dfdbf5130a00821b53537b4856ec671c2e879a31c66e8ab0a07e903cac0bdcc7fd9e04ecaea3abee497592305cd858c691ff7b4777dae85ec7c94562a1ccaea981c4ede16bc1ecac577e1473ce7ad42374a4c97b1cbf856cc47fb1b9e793674c422f537dd28953d3f6f1c089aff14564de3bd6e92ee8670b9c62c11462906c9631ad8a061357d8d1d4cd7556651de85e4dd9c82384e32614c99679b96086f351f19a1880c80dc92bacd5f748a478a4493487bab74efc8f6232e961e3453f718e4c26544548018f14721315fc8bcc354889109043b81afa60d03ad6e39b6b480fa38199f7b3725c05ad5887a21b3d191f380f7bb2734e265ac8bfe156003438e361ed80f6cd933ffa2ce77d6fa1cf376c5f814620729d0a397d24aeb8df97534df16a86250af5eeae5fa40a0e85b527b30e736ab07540c2771baaa41095debd898b7d783213292f9f0b6ad12ff84db31c3f7f0ebfdf98bf18a5da3bc6b7f891408856a0dc70a731e6377930769b9adccc98499850e4da5aee05a690e4c39715bc1b33237fbc6b7001c43b9ebfd5fedb8bc4ffa5ad0e59f01824f871d8cbce1dc7eb8af582a4268c7f5bcca7e0eacb47492e11e747e46f454b8046bcd62ce2028df6049d663ca073bbd574e0de0e1592f196ec67d8349892009da894f19b60ce92205bc6c481ec65b86c8afdbe6058f66a7a04746efa9335e622e05ab83a17e3fb5d58a1537602def1ae5a052fdfab267a11388d4d030862967a345f34dad4ff5111128dc6f6b50387c0e0bd36c7aa8ec669032ec1d926f4dc31ff29930b3c6e45a6f082d65f9ac68978389f136d16ab1bb38f9e5429c7cb841e0b1382a6d3a4d1625cc5846257b5799e164b57dec9a993f88eb79c8728abb72a6895def394da37f0ce69b0e7adc6d33aeac1e8eb4120cecfe769407600aae1a145e2d622d4aee94de9fd9553e95e0e4de3eb60db00dc821c4ea9dfa233dfbc873a0282624c82eb020ef3b4d0ca45c1cb082be52612506961c01c75a3f6587de7fc7078bfb12847a4546cec05bd2ed6430a7caad0bc4ee3dc2e353e1c90074f015b71cb16eaf7c805ce9cc73a8b616244ed2dc5bd9d9f69788dd425a59859bf17b22d7df6b1e23e9ce7bc1187f9b867cd090c948b6e609cf372de5dfd60dde4c871b3cf9301dafef25a76610d63cf5c9e9578ad9a7fb611229de7a489c7df680ae1cc34c38af4436f2ddc9a7363d09d4954654d6b9c41d01b89a353c8841208dfa8e1fed814364ba8bfbc8583f43f8a14700f06d27ebf9ad88e552f1e59cb44eb927040c1eae87a6e5ad612c49a5ce8d8f7995617351b8ff3608d3e4976a59677ae947d329d1cf53852397a2515e32cef9475767616a5d4b268b85b344d430b370d3a6d2efee63be732356ddaa5b4b2a7345a7d1f5a21f7f79438f2267b7b69c2fbd2c15dbde93733f7bd0f0bddbe7b2bcf774b3c3b69979f155b008ae5476f4de0601574c1b2c1f30ecaa1fd077aaadec5816a1fcfab187aa08705424b4236d52265ea654e43dd9e5ab2e1b99f2c1b51e5b97d83ec287f78abc261a9fd0b85ee3415d7ea6f0db20ef5f9226fdc3d822023e06e2957956b04c454e4ae0900936a914040dcd2928a70d2c49275e6990d5556fde2611274aadb9c402c30997edf33a552a5c1efc4c31e785db82ecd423bf4adf1fffa37c209606c7d53978be8a78e11ddcf2764d047537c40bb79d642ef67d1a842da00c0b81cf203ca67feececaa8415d3b6b36370df1c47aafd474f4db93cd212c9decfc8c81d94820de517d8cf5a236b9a7e90746e14e096a587d7f24aaf02ed4cf495390aff9cfb5325625c21bf6fa65f1e27988253ea0359211d87d0395790b86a702f41f5746e7ea985b49571d9415380d470b3260a063a5891aa02a21c3b8dfa5abe66d1e1c4208421324b6134e8bd69497c326219820fddbbd94b1d6c329409421959e4b9d554491157ef54c7e05279988ea0d6ba012f5e572d94d5866375a58d0794ca365a380ac8a9544b5613c1ec79cfe7beb3c8454e4d37fd0fb8536f4afb5a8d389747d4f1a2e71e0feef768afc0c496c6200dd6285536fe2fa51fca036c78d5f003741a2001f00a4a7c7ec3f947da2f6afb0a5eb68e97720a77a8dd3405777591e7c24d49a4ed8b34d147d09d758e9774eb8e61ce9e8ff714fafe6e5118b0b92c9094ace886201cfcd10146765a755a5fa5bf56c61d7ac3b0cc9804efa7c6b70311ad1ea7f356a980a8d299040131acdbafacc9225744a1759fc588d1894d12ccedc9c7fb3f9f200851757c9f4259ef472fb00473c8e249d32352dbee392285110af55325d2dd6132aa5749d25dc2b44e0d484d546d1d2c7f5c89050bbe3e70bb987a89931963a0e0ec6bded212b1f7d6fd7f55a1b6bdfdafc93740b3b876dd6e9d33c5912127719ceb33190e691345d842ec196ce6cc3b3b206d0e096cbf7792f4b3613bc34e3e672a0023dcaa3745426463def8d22221a756407f6d9823510c7167ed01ab1a2abdf751e6c63bac6e88875494933043c689e8fbe953593e974038a00cfce298234d7a70993dea588394a06c06b3dd005a0a5f9eec0dd1a2e06a3350f3003b097e19a2fa05bd2f7132f47a269eaaf95ca45ed680f2197728a51c8d8a2b24185a1a09ea656fcabe78c819e12ebca85394143e8a8644d7c4ff73615d21e785ebac1db78914b9dd09b6f48f5333fb0ccf6a3d1557f1bcdd7e21656f808be90058615a5030f8f0b12fcb44bec35b873fecbc92b36c777c24c8628c80f63b16f2669782833f369c8dbe0ebff3f297a5a3461be7326ceac9f166deed4f8d99c5eba9585fd2ff0ed91591ac643b103e772a0f570cfbca8a32a6d59a6b926e5750bf3f1a9adfcfcb256fd30be0fa84881a8708dcd7e432cf3ef3b7036691344fe0c3c5c21056ffce76b1a7faafe011d3b181368872e1297b10451bdfd857673c8bad8f2b5519133ad78e1b536d4a0b9591359a9ee8893c2348b6362504bbab62a0ebc6bead66d823966eadc1dc2456520d147299f89f00e5c1c939996b3bfdecc3c2489e79757c257a32a05f3afb9042cec9d8dc646bb748c8dc2ba3212cec10877b635ccdcb238201d37f88d7bcccee4ea98a7cf4acf532cd86a625839327a44ea05d8acf35b2b2ec01555930293e25a64d5700b40156549f33ba3fb734668b23824ec20255fc3a56ac4931724c5a1697382fe12a48909564f8e00c5a1a36011f92a1e2f33b23fb37136f106a07fb760ae5a89793482f3747edab7f7dc479e91f566a88dfd2826b89ecd3d0a0e91e25222ea5bf3cce4d32620dfe1295e25fdad76aa05ea70cfdae6736970fab78668a912cc802a80c5c95c97c90e22bc06917eb9bbac79292356d028527000cfa8eb4981d3a3c1c2b3407ec8a2dbb348f2f43619f0032a514fa5d4454020b020f52d9d9c1f436f510798b331497e002779758c26f23b5bd76e0a3568e86cf7e65cb2a72009a6fca7687a099a43a7a3485e9f8706cb305941439f4d992a1d31c134b2004bc2e200dc001621e011bb33168afe490e1cf824f55d25cbb3b8c9be9b60159cc391c1428c5602997d1b301af93a234a3d1e0e524112184d37dcafff42f5acf3dfd15497e4ece100fd5af6d57f4df123dd6b98308fc2cf9abd5d262ab068fea502e511f25fdcf6abc8f10ed4144b5d88fe8f11e0621daa05ac2d3a80286c586cba071f09876f5a9171272db55e8caceaa0a9aeb04c57a1693b275d9b17ba2e590de474eb1e873af007bd0dbd8b21b1d85656375babfba03e30f22bc04be2919cd167f43ed529c69c3bea4679cfcafb8ad33818fd42c23fc357b0b027a34e48bae3a77e11f409f6c75e894588078cda2bbe8eadc5ad03de86dbb139d0523da1ce9932d17d4976a7b7bbc68d8eecd9f21fb565872658b5cb4b4307d143acfa122bd55fcf7c6e40ab64f8439dd0465ad5b59f6546236189936b5c74e815996c8a8088a1876bf039bf7b429b8771ef7ddcdde5895a96611c32a3643f14d759f1cc1530bf5351fc7d39ba799b15d6fe70e0b6a647967b2b9b6e4eed48a8b3c77a979cab3fa1e30c8ea3a86b22ab9edd727eb079c9c33efae37af72a4cbd59cc28b5d7f3a0c6691a13aeae65891e22303aadbaad524705669873bc42ecafa1c8dd330c7c6bb47325feb8d9ca9518e294274f4d6b34be1ee5f7162acd30beb94a07c065f75ade857039c556123abdd38e2efcdb3b3eb2cdb3f901bc17f3b6086d993c79170fb5b64e5c3888c7cd3f63897c1d62d1bcd4cfacbeafc4d61ee15f5be97bf30f9888d7c0ffd39beefa777c30ac9187d0f87d2eb64d4f66bd09bb5dcb0f8ac9648d059ff7cd5d56f57f89b9370b3e8c8ee75d4e8ce30c8698eaec7eba864856e6e40a427890e7deef5db4a65b45435b50baed2a7d65f0525d63c7e0ad32009c118f4a0363b896d7ddfb3c12dd12e87ef8a26447010d1c2fd36355c05362438c4bd1a3f1b2ea35ca4b1cf107db577426320eb58241c2fbc90c8b3a3705cb4bbd4f24c3dfba99c83ff5a6e6d83c9833db4db3c09bfabbbf6ed428443312f8043c80dfc2dc3e0a923557fb1af512a9a89c5e339db7dd663d31c91e096969099e15e0d141bc2bef1b81b1f423a493e6d2a4f4423f8d5d8770183027af4f1f8480d06a125f1c0d5989c4e5ed45248fd8a442c5cd7ac5de94afe8f7d23f5c36a34ca99d76d893266267a6b0033c2c6426222b64691e6fede7aa4ceb8c5eb10879f7a7f51281cafbbbe2b69909ead4d18e33df51277ca8436f602a10fe7e5e98011071072529232d1975b5cc5837e5b075edc9885f36f8348ef5c0211fa4dc1d276acd5744d6a6a9f8812671ec3b2004d44cafa4fa1455dce6a288a383b414d7a03a003dbd4989e78e254bcf55b2bf120c72cc6988d182eb6c7d17ada55ba8450ccd34e0b72c13e45071878df74db9f8e227e79b5fda22ec6f54933f53fa019a25522496e17cc8455a76f0a0baa2d7209618dc9631c7775d6fac4fb73293e2351c698092e314eff8678383c21e39c45ec560d635698d7418e69a87d5a4b9e7199576741f8b951431a000598af59a61bfb63b089d21e440c2d8944b28821ec93733761583c7b542b9553374be239273a07d47bfe24914b026bfe4aba4ce61a30c96ad881aaffc738863719cbeb791532c265250ec98d04f5c5bf3b0745c911fba93ab0c19863bd8cbc7100e0e75455eed545c5b4c3870c6993f0803640844147b8810a9c87bfb4168ec8c93e8a7e7bcc83e90d9699f5a33971d68115a0e553331a124c6867e61f66b30f979bf588bb12f5d2d22313bc03398f565e9c41fd10b69595d0775c9dcb14160e5dfe6225abf581e4b24ce7bbd9501899d1bf8c1ed6f300284ddd11eb9af6053d384819c3d3128112fb1dac8eb76276a4b894e62f93bf7baa6239ddc9cab44717697f05d2badc37ef10389c5d2fa187ddd883967ea241149e1d6cf7dd544ba141b7382c981ef126f6f91a5c02b40cb503aab286b2d88bbb824e9f44d3f6d28d7f58b7cc7401ab0d511e37f38cbb1e00da5ccec1b50b6427d8fa8141dbe715e705cc2a474c999fb3f66eede658d8f6c9379a5792c78432a36865052a63ebaf0a6fe763462c2bc8a18a3a289d064b95724bc7094e4f30beed150ecbb80e6bd6a819843ef9a9c2067157cfb6bb014c01ec5bc0a6f3ca07ae9ef347305e6e572d32932a120848718999f338b1cb02d39cd936c41085b834db1206454ba1d77e25121874e99d6e7cc0395727f7b3559c0807ed4eab446b69f13bec86f00e5dec4b0fbeac57aac8867372dc44954750b0e53dce047bc19c423ce34ea9403c3b1acd2eeb1124cbc54c7c28f4e932c510a70d80ef2e0d7b9ea3d9de23a0fabf86d7e960c4651dffcd8b105ff4eb23a7cb48743d1f8ad1dec89f56839560456dd8d064c4222bd483cae4e70ec1b6c9d0fa85f657f9e12f26f5f96904d475b7b36440bc88f191269c06e0862abb94c2b57d0c1bad84728dc9dad7d895209905c85babc0f449a070987b6b3441bcda6891ce94789255c780e99811e91fdf53331a0f8ce3a86cb4f2d316e5f1f32177b16b7827f75593a1a7659ae49baf532f479f007d3967f706140b3d39f6a62c83ef1c0097dc9d729fd9535a6e340432d1d941907f218a0dbf7e4cf5a95e4ff820beee8879d551a5fb1d71e1d4d6a1bda5230a9e3f4b97fc69a486f5a033654132fed493999ccbe1e631f354ba08e0229ea4d71ba476540a3ed195a991d056d148c7e1e43a79cb59c70ba7bcf805b136c0222149d0e994708040f5f0d47cfd9836fbfe11bc0ee3282dd98d982e4bd07e81418a3ae67cba6ce1c4ac589fb1878a6a84cddd660ca4550e87b0a58631f6873abf2a10c8a36a5c4e43db3058e795e68dbef1ec16ddeb3dfdb12e3a44ec50a3b767954f3cc0790315e0fe0be6fd3d69231cd71ec3c20f6bcefe51d8674ae697efdd6721e0001b49fa0c2afcea4c32343f3e05d2118e401291d4635c41f70013e7c2dbf407f0ceaf3e9f12a47efe321e64012e771bd734d075e21dfe2cb7484215004096849e4abd49490cd0412e325351ab71cccf7e47b5224613ffdd7525646a848d2527150252f8c44432f01859ba76ce224a1379068ac6d499ff32f7661421a77beb699c63e57dbc6271812f883789293e41fc5763e6fd74fccfa34b73aed7db9d903ad1c271d406e996a7a131419976ed5d6604024458bd2236b19b3f2d69b345bbc8492412a7bb157aed18d055c648d0a7c7f829c0523a9fb8c3f6c0ec73061a132649478c5b1805bf2328e59e0b2fc8f9e19e6a2c467006709c7f5c4f3afad619c9044670aacae8f27502adc3da39ae026312a0f0f855faa005ed04b66f2756af7a0f2a58ff3622f382c5b7951de0c5245eeca0cd2dbe16e5db5ea11b389ea0b50e3f066b9d9a2a1eb6398d5a67a846d21ba9ef4f3e17aaa3d172876e57f22ff56b9513bcf6b6241ab75dfd2ad206888a03e21596e8a746dca7dcd896834b8f128ac7e2579c81adbaee45aae8780eb15424b05e92da64a751a27128f5a95f4a89c96dab7cb64bdaf86c09a4ef86b47aef819e0c664f4243023e732aacb07669ba7dc778d798609783fabc78fa3f9f76023acd22022a015bb74592321dcbddb701c9854e4ef402142b51ec1090e8146c2a731c11609b10a1dfb87825211e768ee45d4159cca72aa8f329d1a56148f938d429ca04de2562ef0b7d70cd78994fa5e7f33d437fb19b9f090846a21bad8c145c03ca5040b56e306ca1d55e8d461a3bc093597e68976dfd7c0d3afb9f926b1947c25667b3b4fa72321ee1820325c61895d7b763f3200ba4f71b076cd72c6afa16b14584244c8e6b03a613a0239bce01865ffa8d18b1b4fbf13c8e57f201938c76107df1a1f04318df34cf5e1544015af96c9c0cb1a3b3283ac3684d260fcb900fb3da17cff22eb7b0c29f164f468afaaa6c7fdb1420ad1ec66bbdd3b462432e38d3de5da13dc2a291a04ded50b913ff9b33ba33fad962293736d69d0da7f1386a148b14aba638eaf160323127ac60ad5df4fa4cad2ac2ace937310029f663525b466558964c47659d045a3eeaff71b2d4c29d62b650f45267bec9837d533708e04bdf0af83aa554621e7c871e5360f2fe1e1b3506e0baf2567a15e4a4e9dacc0c2c72bfeb5bd003d933792566b20eee7db2b88fedc26f3958d76433e48c884ca64509d979b2e0747654b0fe73772c3bf205338e09f8332431d8b6224a5c896442c356300ecfc43592f80f21535d7c92c5ef971fa2bf7b1e78adefab7d64dc1a05efa256205419766e05c67fc0d550bdb01ef6afd971651b58993a3e432690dc3d0d4d0ee0d78017c367176abc566b78d66d5b3368d17fcb5fe06fc33c3bdcb749847eca47ea2530e4b24d8f122f220c0b397cd886d7908b2b2b82ae237bf3ac04899880087415d8de5847297444a6cd425c033c2bf62cea8c6b232f226b5bd1d3cdb3e8069167c9c632c00b9e741ca19b1d1434ccda577244f0f8c23a6cb888102484abfc07917aa4e6e8fdf8819469ef9196bda147f2c3d0d9c94d8b4c5798234acbfab9799a113d26f4b57e67e13df8f752f1287becf1157548bc57f3fbf2986b9640e419351ecdee70d00dc1f7f471de1c7abbdff973b9ccd901b5d6b9fd5f7eeb9d7ef4a385effdacd9aa818d7d6eec0b31c26ea5421ca0b3a69858e470eb9c082f696b7217dc4e5dd331a4586adf077106deda2f9d5db951c30fa46156e549e2ac8a4057ae499e34d4ef55387c4cf0c8a04bca14887e1b979dd9542908017ab0e30a7fb2f3e5bc31eb06808794e6457a7212f97489b8f5c15b73d78da23362fe0c887e9f3ea581056c82b61ec3a2c97bb218e9b6978cba7a41b428bff318ecd9c2221695a40c17310bf8476c16756c00a29775c926f346e0d0377971752643733da93db13ff37e14cdab0801f91d37de3b60aa05f5a1b98d9b03568a22c53c1d0906f811c3d963ebd10043b8c2efb3025ae97e33982ed488385af25994210b3f33064d5d9278dd0ce9557579108027eabfcf857ef91027409000113923df551c1f000375c9fc5449c00c1def9901a9c445d95e83d0cd7b72ef326610bdae2f1a8fd4f9fc804b7ad743f8d82083199286612b97b30c9a85bc406de588867642daa12c79efe9a42e927eec85e3847176952eec9ccf73bf4900c7a575d0acf63b82578fad076f3cc464f846a0a60e3cc5115a1da4d8cfffcc9e36cf437c33a2bba1ab19a0238a1ec8bb3b236c15262a68bcad14eb384290d5aa607467bc1a2240a314ea4368f89c11ed4a11658172039c77354ba30bb83fa870de2a04a7d12d1f584ef5091f13c14c98fe59a58ad90db82de80dc8cf7ea068bffe9b0d19adc2abb49af9f8e537761f0faf0faae8536310c6e3caae8f869d156c4fd4552910405425a211ac3044d79bbfee6cb24f1fc1c86e6d807070bd8af294588f07353f3b20031d773e401fed514bd78f583c8bbb27e9fa025deb2f9f370682ac647e59553fd74c587a5b04ece3db8923abcdb2f1648ad9abbcb228bca5e00f0bfdb7a6ee93498742e23f38c70b6c25cc828d65306ac702aba4fab85e0604b57dc6e21702068077364db0f7e8ff446f8ed7efa5477f01088643014210d041e42e4f4bd1f78814cbba3d1ffa79277bcae0966bc7a2aaab45199ec2d13a70d16753636442e5cc2e14fc8c18649ff1926cb32f34046467bf51541275e79c319df78a0fa2424de5814de83c6459b44d5c1122e48d9611a60a25bdda6bbaa8d3b5fef2c42ab2e4552ed666ce1412e5efca07831b9994081461d86e5ac568a1650008887dab9c9ad789314cba319f2e2ac13986c20c94b7146c4f181048e7654b982919ba0a00576102486080c81685361142339f1c527ce65dffb69835d02767859db43c8ce8dd9c928a96e40d2e2721cdbea5bd017df137abf7595bad3747b4202b2a6698cd59d5464646f4a8f0712617c4c5d7067bd6ace89723c8f23e2215a96fea1256ad60cf6578f9fbb83d7ead62279f87095e2a1b3fbead1e0fd89fb5fde0ea5a2f36efd85bee5bb628bdc634fefc39695d92c65f47f099a66b219f79cdd302f71bd18df42a0c4780aaa526a45f333dad39e0a324d3ef3a5b64b1ea2964c927ea1d5b564cd1686a95b231063c4eed3620bd823015255086a966f537ea85bd2995b931f88b2e378ee0cdca9a117cd98c4efebd196a7605cfbf1fc7951959c78d281762b1018da971dea6a98aa114cdd3f013e00b915e1decda98720c9cc073cd03322d8f66072b4ecdaa26c654ecbd91288dd1ae30bb3f409351e6a46ac4502d0e3db1e5a201ccf62a02a664dbc3b23c6de785221ad0db91f594482a9be37e505e264d0a5110fe8e437b852d101a79f817e2e302f04d9949221d9b9632b860f320bb7610576ffff3f6d725a49fedd4ccf7b5f05705d7610e442ccda9c6c0666792d045e5f2b333c7710fdb98af0f57466bd09ec5ba7dbdf5af732839ed346d0f57919bb64e885ce9c5b42fcab98effcd5ed12a57a1c230df21209a379d6dfebe2c7a3a716f6154c7bfbad3ad756260906d1a313010f0a4ed3a253d4660ba919862ff208e4a59d9e4f3d6a3a0938fe8e67a66886b7edeec215c706df2c23ddbc825730e3a1f801d375791754bc87211e2b6f0c9a00927c934bb822fbd27a0140e692f46693354206adc30d4eb592fed9927a3d56b72eb42c1b027febcf4299f9e19f1385303c5651194339bb2e42d00a538880122da669110f04244970ee50254b980a6c4fd5b7b12dd241bfbaed595a027df8dd861dacafa259e9d0fc7951bdf1c9b4f6d937d744b1b82ae19d25261e23c66a6edafcb55630a7df399642bab57ee0fac361069b763a9636729b0b87ac28fe93ed31b6ac490011e3a21a02152bae9858fbcfefdeb8ac47cd8aa006cbf6d32b46f87f41647e3c5c1808f5086b77b4e4dc6fb6d00dc7540d113d25b0fcd6033000694bd47ec67d352d1df1458feee2e280b7a8cc6526c8119b70ea5623216bf4df7affe1e34954127a642dc50b820666c01366ba1f29a216b8ab237527959f407539a30520b2a88842059582bc903d695c25d3ec4b1d3e13c97ca0345e6a22c84520dcb0ae08084af3c5c906e988695023391e9c9e4727cda7c53cb2175c06d07333380b7dda365ab68b18fa722ec7d2670a2c0ce480143300a969c9b72e9e311a4ed7dca2ce54b5225bd97b4353c4b33aa9e80771cd42540745a829a6b363ee5525d465f40f62385c96d4f1a0f41bee4b14091cb4d8a3fc0ce475ec72555343f2aed63eca495657e563a7cfc5d548157ecd4808d96b3a18f1c463a5f62a81aace8672995b435838d91b236c6bfcf1c8ba62b4b54eb8a14f71824d0055d1cc0bbd03375b713acac63165785afd318a918e80190a668dee6820aab245c87bc54cc8495f15abb5eb75c41991482fdd91fbe6abc96c5e8841340f16e22d832e6c49311ce4f78dcbeb3ef92ed7292ccdf269472e4ae6670d089219a5273873305bf659e0d7429df4d56c3cfca584fc7864a06fc562e0a07b98f1c297f5313224addd04f7b25d9310654345ac43c3453adfc3ecd20c0123a82ff18d399d8ac9d996d43a49508e65fa2a10e9494922761f89b0472cdc9e7a19803e47e42845705e0e5d2b595ad399cb70259f236b21873892f62da8676d9c350e042becbc3cb3294135f873e84f653bcc21dd3296ae3aec330912a0dbaa02d1d760d5af48f40093452d910a997bf957cb28ec84912dcf61d727ea50bd55353822333dbffaabef591c2f23171347c3410e6b944be99640eda3b7bf6feba7fba47dd5eda921c79659ddf3caf76b5e0f2039cb54eefb34de07b968fd2aa476d8948891723dba9445d756b68b3e0f64c25b60d6e36b8b0113746c3e9d339f2bc41a0d177f8052b957cfb952f3e717d1cf19d4c54c7e6feb0d8d12f3779c7ca5523d16b57063d42f0de7d7246c67a4bc1f64687bc3f0e8f9b1ea868510a6e5e49effb0eb6a70b0d566206a44472729468efb35a486a9b7540e5fd1787e95ff09c792b4de426acb95c72e9bec4a5423a0a27684e1af3be2a58c7bd380b8eec569443e2c55948a588d13790376f7e9b1a2b9bfe1cd731fbf57458454aad1e7c01403d2f2a0ed483adb27abdb85e2210be55192be19625788fcb6eb1f70a64ae53c8380136a106821f8b1a5a426f2eb1c8c9b2b9fe202da498f163b52912b7e1451e336d52f59ee54440a9444b47fcbf5ded7df801695346c08c32849244ee1f5e32e8b5df10c966cb195f2298726bb482c14e70cd495fc2dbebbcb2ee5991cd5bad8f2901bea444d05172c7ab71c51b48e9d2035667a656eeb78f82dfe7ed423ca40911ab928ec9b4c99e746f9cf94c3018a64f822eaa9c668a3a058ca1586f557f5d53bac4273b777280748598781f9e893dec278ad3138a18d856dd304cdd23b0efe3e0731a084a35e99826cbf9e9fe89d929e1c3b0be47329a8f81109ab53ac2003e16f0074d3a30d5ccc8ffd4d9ec7d91e49c4d4722d5fba73312bdd5e07e0bc4014d2777ef8cddef57f4cea4cf1d70bc678d6d565642e9ee91e8dfabf8d6f1741622f697c9be6d0d99f4cf36c046579e96ef4bf6c8d7c27d3ed099a8cd92d98f0b8d74fa5c13dc07c4ae98d519b4b474f5dff33d57d9b8c0f26d3186fadb5f85e085f1b4f09be2b21fb9e4650873e4b104637a8fdb056cb2cc1e7a06e262ffb7914130411b658e3bf53526e6d923d9bbf0ca5596f72f5057135bc0fb0c27f7d8dbb2f7fa980e4598cdac689fa2b312f2b518c0444e280b79990d8e2a8ca5a1394caae20d3c37925a7001ea51beb84ef8d28c8e6fe53b92f5f545b99af8a76358a168cafb9606770f8b8ee592858b68381ebb322c0c55608dffa9c635fa2d78af010e78a89b24776ba0afc0fba59ea2f2cfdb1f94f7c3226faecdd0d8b99f278c340f9f58585b859a029411a93fa66bfb4511a6eb2d441ab2c681c3d66511cfb5ce9fe528404e1ff6c9fc24d9827a9ede118e31199db6d93c267400ff1ee36ab7db606ba734898472a10bdffb3283edc7a819de00429ceead366e713afe54b5715ffcacd5c9849919007ad76f13de9ee50b8ef93199216391d6f9d49b5a8570f7debf2be29d41b37ec08d1560eef4748adb9e9e57e0206c3f3aabd1b7567ceaaa5dec818678729b11b29eb1adeb51a833d73206406e93ba4106782c386fc03f9868da45e0f6faae5a513923b58164cc605511b6ca2bd6c395ca075bf318956b68f8d7471691371facb2c6fa3fb8bb13af99513bce6e0e1cb8b298f6641dc561ed297da281570e0d10a835e8840d16d9ba09d7963dada1efc67f1bd379c11df68951b6da4488ff3159e9db76cc2efb0789a5fee07a470a66903cdc1c58945363c024be8a108611074bd46712d979584387d094bbd5314964dd83b4c54e74d2785055ad531b3e58ce1e7c7f71b56d4d39dd5896fc31790905f93fda9044fc0935ceef9fdb320381e4eb3f6ef18b7b1940f140e5f16daf85dad689e41e505d099d768df943338493cf857a2ac3e79e5749365d172d1cf16ace1f73cc93cd03286417f78177488efe1168eadc2c602f74f2d9939bac67ba8d7ad16a182ad705f06cdc99fa77d2640511db7524e7e375167c7387080f33b5b94e2b34e056a2759eaa019e46cce0a7a22945ce4e6e886ffbeb297834ace1ad4f9e7f58b204abf555d3db6af46adc172345883ccea4c2e29376bf63dc232472229d7976e41ab31f8594efeb9200119d1c6004b3d166c0c33c7847caf44cb28270998fc5ea644090660a179eeea79b7b4e4b100d16cd89a7a51aeebb5984ef4deabbb70c3e93b13bc99fc45cdb2c035e7fd4a433a52afaee10ece1ded0df52305491be7d621d2ca1398b751792413342c4ca89da1ca7bdfe8e415c0a177fc1cd3d125bb9dd757270b283c6d3fffcf2d611661b23abde94a6b8b6b078cce2a54c43c8c500422655a89f1e550a50fcc959589d8ace836dc6a26a77ec47fe8d3b35d3b03711f45c36f1f6e56abfbbead580caf19ff66171879382328d1ed24b1cf1408939160e4eb7ea81b043228ed490218d942f3d4cbd5ddfa24347e03f834be6b98e4271d4d36e5da61dfc2662c20c7ffdad0af625533e1920c9d25057ca659b21523c2b9a22e341108d1893651a736bb79bc1d1ff9a079e38fe4f2679063c265456a43f425e24899356b1bdb83701c1af36676d1e94025f7cadb3e65ffb558e37d68227cc77486c78b792e851eb16b8c24affebd2d920392b7c09fca694023827583cee4698f108088c133a59b4fb470456c145c35326b783e69ac3361cfec7a0dd80e5bc6fa1dc6c4d77f8887ceb2062b5866e7d4bbe510941fdf94cdb4efc7d9b83fa9390a80a3f337bc58dd4f9c285f0abc7b1442f289e609816966749c8074ec234fa2513f13965f658c6bf4c1f43c1825b60c8ebf106d2e39546da82318e62c0be3006d48ae05cf2d9c270234701f13835fcb654665ce2af9bac7c2832cc15a57e27f048fdde61bec3d63b8be2d760829d0ee15b265d16df2f0ae4be2435663e291c8b3ddfdca7486326f46ce50ce734ec7ee7025eca48b69df2731bd8ae02c3fbc024877ab1c0c41529ffd2df6b39c8ba4d20e64254243d2b44cc2bf8173e8e2ffb7b90b867717f3395e2038ccae25b0090189771af81cdc78e16bf567034d7e0636274b0c4cda1649f168489c075759eac902d0decb53a08ea245e4787b7e605df44d94f37084180f8d","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f05314774f488c7ab0a8185c9eb34394"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
