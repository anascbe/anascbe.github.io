<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #1A2530;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #1A2530;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #F9FAFB;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"16cdda4e34be83bfea5ce0b4e71b92ac8834785ae000f705a4e3135fb753007e979f5260a3e8a4a61f54c76137930390825fcdda96ef53b2ced7bde99d6ee731d2e90757a1c19a302e53d1adec71dbf333c3e7102820374de7b0466c704362af506e27919ad721877c8c04f66c1a75952c3d4a1610e010785162fc2a46b978708e014682c4907a7069694b3b57653569e4f27704803058e68104a40bd904bc846ca1dfe36c08d452f7d13dc8c755b74f60371d2b29012d68456c5feea35e61ab517b307ee7b69c5ba4467ccab4e0453a7f492499ed54dd4b8ae2cabb2995f5cecd3dc6c41d69247f0a27a84ee56dc02f0c3fb9fbf06225ccb56c80c28f5e913612377602562cee623660a53243c577391bfc8b785c399eb3550dd7f1fdd536d5bb1e181f834a059d21d1591af043926314d16ceecd2cfbc6785982625efe468eda52de4517bbff51c5b5a3b60d9d53799c6715f1106c955ee162012e237ec4b7779e6c58f47c29f3492a6e0c042725bbf1337346a39813f901a77e72a268a966158f8d78c3fff396227c5cce346690e45a195102497a8f3b2a9d139afaf01231438b2002c1eb1b3026cb4ec6f12d21ef65bd9ce8af19bc03162917e0823ef0d23ee04bae62f0bbf4e8ae5c8c91c131be5bbfd0ed627995b4438c3a292468a1877536acf64001e38c6ad7d96a4d4ae2a5602d3f781b7593fd9e1e3c376612c3488074bffb60318a543d4d449ac9acf8742ed38a6db94f2a85d4bb3e6eed4be8a582ef844aeb2d7789b71bccfdaf575ee307289115d0df7dce172146ce04ef9f56dbd8c4bb1f1727f6d3cc49b95592fa66957c6278730134933ca0bcb05cbd53f0c89e0f2e7308e8d7d9aab3420173a2c09698af95c5b88f05c41633d2b560254ab2b0c78794b9fe60f80e8cde6ca28dc8e58bf636180995585b44204c5fb9b30afbf81916a4f9bc07aacb4f1036d22f1e7068442d965b3fdd37e60bd0199b981ea1ebf04d7742ee15f4ff546b839ab7c1dcd36f3d8208d9ef2a344981b2e6f21591fcbaa57b839af8f3301bfc7f512e4e444c06f1203a0478e57b476efb2832df3fb3530b5da2c033fc1ae79fe74dc0f43bc9c8dfb31b70561e9d15e6e7494811cc80ac465976640491d5817d9f8bfb580721322d1f760b2e9e9382a33b5dc9f06603662fae288bc4140b2834cb5eef13af306a75660b6c670e63892f146e0ff82f29d950e16baf570dbdfd0f96f1941f9f0dca1a779679fae560a6f030b2321e69b36fe5ffb0616cee2983c8f6fd2b85efb15675e8afe40782410fc9bff7336850ad44c28a4adc2218f3ab1c6ef3f13fce82817c487ba3b730262f7628be8d646553a3784517634654d8af7fc8dabfe1beab67b3b063629e954b81719cf0449d66aa1fee60c990df0fde86d1ddc507e9381b2505cc86d155fa3a96de52c4e6047c0c5315af65b2fe22b15e780b3fcf577637b2d238b55073100537ae2aa1620558de35f9b5a2aec92e35eaf43e192b389df4bed1e34674c7c40ee0d0a7bcf0e4c2dd55183fd6c50897d50612e329d5319a3d99ea4628e86a2f8b8613be7bade874f0312ed3acb2f23d7bd8b6593cbc9120511ccd08235e306e883e19a94da5e80f3046923f0fa5a2116fd752fb0c91c0df6dae643b200639fe51bde25fa8b099a6a2ae09dcd8097a56cb6412a7b0f3bc9fdc23016f8ae105407573dc85d3d341bee3a97d7f5aa4bdd125e96a0967fd5f48c50fac367afb5f1474c021b875fe73e8e5cfbd723b1adb659e0eecd4a5dcd15f96bf75f8c3a977242436c048e4fd704294a84b116fa1b42acef3774af3fd15c13395ee7005e51b031ee454f1277e7ec2d180ad499f409b0bd891e640b556d00b80fbf745e8b4265058d19b4cbbe3c7ab24f8b21fb3cf976f9f3d91642ad6b07d6f6cc24f54c1aeb267b0e3705b8dfebd86139bae9c10da569b7ab8c8b3b4ff19f174e9c429f614cae47a90d3e9c2a0e9dd509d2ee6cbbf50ec4d7d4217e34c919039392a2738a500778457712d1931fd329e777bf147038300bfcfe4bdcdaad96a2cf23a398227ced646bef2725a7de885e4f8c3df184f44133a558cd7c6961a821f98a9665b11a805bae2605ab53f0f06b5a233f217e6564e402520f05200191a5d4d10e1397b3b8ecef3b3cf86ec83877d985ebd737bd7707e7173d4514ce9e15932c084749db10fa27ee657cb6e19c8f357f121450ee567e506280d9d6ace2cb5e45104658a45b2d292950e84b829e3b0f6724dc2d582213e71c36b241b470cb32ae5dfe247bf0a5581bb701a54132246afb473d028b0167c6f6df2d2abd9b165e204a335c68612e03ad61129ca96fa129ac79edd4e54f6cf7fd75bc65e7062a1016e7ca4cb888b28e2303c77b820c0120933ebe5ffd155f62b05834080c28d915fec7c1b4a0f74012e4aec70a283b263b807b276e5d0024b27c862b523b63307ccf202398282b140840859fafda87afbd712dc1ff6a5b4c4a2b5815449e74782b36fbb4056a83bd142817f384f599c9277e7ce1de2e552f2ade21494ae5e3a29c9ce1f06d8143923640f15be2bdfe6c06c53f1ee4282385de5df166e6b9664762913b23bb5a3978d27e53021828ed769df766eb225d2bf7c39614991e0a09792325f96c2ed40a2d095e8342bbfb6999c21d0780d67826df945e6b23ec2cf2998d46d111653dad8201b54b007e3ed0ee320e4314648373ea8049fba3266098a22aca31f2b049388fbbba8c87f664ff50730bb5b123cc2b25052b21585d8e840c0dfe168e84b76d25637c05c74144f6851f37437666117d058035b2d068f0aa082e6b8b6da97cebad8406fd2134a897cb6f6cb58ff450cb8b62026f17a79f330e3355688361fe6ac210a86addea259c0b5ff4e2ef6f589728deda9815a65bc82f17aafe6a83bc6c90e2dfe0a03bb04b8af8c94a9444d0e1093d8dd03a589e71525783b4e37ed9bce701aac57b3a3a611bd4f432cfa8a2bc513c3399f48695fd24b68380d1fae4da77f236eeb9318ee3f37e68906e02089e211c771ea962693bc2942903ba5fa204196df56687ee404e73724beeed395f3e84ff5ccb8d4c4f2998f4553a2899df8346adf3792f130dfe3c322e331bf2a92894cc73717c93f77672ccde91a194bf77dbb9e2aa6c8a93448c78c36e4f5b819d41ff878df578dad6f9657adad22ca1e99d52f6859ce4d31a29c58e5863661b54d5b9dba5365aa5f9d6bb57d4cc4ba730b425ff6c763c217c9f948e9c8fa2df225da6c31b863070229898972f78278b58596d852989797ae9217731fdb56dd8b5312235b07da354613ba86266d71e920776c1b7d92f14b077473f06b7d60d99ace0c54d99c8654ff6480b7f830efaa4f0226a8d91a7dc7c9db7d8316002f888c4962948517e0c89c31984cdb0ca9881cfca87eaea555973982ed332c280de2bf75befb6e96b3164793302e85c9acea92f1b75433b1274589ef5dfbf72999bec5fef62501d2c67eb7a10ac1566b8c95a788a4ffd1438dc11b3f096982f768c89558fbb66b16b49ee4addb63f8632e75546dcee33ab0d73ee92b723f0a47fdc31c87c87365a2521ac70015a2754a36511bd10628713127cc6ba9a824c3639bd0a003d46347a6961491bef3db83bd9bd93f3b59663afcf3724ad91942b2c0cf0da7a7e9d362d2511e9a7fb9af9c8ca624e73453a7cc7f76ac3840c09f6cbd881bd2b7e210de0a8232b34f6f3133f743d25be480358fb423aa15127c56ecf57a5b1e9a177fbd5ee36a7975df61770cb0e7e99642f67d17ee858ccd4d27796cbf52c76dad6710e7bdef7e14817e657f2dafb0c4b8e262b59b6455f8a1f254f3a7feedc21c20bf73e0de8209a486204a785fb064c18bb01952656c0533b0700c3aade192583e4506fa72a711a703abad226c242f52d9a1c1693bac3aa01956cdd0c6cd2a44277d100a92f706c496af7afc881cb97c8e877765b78a5325b78ac721b1df85bfa3081df31b5b22e24ac92c9296e95217efccb04195915fc280ce906554608a500e524284f4550d409cc278ac15c85c41614970ae52e9bbad46136e07e5dc9b804cfe642cfc69097e9d9100ee87527c932469fad2f36db6afb6559c385fd584197c47c9d2e771463d09573462fc045477c666f65cfb1f7e09009b7ac37e1ab79ca6a254830e14cba9453bcac86c6b9bbbaa8ac74c2769c999919ba0d194733d70cb843b88d076e6be34ebbd9c7b24cb6c538b73c848f24d192d97030bdd9a5a7b3c308ddaa609562ac04df3a8b20e1d7a23a56420058cf170820de1079ca49329e8248fa832b8c3a2f4a0cba9041cab901027e2e4f90d96d65776bd7577eef2f8d3ff96499258cb4cba3e4ac842752733a5b40df8e4d2216d46629428d364abea321e2a0b2766e11b30693cf50c3ea4d2d9ffeb536ee0117531d33a6a78f33c4b256aaa49b30e9165bd1cdcafa413650f0ec2f903d30a629c3e58947d61a3bf6a908a164329173a0ed0c54689051cc4c595c9e296015b4f856012a94eb54b81159070d5fcd533d8b1a01e96bb55e996cb09c48eafeb9ea89867efcb50c8cb3d7c515fb6509cdb3d69bf7216417dbdfaece46b5f879f0c691759db0216dac7caa3eadfda294e8e11d4ca5a6a17fb55cf0fd746e9eb1637f1d44cb92ecdf1b9733b8280bb959ac96fb5ee34ab7fcf051452a0dd95e60416ef4b641abfc41e3852b4b90869fb9159565c8006a9c693f309eccf2bc290eb1441c28b323f959fd40ab582776336d6d3e0edde6d56589ead589cf3b31ce9c681ca7e5c93c7707f2b2711840e5fda3bf1a466bca61bbddcab1c80cee81aff761a6b3dd83f16251cf6e2269fb4a726e4ec2427327bab80cb34d9d042ee34668e996dcdace2a60fbb3c94c52c8f88d178e362b67f9669bf0e5bebe08332a2d6952f9e3436f6c06a8ff42d47ea58d970e50728a792ee80181a72abcb23b97da8a2c349bde4c493988ea22fc92a116256fcc94374b76cda594a1841569d33603be00b3a7c54d4ee3dd4693449c985fd781a56ce6867f7662b6c28934e49aef136925472de7aab52795b3d6a324fcff1601a6abe5637ded984a00162ae17bd601645a01e9002fd10dee7f882ec0bc686553b2d745c022a53884e259c5eb00bc1c42d2c21f37ca09e5959d88053788aa25e0cab671ccb75982bf6900bb02ddf65fa4cfd217bf08bbc07e0c0850545ac93068f579017993cd04375d84da8a6e48574a15dec44d636577cd6e0f2c2ceb11348a1c8f2b4cdae74cb1650ab5b169e0f14e66edfcf2db805eda705bf38fe29c6749b5adda6c95bf1c18194f06a197bc8ef2985dab814150d91e48087c2887fa876625f1e5af6552dce634f40676a4924eb52377b9df3e72f8c00a503f9d1d874a2b2cbdf91482cfaef9dcf36928d71d2ac0a1afad8b3db7362eda1a4ded829ba31453ac7084ee2775bf6870f7ef99a7494d59b2d799ac463c9b71a5673ab3626a8adc7f27698c2d6483d5522f4604031bbab71202f2e0219828e0e5df3ab205e005158481259453d519e8b1540122b32d743a2b5867ad0ee1cb170ae7f6e12e3b01e99c1299d92932203e6cdf8ca35fc391955dedfd37ee6822b886ace6eea963ed236ebcb17af071246096c31691c3f8ea4fa460136ec653c01acaf6405a60d63c59229f1b914f29f66a3e207cba2ba02cf6dc312784ec194506a560ca3b02f740513e128eb2bbd19d6f6cb313ece7acbe88c51c2a7a94fc587d3ad67ad0928c7e977ea93a0a4fb010a0d46cd608c7b253645e36d16bced7fcfbf04cc56af7646dab717a663c1ce37ddbc4a67c8c71291fc2364af5c0f57763512e5e149b25e93a8f3c288acc41cb55f3f37d1957bc519d025e739643ab7ed93a119356f1ece99a00913537b52276d88fb18b03d39886b7d64f7a0fbc2519d6d336997c30f236df0a47837adf66b635eb25b3b2a6844c92db3eca5c530c20f1b77ca6e62e1748e20fc334e107e356887b9978d191df1799368fb72484cd0535c6ecd68e7137aea96541c227e6a481cb59576a2f342c534eb0f9159a94525b2e79ceadbf40e626418ee12cb2790a08a69597f436a3f1d9a4d519a66d720d56b2bc10130aaf170d4f001cbed1e2e6ffd75eaed41a265479af2497058bad4e91416e2f43c03b242954d3260b7726f987c2869ee6a4c0dedad0caf7085f274a3d7ac329f8085531a0e259567408a598436387bf03e003871a5bc44b6b76f351a987434ba64766dc7b66514bc7fca13b1b898f7f373eff626bd7c6d0dde54b3d5f0fa11919378a1024b7f25b7c492f2d4b254acb143b7ce2156a03f0ce3e008573f6c5ff09daa3cb5ffa2ad043a1c64590dc8e92a18f7b234c75e616fb8934e7f7775550920d629d152a6dde4401708ed49eec805aeb8169be2ce35f106e0d5bb6beb1a070bcaa1feeb34823ed3e0b1eb12021bfdd78727976a1186112d97a5db46c55067772d74cf47129dca02bbcd6c85503047aa970361cfec493c0190ad82faaf2004ce0639c27376b247573a9105418039945f527ee03924ecc22f0b6e810ccb84e2540a7460392bfbfa2ff43cf59b3f79e377463c73029ac85cddbf4da5a25799258bab7c44074c836a14a1b8f6a243901cedbbb2aa7bd7784048b75e31f5fc25f922fd2672abba42654893eaa5404300d01f851bccd7d3be5ec31569a38a502bf4fc2b89442d502c73a286379a8c3be09a194cc9a9c98db29e98ce4fe5b350ed5f04ff694db36d1f9d2a0b75d038eff1bda6d69aa4c2e5e4ca358db05323a2086c098e634ac9eb37a8c042519289bc4a33b733261fab2240602f766d7f80909876e8fab94fcd575691ad26d9f306f2480048b7d82ee3696de97f7d8c6545c41aca8791b849dcf472f1fe90213bf347ff258f27599ea078c0764253dd9b71f74d505032aeb3e960ce73f0e1352a598747d9674984de5760cb270c53bed4ff708f07c538c6a63a2e01f35c6f7899fa84e28826011cb0aa2abc25c6af050797bf1246bd43c665f72d2f93a914705cca687ffd886a6b26b4f4d531ea2fd0e931bdb2a3fdb40d0487758c0c8c28a510c7b5f99777a0cf4d48b1d7d6a09edaa429accc007ec4690929fe2216c5a61da21a7557a25301b2954e9d652f96bc758731eec8474a5564569f25704dcb7429332c09d0027774348e8478b9976a1014837547559718cb794069715da2051ad5058d3b036c6fa9e29438b4e4445581b2c0b1bbaccc30dc307fd79ee0abd1013a5b1aba6523218293a545ae6f0a82a5405675b14b92a7a66c4bee9cae523dc8c5d780ed25e1550f4f43e9628b470ac3949b4f4d9f670dbefb4d6d57f6120b1bdd73e98c184899b8247f73812d869b58fc1be75d4a8a7e19309faf3cf84bff0f63c5a48547904e0b209617ab2f65e65198ca88061b64ba46966121508fc5bb9d548dff58008d21c043bdda19db9dc64e314ff24bf4b6b15958cfdc3feea85a2485ecc1e8a1d503a2b924d8bc8174a00aeea3162a82498803f89b2214e8022b4108c49216bb07371f4ebe752e7f1f2b07e5734ea0aadd56fe086fed8404aff96163cf42b34dacaaff44f2bc1f014396766edf51ece3f12c1d3f03e46a1ceb682eedeaaf3e869146f838142d5f637c6f7d2069ee46a118695206a6d996f0ee52f6d117b9320c7d6a57c1fdf872c6bf517ef47e35086cc2adffd32d085a7af94508238e7d330569dbfaf61f45a4e2e48a194fa49fd604cb68fe08e522c93ba32096816417aebcf2c169414a0285a7b125ef1be1b9321e58e0ad212606ab9d567f7c5f0318d1aa97f35b1e7020141ac1308689010664a2ae95073f413b940f5605a492e9b1f3669d9c6c5c7b58fa03bc9b192c40949f4d9530d64212d89cdd06077d14977d4a13eac6e941df909a5b843baaff15e7275511568c0a40554f1993960966f80d4a6fe072913f8f81caedabaac9255ae509f58b4920f055827e0ae410c9656f6a4aa8c3c7fdaa77c3817f4cb8cf439508c2d9da6270ec910a527581666e443c736fd5b8467616133a89f39ab1c3c843e843a2d232775ec8d0f50b14623e06525f0d0f75739a075d4feea6a9712d2f40a80926557c1d31756fca0a1462379777d371e2c3a08666fd035180b1c462e554c04d05e006d453a36da5359c91e00764b3d7e9bf2c301f32737179ef530415d6c32ac342c592c51386c8af678ab0bbe1ed2a7f9b1d9da5154f1e5e2e050cd23df6ca7a85c6f5d81433d5af7ac330a5e065429e9f2b8e7b85e5ffc7dbfcabe3ca8c664ea352e975f53a253ee043e044e9d0d241175453b0b4d02096f32f2622dea3ee13dd4e41abe498c96479c96ccbf4da2de1a2814310fc875276620b6b65fcd39d58247b18c6f75794d0d3a64295cac3d02f0f748687ece3ddb6e552a7f7af9413a03dca8d9bd2c4dc87205a006ab3dd37665658ab373cc0a7547c750d2de9095ff51adf756677ee60b3a9b41a841fa1ce1bcb73109a96203741767d2f495553d62543d3756b7ba2e4895773a5a15e73af34ea53cd4a3f5ab1287014130b530f87effe8810ddfeee6a4a31a067f4f2260af4d7e95e14091ab5b6fa8a939e7f7fad6295a627a56fd9f53c4d340458a805519763fb876b434876947ce6dd81ede2661c5129b5776630112061c2624c6693f15e070858e182666df2ecd7776550e07f1a7b2fb2d930d3266b8393c8193a04de0e9deafcbdf13d82a32cb5595408ee3e9158b1a6b62d90a527b19c9c312e210092a96a2b02990e8672d9ca6ac57ff520c494356e9ca4f66fdd55d97a69be0b2d9e93a1e0ff1f906c5e95bb82b7cc0698a5336cf62314ce4f17344220d831e485ce2ba5e7b58ac72ca5ceb30e76c9bdc6b1cf9618d5dd519abc799216297a5b961dcf40d80eeb8f05911cca72fcd29764d34c77f22035120b3bc480263169028837970d36fbc5496ca084dfd36649c36c180a9ef942f27457ba30c7ddf879f389efb486ac3d39da7d36e2f4f67f457df2aa9959a68c102ea0dd55f1fb91ced57154b84428308b445c53f77b8259d5256a12e7aa4dcf06ccbb7358cb3f0433122d6fb9e77eeea659ce297e6c9cb7c58b1e80d555c4c7eb8ff1041e03a7c00eff9c235a9012e1073e0b764bce15a09c92284fae6f953795b500b23462bd136f95eb9a35522f053a5a1346f9e22139042bc9db8ea561cbb07d32db72dfc3250e8f4ceaa547772baf7a348b84fbae062e3cbc0088eb2e807dab6826dd5a469da039558072225d358b43d4cbfe745ec0942bbacb33dbe18f3dcad52a05b41eb35b9c2dd4fbffb936c1f80a1a98b695dfd4cdb11af87beb23992d0c2aa0ae433aa321e59c8d3866f094b934b35adaefd3169cae6157697d59fefe815f174752a317ad13b44851f7d6a9e3792d71cfc4aba7ace87f2212b4f3340d8ee96a66a974198040954830903efe07484311e71cb0fcac20701ef3484a31e6b38c6325e71102003db40c2bc41286e7630f4a7d0908a8d55527eb7522635cc3639e6d126ec26b5ccf59a43c26e48414f0d291ec921f131d8a5a73cb22f6f1819758fc2a12b36b2d552c8b1b8307271423949fa441819a75723eb56a0c45900b33974dc6828a534ff7b1aa549faa674329a3785146c75150e45dbeda3e163eaadb79cb87479f7a35039f8ba19283913127bf2d5a7138e44ef10300a3c8de79d17342712d9e37193e84545b1b71e66368c4e88467f8c47db6c7cf6a282eef2fd0781adf884268857cd45ea5edbdbc603f1e10c6222ce1e6c5217b6bd1b8d440ee5492e70c2ca226dd89788f5fa71408a7757a2831e523bcd3ef798d5e1dcfabb983a3f7d26f87c39b847a3780933283800bedc86f2203b8c560d3237d94ca6e671fb441b71ba235070c932f4833011314aa52bc9866fa704d863513ba21e4ccaf04709113831da4241a538637dba2f2c868dc35e5711004354918f27fc6733e91189a1262ba7725feafff133405b6f9efc7c42e70180e5fb2ae8efa6cb191f5ddde0126f59c752fff92b11c1de7f9eb35fb21f895bb424557e0a0aab72e0dbb8f8a7137e530eaa28f974059f983eb736cf1f77921d9e643ba5c64a592adddca66e6fd2b9e85e1088eeb3e691f3730f8c86d6e17cfbf9b1bf1241d92886c025e47cd9fb0cd59e1af9f63cb6d12506f6b3c88d416b6be82260bb933dedf94b6c350a985666e11e1db74127a7872d916c8359658edeb4ac6451b5e5f14fe6c385d48023ee415ad7b163d8154dffdaf89b036afcaf4a7e9a930d3bbd4b97e460fa85f856d0df4e1f4276967ead74b3173f4a58fc913ebaec564af2b71b16153938fe5eff446b545f495e1e33a769d987404c831e0eac9f37b30a8e69ccadcb4d645f53474faf3f149ee40c21a77a3c81515ddb723b90d5f6735bdc6ad9d2235d22fddf37e38219398b7c51eb919431bcc56d46ad983bcc6ac261bb361b0f588b85fe2dbdff1b9b72024a47047d6f3f463e57c9e4d481979c0a5ad54f3701824931a2c3ab34ec2e5d1cc12e165908204bb8e1d344d8d147959bd5e9996f184b12c32a02c4bbaadc942e2fc68758f9d1f6752a9aac8812bf401edac5f424c7a756e50b61cda82c7dfd45a27a8eb1016371b4a5d907cfd1e9c6e38d62b948f289e8a2574c938edf011d086faecc8488803f281ff332a084d8835966afb5c36f9f0843e937d72b72792fd6acdb62606f86ea588cba2e64bbe1586a8e42c63275f9484a2e7d0b9106ca609891a8dc5521eedb53919c116cd0975d320a3208eee984f4beebe520030612bfc86c928bc008557d89ff415f3d8db579f9541b624a8e919e307a4ff29ec68866a50e04a7e30c6f5be6390154cb7d10c8de9d52163d13d6459159eacdf0dce4c2bad0b8ca943596ff9c9d6fb44f725798110d95ec3d0383890ca751079036705e70f768937c7f5e6cc6c4a2a7b12c68c5b577ff8449c510fc48a94b26146920321954b0ec3983dcdd0c768f4faa8ee423d76e9b1b29b805baa56c8e312d2be461c2f527136784fc5faa88626d025a2b1dbb16f7c2448a9ec726317245df406b3ad9a263b38c43713c4594c25bc831dc4c7aec78d5375661ecebe87f5dcdcd62122896b4da9384444f86bdbf92945b63c0157b29768879cb4c6de4e1f5e46208e7db92ceff8cf97b545453b782fd9ff992f23b32f67dd18b27f537e37015cea9c0a9233249975f54fb9e8bfe6a98bc921575d3ddd297c8efb9805429b5e0e028355bb66cf62eff27edaa5faa890e53bcc75f92cc9ea0d96c3ee8ed288d7f87faccc6e9cfe79f57fc6735c4b5e6f3fd7e222c821c5a6a6855591e9739fde2748726e10abb4eabca48a27832ff9a0faa9db7b686eb9c57951c2f219a0c929636245305c8af24b66374914715f76a35f4b24010d710a2dc2e3d4acf9917e24342cdc4280e3536e10da0f672d445d4ab19416922789c4dfb4f03cafad4e126c23d6c0b210657693c4ed6c736f7945559056e0323cf37a406debc8765cb5e915682549ae5b1a844165d34ad40132c6882af8e7e1848460d133ab969a10000d76384b1d05f6ab13a2faf6361d5544e20cc8bc43a2b87dd6be51118e7730c947509f7eb46defcd42a06b41673aa6bca33f7749af15d284592c15e119ee93dc29c4165729d61256317bb127a96def3256b98ae9213e458fa908b7eb814fe3a2cea9be3790e87546fad6506bbf81e0406f34c8c3fd7314c7da04ff4bf1a3919c54a788496f45aa73542eba0afea9c4febd59d14bd8af18e958ff19fd0a61c13bb48aad99904b5cbc4c422b5d7e97ef369783d40ddfff157896457bda79a13dccc699d99b49ccaf31c7b0fe7ec817d6176cf2b882c7b0f62b93763483dded8de27eca349d5dc44d30d517c6a4f1696aee60a06a046f7f747ec95b4fb30615c07440457d7a2fbf19bb8be8242409665a3c8b751b75f68664dc6b1ff342cc2052d39c506c01082274be8a3745d88a3a00bf7ddc80da1463988c8583f0c4940e29cc947696735c11e74b5881fd28e8aedbadfdc3ab1dd29e9bf938deda25ee5989c8a79edaaa7af21841ac646ef0bff9bc8eb2b8f89f2992ed5140cb9ab531a2bc6079defe574bd338a0853916ba7ccaa55e54cfc0a74c9c066f8efd7c73a59fa56ea24fb528c5dd3b1ace7f9c5a43155ba033d57098f2d38ed01caf721de7cfbdb340b4c7588149a97cae56bde524b54d2cccd7073bee3e24dc9daad4aa896d6be2a158b30795e82988fb608d71d22526e76362c05532988a93bfc6b7194525706cbe1ca24b0611458c5cd67f67069d96d5d0eb997d217bbef053d0c31ef03536dfbc2d39cdc04dda21ebee92c05c405c980e658d8feff062d70776229acc7b3cafccb6abce2fd1b0b7fa5be6c54b1b073b431e9c684d62ecfb22788ad0784341bb4a1b913667c734787f6ad16703b6f4e6e42f7fbda672a61a592d75334e9f0aa4014c5090df59b1d8cec97a36277d7a9ecd0fec16de968e3ed33ed4d51dff8389bfced5bc3d3f8c03103e0c5fb17bb704d99fe3ed3653bb16569e6db09954ac0a11ecd2d29e09cdea5dca792ca8adf680534570492dfc26f21e18c54924cfc85e8db9226225cfdaa7df62c813bf5857cfc2db3fac99ccb1406527bc270e25d49217b8e39afc0d4ccf28dffe10245ee08fe774ca7811337bbf61c0db58e020e3697dc1aca5222c8e42e24d4b1597e98977309c035b5e9de88bfda140141cdded8593c377c809933307f85b70bb02859a4b01489cbcf6282a4e9e9cc8f8aaa794228851e6890c4e69ab9e8a49c3bcdfbf58a1209fcfbb9ad26bafcb8c6cc7ceea7296feafa99657c58b27355547262aa6a0513c9b4c5cfc796ff542df299fba0c1b8ccaefd4191cf8593831e7165c2deda578b919fc4b6f539ebe1da5e5cfde1fbc4311c7cd6f186718895e0aeacf954d1ab050b237bf2118672e1a18a80735adf96d1e3077263e09deb46f84c39097934d06d016a142cb9a6544abc8f2f499e8fd2233aece71d95f312e33096f46b4f4832d592c96b759020f3bf9fd7a6f18a93b04f21d9f4253332144641289d0f90b89bd4408c6b5d18977f91f662b9f3e7f5162faa718dd62661a3190b9ae28f9421be72cd2941f5758f8a7edd751a7201a462f66cc48373091e88cdd816a9aab2181a0fcd687fcade8aa03d2ac35964505d5fbe475603510761cec562a766fdf019d5f1c49a55cf31f82416baec95bca84b0b8efa8a1701e4b50802bc9de5838a7f78dbf3e5288b4a6708f23043e7ad5088245559a42dceb74de6a8cdeaf84e414d28631f05482db858ab41785838fb5d2d3f05dd8942456a2ebd98d6d893acaca332008253fdb7757a43e59fe44cd3aefa554d44e67fe589c7d07baf1920e8412616ef1d39170d4a624f113a7a3d63b74764375579c881ee9fbf147847fb8c23fbc851523df5f0d94e8e32c9dccb1339c15c907b34dc3af56f8f5c4f5ba51e85ffc215de432fb079b4d5442512aed985c8118e9e2a32eaac1d531fa5f14ac582624e49e93aee176a54639ae7fb57054f00cbe90e6eb074dd52a0492e596642d305296268df8dbdb0a88ac3fe0ba85e49f115812126c071ca5dd39fc1c356f23170fc069dedb0be48fa3ff0ded3d11281328e61cdf1fed4644d91f679aadb3d22cb3512be143a422a551f66fe285b314d325ebe9e5fcdfc65c34bd7f7dd47299bd878f561fcdab132c4355740f027027944c0e631638a047851ce17e3bf7a716c4b52a92b116855c8bdb33a88cda527c605ed43f1dc914be0ba36e7c2ed7471e8f586aab9ed1ffcfa4917bf213c0542d734dc82671e4d75a26468c858c42bc45fdb92ae8d16c444862afdc1ba837468b65a24d3b741b3a585796c98e94602f752080e8ca9a73177c1d339ff1dbf8e067de79ccaa9255ab682c63d90c446983d4e16d7bdfd629fca97aa9fe8a76054540e3fc2ba13599a179a489ba2f06a3989054368d75cd7f73af4474cc353aac712d00d959899d7ed49c0eccea4b043677b5d3618633a21250f970f4c5efb0bcfdf364b5b194540e00e60d77d2dbf252363c2c413660ff5c34f19165b82936169591a18dddaf6fd7307fd4546d743cd24972cc84ecb949fa721c2638d4eabdac50d5f17fbe56ad9a1129b7b8066dc4ce945f3af1d198fe3bd050862337b673326cfdb40ddb25b2bb485fc3149873fa20bb5cacbad7eccaa3e70d3b96ecb285cf2c4d7920b4df2c0c775899d818d84367cb53da4adde3c1f5903ecd782b7c8d11fddde35ae0e25e2c3b06969f8fdc5ae969d5e681dea05bba672f72fc260016ce4d975e3f5a1a2f1c28de51465bfb887e9a7b0fe16b1fcb66df44e877a99529103adea85e49cc8339f0e5175e1a9e83a2692460587d67bb5c6a893437a1ba2e8f355dbdc9c7f6d1b61df09db12c7fd4154a72e9164aeab2d2159ed5dc494618ea4bcbf7c5d6ba0b741ed7bfc6486028410d91475001a363ca4c37520154be2ad71b62533d02a0bb40a8f7f005685daabf7ae5303763e4082c4291b0e2822618215eb61bab29ada5014fa72a3732673b0ba038480c754ed1c694a77036d0a7e66936982c68e47386a474c731d3406e113118cd3aebe6759fd3e568942124cf9c060ed5053dc4bc6c258ce243427293df3b8e6d3979da43df119dad80d6c73d091fc9ef2ef2a236e2d4cb994766970e0dca97fa4a00156d1e00b6ca779cc0ff9bc1271f464e19855bfd7acd1f22be01aa3e6a5b5a3c16af97c346eed49fb6543bbf8d83c45d68b4965a00f9ebfa953efb1da4b2a81f257fbe2e0963ddc09694f718bfa0198ee620fe71837a564f787c4c5f7cbefaf980c51013d3115655630afa0738ea620677a02f8a7216eb7a03c0061f1fa08471343b9cd092e548dbc86cbb0c39015ee362251b324a16b97661909a46add8e2a39e1266f842e51eda1485023b899b4faac8fa553df568fa842e87079af021a589fdff32785ad3f4c9b77f77642420594a1533714d4ab65c905d4cc96cde6f92500e70855edf971d6aa8985762e2be8ede019c71587f4cd8d75a7965487dc7a7cf9bbb4cd5ab89c353335249754b2dc3bfd6671b1faa72c2401e5ebc62daa5b63728fb3d2f78dda116d1ea94ccb9aa0531b1fe953606e283447d32eda1f23fdaf970f6762078b477c4fa9566cb27f11c1779d8f36d225cf754449a1ba05e199b79a52a3e3ad6027814ee1506cabe64e30e9e8959bec464fe1c3e39d065b3c760b2c95b64433c00daef264957b5a504c0c34a597a1e07a07b734d8b3c4ab22189f0df39ebd91e00538648d5156d0c031c97ffbbf1f7d615e420d5a509a5beddc6f56a5f67f4944c870685aa26a7733ddc0b45d58c13f0e7096212406d365517235120ce0ba9abab0a9d6d38fa9391a16637887779e9da083874b466452990ea21ca907849d1e9634d5cfba95b896567e32f2152841c934efd90d32f8ec94222bfe78a5885033dcd81fc20459d181928d2ba4078c9a0cfd7f67ddc813c659dc65336c70b2c85bb6dc9ea8f46edcc6357e490e14a9eb7537e4b6db52943c26e748a907f546b9e8501eea40ad8b95cdaab3dea514d891ba328c2a861aa395bf10af2e6b54aaa8bdee1772e50934f1eaa8e53619a3393ef9f7f4396208e56aa7e7b8b1dc31fd50343e977b6ac968a5a82f0469b202d4bbe7dfc78df6ef5c57ba643257a9ed02f30ccedee9c5c76add8379ac81b8f50d3fec67ba22b919f5732866d3c7226c2865918e3807e9fb747434853c792bc58c933446075c83a88de887b2529d1f04b84136e647c306e8f12052bcc6340b3b123fc8c5cc2d4b5c31207fac22bfa629534d6a34ae9822d922136be4161ed2e36b35b5f04ab345225863dba8d7fcbe99a9c06c68a24cef55f8c57963126e3a9bce27e5980b99e55f66a5f38e36f1adf2a68458e3ce5ae55ae0aeb0b08a171bc13c86709e8a1892ae868c1e1ff25953a212f33ee86d0beac4a082e534949b0850d4277b7278cc7b388b2c1906640694de1de4a1629d22ea281313c44afe64953bac9e08fe2493b9a4355ada199bcc3a83545a1c7d74756eaaa9458189723aead7b9a587e6defb472bac07b241efa564d6e317bf9a6a5583a8bc2e01b320a43a83cd6ba1cbf830f503bc7312ab014213b8df49d4dcf88cf36046618189f242d3605cc086b97b9b80c782213019d8bfa6255e4b2fe626e91d1b8d6f37c6c460a0ae7a2185b216a97a5e3fe67cd4d20ba3a4c75efbf46f6f60b83e5a30dbcd1725624abd7604ae4cf6fd99e81369ca6410251a23154559ecfb316c469f8aec8b4c09a8cdba577cc78cb0eb2eefdd620e18b1db3b7ba405b54fd342d7b22fb33728b98058c62e27c86e50022aca3a73403479621873ffe85679a9b449d7bd59a8fee38a999c83c8b26710adc2df2a105f7d5c317cf05c9fa4d55fccb3214240e8dfa946074b8bbf2b70b6cbacf881914e9f8562efa7291262fecaafbb36f105ce5eb4bde71d40abe570b1516d37eed6d0b1413302289ebafee8639b0a74785a46c80612f7c1957ec7fa32642ca6a9e2fa3ee11d8e92641b97585292002ea927c1105a1c5ebefde842d490220916c2a8890cbb535719334a9bb002b40a89051cdd9f8425c6c94aea3403c45698baae65c63f70901a22e5889e5d1584f6c6894ad540f19af48b792f0c74da7376dc7e79857e67c730df4477f60ba651747183c483f6f05b8295e2b8e9e215623e2b342f7b47a72f86c0a3fe3d0db42ecab88dea50b9d3073bc0cb69f3970b19c4500823b117a7eb3a2f57e9047d887605a7d25b646cf3bc2323263db05b4e3c2c786f26d87c73659acd9001b9bae52e0c114251f0cd1f82ab63e07aa7b970c42147e71a328079dd2aa6ec0a4b6c1a8bd8176ddbad4e19fb2640deaab67c8237bd2210fd699e9cb0f89f63447eee04828190a018e666f3a8e893769514abf7aca4a42adac98947c505aa585f600137ae64a15a29988cc3ba0eda889df05215fd613415156842b24edbc699efc1d1ad67634d47af5eebd851f1f31294c1ebbecd0cb1eaa5c5c77e2643564799cd35d0f686f8cd76d68cf4daf77e141fc526ea3d6f5147db5d81b2117804e2387d9c134d1265cfdeb2f43de72d996188feec4e2ac4a4a2e254ca587c1488d2f0e32d3daee432564f086e27fc6f6c2c2d95c2978485a076fe079dfa2d968f3a8c53efdaefe51ffba880bef86a04507e65333eef8b7b9f4412b7823eecebe33c0ea6543082a998b255983529de210c53f5299755ac277745cf93c048298a431a184e7a4d23dfae319dd132a3f4c0a72e0e73eac59390b4c5c88c300549c7c853af3031ad57568583f27a61363a8eba81fbef4766b49dc510a811a0be73b0b54d79ab3c6f5846bffa8c191a7b33dcb793966b53738d7f358a026578a17445e4fcfb25d74df021bfa2952b84d903be6a2345b13e5caf5de19e84dc75e6120ad3ff891320c9e2e56cec402b3e817cecb00c4af548d4e6cbb2d7611ed1e8350a71314e15558d798f9fa34084bb1020fcd229a5693ac6766d7c2e1888b910eb36229a3c0df138b43c0c13ce207cb7cf983719c212494f6f11d8e8cda44cdea321d0b4c21eb32239f65c3ac79e20995554aa276231af2834dacf793d5fa6ca8c968bf2215f6e8f6dfcf72443659cd1bb37b0e18d66be95dabebe6679205d07643b67ad3c689382b1cad99b150ac2a1d26540d9e67f995a3de0b756c7f4eb4a475168e39682566a0a8b25420acfba511f1a8b84a06d6a90208b3cc4337740247556d79ae858730cc2d734bb200227ad33cbdb4b04841e044935ac9fca4e2fab8d02969c86f3dc298bc80497b7cf88c18dd00e7aa10aa17f686a09c4f1514dfa2815f0dd73a3b163556ac2239ccfe3022c59a38b6467967dc2940af60c56dcce92730b7d7fc56c62d619e785e0001be671468b90a83aff09d7914c124bb2d3262f48d3d0e65a6711e4ba56ef233cf5ef3c98c30089acd81d7703b7879cfa73fd00ac458c1ec96d820d8f6bedbea903c8b0531458480f51a15e51803cc4c57f64b3a73f9679fb62d89441a490bf487a15d959e1b78981a919ab46dc8ae8a0e0af88d8c8970e3157ec015466fde39a1b14783fab7a49fce34cec167dd53aac7d30ba64dff264490667cd9c95dff2f246f95640ba74797b5e2cfe50a8f6bdccdf9be9ecf4ca54eb0937667c4073199d4dd25540ae8117a6a63e5e089fd90b194e80078ab61fcc377ab5b47c16e318e5026a7cad81611405d51b3e3aadcb2be0a9933c02972cdc21de238298f0917bd70bcb2a91ea226e17ca7954459b58d9176a6ca575451a1fe89a470df733442b1d31e470167898f2d4d91ab3023378a37dd8b1adbd1db8e5b8945c0b74cfbba7f4d9dffed8747e3dcfcb834bb253e358db33040692a585ea375291ab375197fc620f26ee7739974c28f10754751279667f0f41b105d06cfd64671be8d1b25afa5c0b1facedf55c9e741896bdde90856fd20f762f00e1d6f52725564f19303392e1c22668a5936ccab713670798ba50783caf465fefb3508dec61e79fab378b06cca7e94da0833c40212748e3822d6c3fe03af50825cc19d741192f331b3470e08b9fc636b787325c61d7f45e6ae110b9b9e74520801b5137371786853a14e46b435f7c19648c1176a1b22c83b8d9d8b96e3a29e6e8482375be6e82b7838fa85b9c09e0521cf0fcaf6cdc63f52cc952e22658c626efc727678425d556db8a84eec42590f7cb961e1d55f19f2e94609a7db620be19ad13cf5d016aaaba6c513afa98260335f0081dd3b0aec1d67a72a90208cc18bb71fa774ad26924c36c19069b9632cd4e573390ef9295c76cd19fa22f0837cd5c580df50cf548744ede4449994033bc0c9ef100fdcb08704366c98bcaf95d24acf8cc5891e4bd67303a20783abbfe8dce2ba5a405042b6defcbede66d16918e73289e3b82fa8ca3aca72dbaf58308dd92c13c22e1705618367e019221d518635be9814bea7a979e92882011ba05501","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"202ca30a2e95114f193a82aa4c78a58f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
