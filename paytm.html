<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #1E242A;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #1E242A;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #F9FAFB;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3f1789de4596f96ffe4e59d238837b232b894cbae9ed2c35d56bf71139df2151cbfd17794d07fb96b910d50e93ff9aef5ec3fe940bb913cfcd7a83b8b000fc6c3aeb34909241822e9cac98aeb16cec565d76697bf2bcaca8709494cf38b5d6e065201fac7671d39adbdb3e36925d2d7424172b8b26e700f844f7e3a47617ded88855d46b37cedab0519f02ee469b1efeb951bd0a70b6d8199f4b77d8e9dc01380d77ed7794b8273f467cb5042f82561bf1cebcc7cf56da65cc85d05200b14c0743bd78bb0f4099ca52078c7cab7fb4d077ced09c01307290a83ac295b15a64344dc9f5ba6b18848ab649573e08d6dcf0a7ff5289643adb9e417236dc92ee131df0cc2c1f323f295091689f93bfd18ec45be0cfe411d04bb24983d2e86a89fe175edc62cf6d9bd8b69388af7d597d1486f1ac37d6a505e7a81b431e56a02f6473f7c4509a7317f101cc877b09e0bbd1e30ae769084d19cd12cd50a8dd69e63f531a7bf68450f606e5774929a45f401de013946083282f5a408a0db3b53364aaacb693919994efb759e1721556ad43a3608d4f12ed0152764c91c9034ea708d02e10f9de3a14a2eb580d21c1e19d970d9dad2d3bab9ef69883647235f53a2213af376be1b5afbef950d7324721a20428f92ee21d51b85f091a35a509660da2fccdaf71cb1da0a90379896062020f0fb04d5c17cd8db2e1c36745424c8a5013a1bbaa3b1e2ebee5a322d424cd9ff46b33157859e0d6a79369c8b047d8bbb76d833b30d6a5d5b446b81e944a0e2d597efcdf81680fcf2a12dc6ee884dc08175ef3b9ecec52f8f3759045da56fecc3e39dd395fa9cca38416fba485706826edd534c442d1ec2d33bdb751235c55ae18ea600595828e5fed79d72bfd7d283c0b9c3b0722571ac405a7edc80661f78a83f05f167f137a6f6bc214ed8b8d57f78740b4434f0310b952c96300038945585eac2e2785f21f00af9e8983e835d67d72fffb987bd723376b645a8b91eec97de5f6d4dd65c3e466c83a7d22fdeb9101436e634a87c1e934391d1df99cc26ff93be3c6e54e865e783df7604fdf83160a98472e4f5fea8af9f5d6deda39f9017412b9f53d7ab2baad7ce019785f2ca943a6d104a12d537cdce7fef069966ed7913b468dbe1b271dff7a710b11c77e4d91abb07fab922bd7817bad2e122886d130ae7d0e58265d58886f0a2ad22c38b5241db94017851a25c35c364ee8ffa4cba136ae062fb2406d7d7e05015e617454dda6bcbef24b9b45929ed2b47c105aded9bf02c71b7d20f050c8195091ab8b5c04f5cf8074817184dab639e401c6c7727f4dfb1c48a00a3eeaad418bf24a5f28d1199efe3c99d90685722b1a98a015a5152b9782fa0bfce356bfa88eada2473439b612a0a6c52e55d38d1ec40398c955e7ff645c9fa3a7ebd09b32d8ebcc4a6fe1977a937895092d7f96f76900591bf4d5d2a764d4ca7e0b83cbeccc33acd4ea2d88cf6ecdaf62ba78a5af516c78af43024fab901839d11e3a6a7ffbb5372dc64fa4ff8eba3a773a2cda687b6298a339bd79d55566dac8fed49d3fe94114f6acc360edd59f4ba6c21df4c6918f1b213ead35274e97ce31448351fe6a653678ab2b2037d3e93ec1765aa2174b8f4020e0bd8aaab44daef7b8de936932fdb65dba5b9fb8e394f3cfb0304b2b795cdea82e785125317518935f2efa46d021f934838f3efc930b409406acef8b93334af1e70fbc75eb5b1d9f50b169754d40dff2a121feb184647f3b858195a52dad26e4604c0efcdbeaf70c8d7a72bc370d858e131e2c224b49ed33c9ec24766879fcb127e32b8c0f43498bf3a6d9420d94d66f44089f45784ed63a3a7adfc7c124f23a0e107b867cdea0aff3cd6647b7d77e218c067051f3e3a0cdcffb1010cb7e0c76af472e56641cdb43573f2b9f18535e8bcd2a15c4800dda57d9cee8caa4dd12d8229869589c89a02d38beebf7199a4681a39acbcac3523632e6434d2f0921f11acadc467e449f790479398108127af9335cfbbfe9a814d8bcc8983afd9bc7634d556f95b80c2c40277b18097e15873bc28b5d5b26ce38db2ee900b0293f12785715750ad9243d748c078d87453356de8b1272bfbca20c4e5fc4066896a7547bd2848301adab5734e04b1ca7dbb9e09761d006c3f9f7a067318785f17a37b2cb73d05da29c0702ca813bf2c3dc685aad74ce611f05ffa0b19075380ec46a0b30ec9006365fad775ee59823def292cdfe18b6f491c8dd8709b6df88d706690e8c23fc25e2dbf6c552eb7ff4bd295be9858f4f95f30783b174f38d16325cc92fafa1490a1b71b1fc590e101b4e9a427ecaba75141e9a83bcbb80cfaf809168a9807d5d6718676ce448fe8d0ecf5ca31f1efe8fea21ee04d2698e805953b4452dac003333376ed82ecf113c6bc75d441fa7e2c8398b114d6c2a8043cbfa28eff5a02508fef31bad84f1f954199b1748f4a7b4885ecf4cd93a42285ce0896470abda136cd51718045f70e7cd722cc341172bb21d27accf87e3f16f48a260b8594c9ac19a391dc8399e992b2f44faffacb248e33bbb227b8088ea8c9b0a104aced21e3687eb0d7e750ccdce929f578b34be29ec3171ae9a10cf4171c1f67a41168508af48b849bc177fda412d0793e04d02cbb44f9e20c41a45117025d548cc61e397c82cc134e3856b79f0233ad945841b0ff0ae2fb313718ddafe66ae9c8dcc0ded1069314bffb1713dbea27e42ec2a4dbfbbe5f6cf61099893fe87e8b5228d423e33edd6e46cb0c25512a1b79a2abf93e090eb3ad8a3416fb3cff3724677cc56439494871b37f5f707523d4e77cece6e5aeac3c6cc36a1e9e3d7be249cae2129cefd9d76c107a2ecdb13b7d14b2d8dd542a8a2cbc786b17355a4469bc2c5cd9461b30de52b3f9fa4952eb7d299dc34c57fc03897602152c82c3d1b45f6ee7e598a0c544e9c094df56b7fb3227c5dcf0ed48f421ddd7a581c9b2047ef394971f1a8edfa99c2c5b61de237d0ba2ea3184e5a7b6376f04669a3cc3b091e5b47a08fd9eda3f5adfc31aca1f7de37f7b7452b752e4b12667d0a53c9cba8ece65c64ddfcac8a4fc88c11b1480dea70de24d020570097dab791a1f5bf28cf1820a3c3e59a1556b11abea904256c2435ed814282c659f85ca3d22bdb59356234072067602bf36b42a17690cef4d0ff10c9408e55c92446fd7c10e01dff939c81629fd69659bbfc3ec7f4dabfc45e3e691f646f9e1fe7e0ee39dcbc1df9d144fe019cd6e455eb2ef62425b772ad719faba49f6085ae981f127603c01915a348593e54e72542e7a0fd41693261c48639fcc50f0b058dd49725bf48218756b0dc5a2837cdcd7864d9be800b367128f12a3dc02c21e23525edf44b1af007f0c36e2df251592c9fe414b5861cb6e6f7d28f92b92b1b01791cd6bb19ad6578589737952aed13bd1e93863bc3c7c924700392eff6a676917b6ff0f4466a0ed17b1a130044f232cbc63e5623d473557a3f6d3b078dd968d651e501597c576d1b512201d1cf16540696a5055d13585051ea7ee01fbfdb97f1a9edd79f97e98d05ebe6bde7879c968a701b99cfa59982c080dc64453d1d6642764bcccd680f016bd22b2690ee3417c7a5545d6f274f981e5a025ff79ca94ad8a40477da0f240cdd3f085d344a644ada56d8347b8ff41d747813e8224c51127b29e9c47c9fa9ece53cd6ae19e8eae612b33111f14ff6dc7ebe18240f22ae5c6cbd0426d0f2e952b272ccfa1d613d2d34332cb116de2882be5d3638d4f17676714a65adf397db167572bc63bd0b4e107e6fe38881cf3023a92a7946e2d9fb44e1c6e4d802f44cebaf101ba15cd9ca6df3154337189905a912209214cab5fdee28ecca349342ff59c012865687a6f7da334013ee3187baf9460957eb20757fd9c7124ee9f4ff2ccb21857d0e78e4b6476f5825c5b8b526e3e455c02877b1c934e4f60cdfecdea2ca850daffe7e94d9daa005806c559f991482bf132b737764e63094c3728b2bc96a8562622434bb102d5f697ff98e4b2bbadd51e6e9b018a1ea0aa38904bbff6fc54e2f6a6d2158667e7a20e5e24cd6f5b2816051f36937715b4e3d6888a8fecb731c2bbcf22719e9374e78177e80f1182d4bd1de459aa58947a3c3666af8f20b180d6e198b35d6ff4a81a2b7c3afa200baa3aa8f16c519204a9224cc3afcee1f12072c9755d03b569deeb38df42f314af283e233c2de23ff2dff66e9846a806a302c12d642b65c719d0a61a9961a8a51a2956c5be5f6d9c77272b3213ee57fec52c7f8888a68db51ca67f90d9ebe9c532761e180480d56065011217560d4926be3e73a80afd6d53a42ea84e414470b3b22838da916cf9ca396fda6e17537fea9665bdc645e26741e6a895e9e153ef5ac5caddb15cb093fcc3039919a33aeac2f2a4a847072e8825cb7bd373c19e03a7b0e74a886c02a4554d99edc958cfe175f9c59009697781b1a4795c215b2cd56fde0af2de54df7fd0cd4b35b9731d69a642fd58c00eb94d45c2f68eced725960346b50caf5c53b3b3fdacf37eafbfdb8f9e601eb8115d89d4c0db63f8eb90b41ea4af96cb896da0d28caec1fb73a30d543c3a3576af14a6a93e047a240713ae28fd39549cdc21d6e393a542011dff48e44823e1ff5b10ecb79a7d5e7b7afe61c9f29cab7bdcaf0e79be546397c885b388c116bac6401c874a312e8907652da08b02dba78cf696216f44bca1f460a2298dbdc8964a5aca5fe0c7686d06ab3a5fb970f2dd5af23ca98c5d7ad62ebfe601cd33ec935d1fcae320eda62781162a18c6b84e4fec736c2239b6bc5481950461d914afc9c5cca194f22fba33d0c0b36468ae88162805a9146983cf4d26bcbd9de820f80b2a038476cba08cc2b6f733d3530f4b552e76f8e5dc7e85e5aa023f0aba45d6a49f00540bbaff7f5a5288a9af73652c12e07d977d3a7ce3c4004bf88cb87b93535b1440912de2a7ac3259f5e915027b4b2bed8384e4518c06553b419142fd12c024b3b2057971b0e23e1079511aab24f1017e4aec80e7fa1008a25b0ed68ffb3dfe93b07642f3dc475481d768550d047ee7323a2673f88df4262430a5356888b40c32b84199df08fc4243c5a3b8b47d048a821d00c7ddb09dafeb89c5dd2519de0d29777b9e10034d2878a11ca0c52983593420883ad50310a7e8931c6a127f0663e35202aab42ea79cf78890a621e1bdedd8fa7d88b976ac03e8f4b2dd109a71ea52f41f75e5de977dea5348d7272db9736bd5d8a45ee52286581ff37a337413e9ab548119b1e682b5f3f25901d1f1e7e27c6af82242834da5f3ea41b3569dcf8448d8353d59cbdbc80c17cd3ba3e709f1d0a06a69678eda2be4b50a969f378fbe9bf56b99c1f90158cd4cd0294c1a8a9dd4bb9fd56d36de0776b9f9fed346f7c566d82020b05564bc1b89d6f13b7ab820c822e5feae7655798c0f7e07330242d4e67cc112ea4d9f0b22b87aa71d5a709f3d3478e902cc87796673e88928f637b549c4cc907af1021f5fd1405d9edcacebf1270abfe51ac4d6c2942b204f33a3466acd224392fced3a0702f18ac33f75681a7f900565b37c605f8af226d00f55804366ea802621782163bb82a0585c5c35348e03420afc5e1f916e74a2af144d39d6e797b48a859e96966e0a0bd104483e8c8e22a5c5160bb7aa1cff8a9474614bd501d2358a8d4ea9a53eb20bdfbb19133d364cc910c33ad19c85a7f8f96254f01ecebc1ad2bfff26fd76648596f1a6be82da1a45cb2627779be89e21c9953ed64a26a392f2f6ab89aa0d1be6d9b19ea2a026cd4e3c196dae9f8d5f139068b3f731583a1e70ef0e565c9eb2d7805fd9fba72bb6beb533388ae0a76055a9bfee8083fb20970ba908be07f60a56d9c0c53f0dc1758dca4bc537de83420651b23e2ef20135905051c83ee36c653cdfd47fa2799c68cafe48aec2dacb1c1047d3a99211e57e0fe2b862c667a1b6ec73245b43300d2db9235ffd9109cc59bef2bba456ba682e53fe8961b517eb9bc32e2bc86d1d2bde8107c035e9e1192fa9577819f6b267e4b48fa1b26c54b6771df836821f2643305e54206421e1035b403853652c350cd1cad836dc4decfb65726b23e9bb636c29a7d94831cfc6775abd18374f2421eab5035369c3c6e0758837beb8e3a7f035825bb6274d468ff34defbbb072b3efb2e5769faa3f2cb7bb34b96157e345ee6735d54d2226176de3844e527d500ce5d1d2acbaaf3fb2ebfa24609a0ff349206b3855c35c8c6c849dff98738260360414f4a1f96e8729a6297accc0074a0197fb706c30cda17c7e01e018496bb6f86fe51c2023516b571708481fe378fd69132c420654b64563618221063381658bdc518d47933ad17cb9b75849ed85c7ef3a751042c8807bb9b95ef19774509a7929fc647a46b4ec848278fbccec89d20a30511531e4ed4e7c2db91fb970089081f14e9fda220cd382608930111b328163aae0e49948ec5c1277c3dba073e3f211d989ddf8b0b9125479a30c55b4257f0fc496760affd61dd5c1a191fce8d8f0242cadc9841dcb55c5615196bd7d990c1caebd313712f08f3599bf427560c19f968ec10ec4105a74fa41e14d1c25bb1a23388884194a378a0f39364c07b101cef343ba4da99f8f6b9cec061c2c6ebf6e83f848a2eef47e10e7f6d52d53e27e268ea6a80fc4e024cd775b96af0676b9fd9e47120c95f61fad1ea16c133161515d3ca5c6a56ec4ff6e91c0675dfc2a6fa3e986a37be3c3c24422ca701ef6f3217a0a44a1b948848de59f3effe7ce8d8d3b15c802bc157339093beef7c6175f86921df2e1cd2e0bd055853a2a750012b33e41b2e1340dac20deb79f1a565ac1fd3ba2e9b2957661cebd3e95145d568c9cc087e70cbe4af43b6ad3a56c6551f49e32bbd04bdefd337673660eabd664942c08a507ceec506bc74d200a9626ace752e108f3c9c7aab55039fb77692e35a43b2726d54ce0f4e5eed0aa5c0f5709df9b048ed950426ed3ceb8133c39515d525b99434e87c74571d689d3d9bb4018620cb8fe9ad8cd71ea4977b7f262719a2e7b56192cc05e5987f30700c81ae97d703231cb02ac5ca73c777c4fe8eb293d8b8516125e847e9443c8560313fa08747912bc9c58d92bb80c4b82f0a3b7773c2e54647874ce59c7a2fdd5b6d66ea1673fbf11bf28764e23c945e152422710169236c63a04c1cb2a52cabdd63c91eb03ac50ef8bf4d1cf3d7a78b35e3f75fc1d6d9b0b3cd9646c0a06cee054649a37d40ee34df3574c7e32c5d6f89da5d279805dc6f149df44ef775ea584b5e088c2e1e95ad12cfffc1bb98f5f4b883f8cd2373266e1fb0b81923c8cb601854e2dabbb352034fd5f3b49c44433fea6ce1727cd693f55fa2a001287532bd20c608662dc6f8e9eb721a2767a4ce3ae1eb33e13c466437f1de7d9c682826967b539ee63d0d2b64ce31443ee1500cffbd621ced2b9d1bc17e3ce61e0f86a2da5fc5f6cbfe91a318bc2a16a4770d4a5d6756956be8e1b3fab32f6406dd99c06219bb7828c1d00af3a4348d93afbf352ede464b6d790a6b2e9d2896506c56be6b8d9b477808474706418c9ece97f3bf507ae38193191a17f76220e2c158e187cf96fe7567237abeabd2d5d50cb21d5c335c2e7c30a201cca8cf5c5ea6db37c729edff96bc5626275a6fc74fb17bdfd01e17038be7046c5b500d5e3e2387c09870e8f2b8d32f90044d9d7e39610d7d8c2eb0465e84784d39cf01a3971ccbc8f9f2bd8272528cda20ccb0704dd835b9b90bb6f26c1e9ef6e41f610fff4811ee48dccf43e966acc5c2e1ddded399960148c046f416473b002c1a0d1d6caabc3f1bf12354107a44549f79715a22f390e3f33b41f74381cfebf2d87492264dbd2c5c68c5a5b3faa80e677d72baa36adb8616c93159fa1cf0b7a2f6b4c9db062b84611e8c65749336c5fa53adad0cb1f278ddeb2b4dc7d5773de307a11dfd382b826ed95eb4b7b48c758321e68c66b13273b9c21ad722ca91feb31542c8c23e7aecad7312fe8550510bde7a17b9ea4df4ec1c8039c0a7f913c15b9cab8eea66e226b68598bf07d4a0808d4866f81517e9e927aab4879749a988c4c2af0abb674f52a0bd09299a3048f962c7e374ffc294172c9bf030a9e90e9caadaba3adebf8b2fdba75c77639de84a4cfa57710bc67821678f4fc93812ba924a90ccfc3ab2d1bcea5e4cb65ad457887e64b542eb3f26bd8beda06d5bc58251244cf46f91ed6129147b90d7a0521f8d0b92a3b97e4cf9daa3806768d5a3aab870a3a68ed40f42d38690aacd39cbf298bc84cef1a8672bab44eb9235f62f6e2e16262d1571d77bd878aa29fb23902e5dd736a9186806b2b69741a2a901ad08e19060417779b01c7f58f905760ead90f30a7b26f3cb3ff3348a6f19ad57c69d1d2d2c1d0176685ad935595231f284895555547daeaf30ad4ceb11ed7671acacc5b25c3bdb2d3e73e1e087d04ffbe5aec25922c3900ca44a1cf9b495d46ebb5ff98a68c777de94baf6f8fcfb76c9bdf2cccf37cd3d857a77f26fe07ec35f2908edf368293909df0fccf029ee5330d07abb0fef51f08a78e54eb690ee009a420cb75daa3dbd7af9db62677f27ce5b1b91380af886d12473b8cae117b3d45558ee3001eacf71a692ea7189a4f4af7e920bcd6d140448226532ee0aca9c545da52af69588d612decf6449d9ec749f235dbc289f742c95d335a1eaaecbfc55a1c99506597192a9502544b35cd0f7bf68e4a7987cbfe9fc422ddea9f935455049c7b8e863318176b3070392d67eb3f7efe2cebdbc64604b3acfd69eab2205b3932876b0c46915ff738b1a1ac6c4c38014d5389fc33f67e0398f3f4aab1b91639a59a27e44e682377ac12aa960370f71224adc0b6f8b5b334a283657e943b52a9a2dd6c9b64b4b094c58d7f750798bee8c79b658d4659462891c288c84f9d8597544050aafb97da9f763c3318b4ea305676f83de74566073275e32309e18a69e8b20074ce564975e77330b739325b4d587d14a67e92dd26229cde8d56479ee2ed4d7d0a2ae7350b9f6af9dccf8c0215dc5b8c07bdabf3a39e7f006ce04aa67c6996ec270f340985276bb20d5d5184c9c71e25893ed3a90d593d70e6497fd16290fc6b9e71e55dc5f916db320698ced184c752340512ba18a41eaedf3de55fb8175f4dba47cb842e6dfad9facb24d8db2f7dd15bbce6667e1c5c4b1af4600fe681db6a34795306f86f13391e46f13bb5570dcdf63a03123c3a15593b6445578d8712f66a42dbd5c35ac46d3fc9fd5e938a2824921897330489ade92f1178d77dd084bb1d020c5fdcca3d45d26517a3c5886542f6e8404868dc9732ce3ae21b51580e36dff496d2198612217d38bc45fdfa6fac33d65d0feb458bb2c555e56b819c80077b9df60fc54a2dc68c0d0f6b32cd11b00a274bee6d76470427a54085e810f27dd930dbd3f53863fa607ed185f10f0d5070027a4791fcc5fb395f833a564903b9e188f7bb04606822028584fe77d6a94158bda5ed8c6210c956db1b16acc938d72ed29439cd3c0e1bdde35863e35eb0ff28b871bd6f17d369cba0a79e6316d217eb659a524ccaad74751a82f6868f4b078c003084b7bfccf9a2983de593296b3653edc8fa09c6737a8561a5faaa1cec7d8af0c8c7c93a6929e9ddf16462d3daac81ce194245b696f1b8566ffecb7cc390680fd2e4a67834faaf9adabbb27060bf8a9381fea3ad2c3e5c189cc9c46c067492cba5aad4c90a6c2059401d1a405408d5f05e7d69a263e86e909b6095d583fb1ee1f0cd5028ddc9e10424c0274ab5c29c6ff553d536550b87d51b0c728c5c42db4c76565ded8b397c8b81993fb994adedf597266e97f4849312f4974ecdad634f6ca582b2f6c4acf474fb66724cd42d8771b6ec3c30878f6b516db905e9d5b71a24982fb46a13269d574fe1bc9c57ad6f5425024283d461be04858138a7a65989782e7f430448ea0e2df9bb87d6682c621287dc89b12591bd78ba26a84417c17d9b46df7960c48fb38ed263065a360074df8434259b566c4a3d06c12c8a0e4fabbea0806dd47c8d615408754c8124b3dd5f752e75bd481cec5316507451e4934316e12316e566016e4b045a248215eeba3610e6ba6621e4cc9e005a89f62dfc202bf2970240eaec8c2784fa566dc8bbf100fa99866d2b76735a5dbdc1697f6fc1694711859129d8a731250e070d6a802e6f31e5b34cccadab7ed4434b04a9dea0392aedf3a4705d45b25daed6a23d635cdb2da5cb078c4073aef81bf16b58a7309576366584e3d684703c38322c5eb6f35384702c07c116d85f589c1443943d10fadcb30d306b5d0b7d47fb912b8b064e013b09d0acedc597c80a78bfae5b5fb2629b42564192cbefe9ca7b8b28d63c64a7fce531eebb1dd9cbaca91b925744e1d4654761362878bbc919ac51a80eb738ad9bcd31adb800d03136390100c7d9a0032048c54bf0cf941b7ecf31d467342d0511311f4df7c24f6aa658e453d69566e08c6f44ddf1dc24e770980a73c1c15e383be688a8f7ef8354a0eb918226a8c76faf1eb7ff28f53e3c9ed8edab87b227610d1bb5a86a0196d23b5793a97ba0541b8368bf4f2ced662923244b809f025289926ca1ba09a65ec12c200334e37d82f8ba79cc7d274ed9cd7c88180caf1f0d445b501e2953815d57a07355aca0b91d6249fda44f4714ba27e75c92855a3a5d0e053a982f60cc7fde92fdd3cd594ae67358ad1e9eec3c4f5e0bc084d94ac711b041e461574b7f43df43920c00ba30c2edca444341b8e5241d7d702748409c4d78964c661c58b9be9fec50ecb643f7e372bfc6ffe3d176dec441948ad1c876bbda67d94590a2024592e1d22c41c1b10d1c96bbee6f4fdffefbfbe7bec6cbeb884a743ac27e42fcacc67c962f4e6d555464ff9b0e7a02a983225f80770a787e6baeff0064facd60233e146e53d42bd0c1272ff8450b3fcd502df7f48b6e9272bd5938a2358ae53b41e0835797af7a1b30cc95a74db8002f6fa61e14d9f9697c70f6a066979cdc991e530420dcb3e45dbcc265c52baeb77411e3da57fd11c298fed697cddcebf6b00ce74d78fcacebf9b94ee9a2c325b33d02f67406d5e25ac2598f702936863f85c45beb52fb835698d84b2d45fe18fef701444831f6c04cacf9b925c1bc3784d021216aa048d200b069238bee58222766ad4c0d7810bddd317dc432f6a7833bff9c397b4b7e46af3cc2520e970bf180492203cd0fcaef60411dd3b285d04ffc5e0fe81a169137a104ae962b7fcd77d7791f4c85a14d66f253e73149a47730ed20317a937bc21610d87915570fb881e038c3996e72229fdecf913f45d82be79acccd9373c96c82d51d0165570bc60f933800922780993f7285ebbebbd8465b9239e7ebb97d90ede9524a14d7ac3d7edb9c447f408ce0247332df9c1cc5e60fceb3455b7babd6c330bb1b0c434f017405cdc06a1c6a96404c4fa9ec924b6bdac4c3dceb7870001cfea3d9ae040062fe059476d0e7d7f570dcf1952d86dda625d0e7c18108751bbe8d02ed4576a9347228299ee60c4fef53700657110e0d36f80392e0d64cb7f096d1edaa07ca88c087fd2963f875160a7d0957d604f58eeb2b298a12972717a083bd1487e3ea16f84b5bd12f771457eb9f2dd336c27591b80ceaf11641bd858a6c6bcaa6de4d15e9f5af958e73c7632b9804873e5f877c8f356bc8fb3e0acf9f81f5ef3067433a69ce1e8a1369052b0185bad5d1245ef4f5337172ee4e7c86d8338fddc1d4e64b20418a23c3448950b169daf1f60f62eae05367ed957b36989421b74d2da9b03ba3ebf82fa4dcb88081a96677961511ed2a831ad1d725aa3b1091c74b360ea0663a305b2b4259ade50e96f75e738a9ccb648ce6d015676741d82884ed1e10827a1f95f57f95898c23f191c44237c2e151e862bcab8ee1315949ba9847df0b7cac801848754df77fd6b45d65e05fb1d2c78700c0a8a1abeb624bac0b62b2bd0224fafd0d7d7812cf9e17bc5678ee22bcffee42cf7fa55da754f00cec04c61bff8f1f6c3f0fd5d3091d50ec91818ccba181501390fccead3120b5a3951b8affb28d305136e1a26c40545f3dfdbfb596eeb667ca7b89f53bfa0bb2f4902e542feaec06b079dbc39f3eaf420410f911abfb608d5ad5626ff4903a3660b2ecf5c607f2c835575960e8871934e5be0b10b28fa57f56d4049595467b233bdc58d7a6cb8b040890e4dd24837593e8b514aace017094ccbad8f01f2e8309c297d7c03f5459c798b41a54a9321919b851519e6700b98c66f1dc6221e24347ed1e077de99f199646d646091a4d93842b6ae482d48fcbbdb63507bf8eb25bc7a81af3c877874fa79d7af424bd9db7b34f7ba555ef121aef7e623479880bb6e4168dc765fdf76bac4620cba7d122b14a43d5b91950712a0314e80c58b281a28902f9a0d3e18d89dcecaddd7b50c7b7e2b1fdfe0d1fdfe9a655f0b1265a6db7c9663f2ca1489bc16d765a97de97a59e71aa61b038108372a7a99da269ef5cbe9b552fb746ffcd5967f24d543e5f17944c200495216c5d46a8e4ae18601f7da1994544aa365a0d60ec4acb6d8d10940f8b8e8b03bc7e8eba5ed5b20936be9f420c7234ff845857aaf98c82aaee39a6d499d1fa9e2f4f051f6457d2f93c2738e068bee5d8a04badb1f89ff3944e48cb025ed668e7c13527be6b25dbebc59f8c254a8fcc96c6fff0ce5e51090056e36170431e2bf995098f112bbb068899709daa1fc3c9d04fc58508cdbaf1ac8a82e14bd6825753dd578d6cd7816fe9852d2c531ebdcb76177eddae2613b916b3387723c205e21b94c87c4609fd254bfe2a7cbbe93c8a84e391c5c3392f2a1ee0cb314846a75eebca40de6f79c67339188d6078970e2092511e18944bdf564334e89210de6cce4654c8d60faa554be6e2187b5bc436553a22ad9146eb8b8df8635dc3ad030a07b34be83d4ce870937b5054480fb33782b2b823cb12931c2411005c248a5e55ab0d53c3a00d635597b049ae208cbfd8d152ecb91f4358e8f7d700e501a084c7036361641d4350766e2c423fbfb29af672a9cc87038784d29200a11471d607c6e06e89b51f93cad38aee95492f9166c0cb0f665934bc54bf5a31f115eec3377ad4f6f95263517f8d31c7047bb49fce2f7895913b4b1d271ec46e6bfa03ccccafdda4402ab0d6c1b2b627dc79df071661aa5965a5293577f27907c2732d735f95fc113bc6ef16d080cb2f4ab99841f104f604d6e7f80b8d5aefd0a85df6c90b9a3f9381377d503359d4bfac120c38f7203f7adf3b8566beac9c2f95e3d3c8a36d1741aae13896ac88b013306bd7f60382add07490431265236860b107268f79643c612b0d4cb5d83a2e13d3c9306086abf1ede5f365ace36d28768528163b2ad416a6033ad21546cc1c5e3548c5502aa05150b5b9487d97d6a0ed70816db534d42e1d451f6a774f8773c7c2264fb96a7bda08e8e6b00ec8b33f5ce93419344b0d9e289b3fa5548e404c32d5f452117a9594ab448f2e2f68a6b7f601c686500adfd7fcb304fc4ce94a4731faba3f1c4a8c2ca2c311c2061ecf25d47e9d50e274f63882344471e9adfda2831bcc80d3a93c5252654e0e8c3d4fad24ff33d40c91fcff5a0cf519e03bd34babb2aad1d32b182e8d76b65398a4cb842dcb376fe46fd88263968787ca830f1669cb5780102b387cbebeefaf8898019f211a56b6e0d1092e975fb2ff8f4b812d3c0c6c895f596786cde026da46a1d63a3ebc98769a862a65d3bb297184245cbd93de2b752ec194cd6106ef9ed6396c40120056a529cad945854f692bc0d83a54df2876ed9de7118a5e80d826ca9773ffd0586bcfd4413688d800009a65e235d95877c173e929d88a0ec007f8ac08039002dee7ad0f96246be79c701b2b8a80dff71fbeda56c0e409b45bd9d6e177dd3451e0317f2b320e3205a6f37582dce7bb4d4319fdf2a58620a6cde7e0f9aed07b437a533f0e4f6f1f4588b68ef4fb32ddf12ae1c0ed61090b1980a6173f223bf9effa70bbc30f1e8ae801d1385fe177932de22ebc23e7659e1ea0b4320f4735e1d3049ff5462c3f8836402f5b0482466b0e2d5eb53ed95f1842ce82746aeea98fac48d68acabce0f436332e749299784c2b86720489bfa722a4f844391dcb18f991ccc85d34c2a843e0e357d34eecb879e71450a36371d859bf49400db1d11be70ded51aa8d0a0520074266766f1e68e0878f16ddb8e81447b0faac5fc8323572f2c0fa3c95af7d4f621e5eb9501fd2f6cbaa3384387933a75ff1db1b2e54b9a4969bf79a0fde6ea2cf9791809f46c2ccf09641c1c090904d7c5d6a1ec16584de9b84828444951d06a0448e9976cc9f5c918f00c439161dac38e6962835ce57eeb68c0d69abe949e1fbae495d09e17a2ed2490fec72275dc8cdab5adb7ce0f3b69b56d65ad94f8aae1a06f2cb611727201595e4c8bf350af1ebbc7a13da004f12bf05ec3ac5eacdf2a2dfbc5643060bf9bc787a3a9063a3fca408cbce7932be726a7bd057d728dd25362496911a4c23a19919f4fb63a211eb75b621a53c675f459bb8db2d688a35427d4ca6673b8aaf738f24e8de376b1ffe4df43da33e3119b63cdd03e052938cb17332bc88549530a31fe5ca7d9ac8687257aef77b26062b1738512cb92ec7d049f39c1ab97ef5173742ac5046fd56e467dc35e1456a91b8bb9e67f3690d511e1cdc5caf552cc01c2e9360ba7dccaa894099c0f42a4440d407cac06f6dd3ae4b14390c9f7d6d819f96e558890e9f868b02cb70445487de76890253bbad5554955be287aa82a1e49b759665f37efe9d4bb8cfd2b86f84c6717cba1fc54dd73878e5a036e61ba1709a03e60a046e8bdd51278f3869a5bd367432481961d495f85819cc6e5d53a4e76e6d04bb1e7e263a629f6e235ee31c3dd62ce62b42adfb5e5f341846ff8e16d7c896c4248cc7cd3470473415adc516f78d436fcef6ea8a8d598ef87085a79bdb2d2f168c1c6013544738e5b1a531c8cf55ef0355447bcaa6512c6de01a34c0f3a770af9965092fcfe2f9201d2fdead038dbb676fb4577c5138d022903684b869ee60a616eedb3b3f4e76dc4b2aeed2d45be3d83d3f11e2fedcf58ef99616bfa76970e142eb1fbf1ca6d01ede9d53476f98c902f754551a680983fc64658c339c18dc3fd584f4542016c1056dc0dac15803cf16285a966d2f786fb630817f9b5e9a6afd824216883b8878cb56ff6ba4bbc7943cfef3accefe4321023bc9397dfcb068f41d9e8ee2152fb77e6def5a74d1102beb189605e7eba290639f4ace5fd04167ca309752f9515894d01302bf3d456a0789e6909f7b0deaeebfde10875b720f30b1988461f5e95d0126d23a4de98dfcfcf32b8d79bded043466c67eb5c2ac87ac2c62f27497208caca02a201be137a33208283d1e873054be7b092209366f9501bbbd01a482557f63231334963f2ab8a5b520dd6e436d2f7e461575293ad6cf1e0e4bfcb4dc025bb627913329a3fb8b0cae71e3acd3116f102470135dcfe1b89040b0b97ad6d104d4967e3fb3059953c422e25b2432ec54ec004aa272bd6a08c30791ee9c7309935132ba51bb93361f56a8c6a70bc4810a58230aac41c418d45271c63415a56d12994e2567208a1da1a4b16327a9fa6e131ddc2025f6a314723badce27a825cd03bb633116125c476370ff4033fdd548b42898aaeeee90dd3b8f584e0495536e413d8073a0cb031e7e64355f799e17deaad7ce0be565e828f7c7cafd269a6c2221621fce4527318c08dc1c70f92cd52eca9f50109a87c57062ca3af0dfd36b51054ae3099b61f5a592208f2c1665971b5030adc90f356f288c70ad0dad0810e4f67af83088d4ed8f3d0a6548c336f566037e8435e2f370f31aa839d0e59413b1fdafe4cdb97649e12a2559c497d9c1031365b6f0711926cacf7a3ed2198d42f2740935396ff0a3eb6e167ac445c8c73c704b007cf43c3be8a5a91028723e416675d59a988596809f62cbf39a0bec0a122ecc78f4a88dfedbb5e2d11f28056c3d23b0da7a9ed7a2307bf3283496c4f5bdfffa2644c2681737c46adb2278d86ea40bccfcf8ab981ed9665234b4edca1ce9dfedab1079053e8a99b89c508f7fc85000611653da4be83b9c7634894847ebf9e15566f2ac5ec5282783791d1e0e8d1455e8cf909110cd74fed5239d5656765a22dda2e64e15ff942803c9dd7a020965692f07880bb1c74a6d78119315b8e15e2bbf6ca5665a672793ccf2459b7e4d391085d86b6ae8d5f45bc752782a66366660e365ab9917c7290441ab2768d9a4fcb9e347d4bdb29d33f63796dac773f6ab57ee0ab0a579f1a7029fec83cb96a709cca3e55f4909f78d5f928d53bee030cf0a613b50c67bdc6b2f6e949753bc2313a2fe88b39f446740b12613dcf4c115b79f9782130fea2c6075b7bbc0bd5d7a3ebe9db88b80ae086b91403ac5e29e2e23bf87b99d0095860b647820b96bb5bf61957e66da9528829641444030de95777d66e8b201c37656755bc77b6f689bda0b68fd73c65fd10337c3dc24004fcc88f27a4220b32df8539a4de4d705f04afd9b8e3289eb43bf9b1c6a93ffb45cedc82f8e792d08ec8d075a6193e56ebe1023a2b2a0c2def90c68911401fa13d8ade494238469cd9f56a341b93db8521c00614b5e6f99b294fcb87542c955c8199061f9a0b5fe9518e8c5fcab6e21d33c28621941f7f4156bf7782ccc67bfe986f4ebd3815b6d7fce2c9ace1ee39d9127fab2b6c39cf4499f4fc87ceee3c016a8702c0484ac20a4d37a2a8513ab373d897ea971bda981c41a54c9142a72648a3eb93ac2f948d55c2e93d837ac6ebd46a1e642e01bbd1887071d74e7449b60fc0a44b0b364553aaf168162465622e53d8330d53130c089cd16e42844d45cafdf820832f36b19cfc899b9018e9b9f99bb9956e22d9e1d542b82769663e1982951af83d4eb45e0d9de6fbcca48307c8b84f9ac4cebe830e05996fa3c34fbb80fabf9137203cc52b667aff3e900273a96252d3a98384a9119484e35ae01e207c12fd03269c57f87368390d75c4fd54a71fb802590e6ac8e2cd934a7831d304ae16268390f10eceb83c5a54bce76120584b79262621fe058ecadaa661e6f4076ad15dcafa22bd24c3dcd1f79ee348b12d7c1c806efc4ce0f8ea0513e887196b6eec553e9f6fdaad423a1030b15a328e83d8f371b18abb9137805aa11525b25da33e242e99cc71b21af5170d182f71e86f86b56c5d78bf8a9b09a0d44010a00e5a244bd38f4752665931adbfc2815d01dd1e2a989eaeebd880c42ae4a6a4d1cdf948d9388f1f10fd3c07bdebde10afb0bf8511f260a1a87e39757ae9e6c3e691f608f7b07847131c44a4fad85572ed45a3b2bdeeaa3de4f7eb5f723d45c256aaa07a23bb0c04b5901508dd7a98e0a689ba13b206602e1d637139113362f8cbffaf85d142552e8153d1b4a63449c0eddbc32fba1922cc3f15bff21ee47f38ea4e98836231e091477b12d66bad746c0bf91eba239e05d69132755bf8e26dbf978a8adcfaa0482cff04f44136dd114f16672f9bd21c35a646bdc35472a214e7878f398a997ab5b79f5e37b4bb44ed11bcd4648905ea050eed324ffe2c0d6273fd5774693e93b3d4671a04a1ba9201511fd3e2383cbc700cbf2c45063eee3a3f11c4e9d630950a1c9a681972f1a3ecf771264939384c222082430fd9c06a05c1a1435e1ccb11bdcb327cea44386480b75870b51d4fc24998c0b8356b12c25ea27291d025514e54da666d19ff4fa3ac7d5aee05c33269dc21ce5d6355462a3c7d7621d71fb1707ea96e500e3c1a7601a82c4bb576842fbc052ffae4cc98028c4b240d750951e51ab64457d9a1075c6586af6f8cdd02f8033f65706623edc37521014a19685794b25d7bd68e5bbd837f4bacf07d807e11774bb4b197740aed242b37f7ffe3c0c36cd15a32431799ef4d1483899ede99f5f1758c16aff5e7f55f281e0dab22534cb05d5a7f93b63b528c48ff44bc7a8b3f6330008e6062e8bc536fafd2c7fb068d0aabc1136da03c4850a1b43ecddd91e9de67bdb84ccf65ab265b74cd0dde7aa3b8bbedeed2548ddc74b0b424753dc72a3420570390780649541163c4fbe6eeb0af36401d0d306b8791dc2ca7df0eca75315349ae9765f924157cde5980fc2278459b85c09eb38c5a62bce3129cb075c1b903dade635f64abec1f3cbf562a15121e5453fa728760f419503ac45a64439a6d7737fe66a04a1e918c7e0bce4d11c513eb05650c8845424f35829e0e3963cd088030607943a4eda61b5d2549a1f327e8188635518b80de21386c3e449ec50d00ef3368dbf84ca42a59f13914f5220cc27bda09b97c879e8e38abb26614334ef972c11f14607d288cc501513446eaff11522a2a0d4795d2838807b9177858bfde893ca61294356c08e0ee319f3a138691f925e4b0fc318bf9496964431d5826709bfdb58a335b88b88847e132eb91d9da5497f685aff7affc38e8e6e421e6ce636d85ea13f788e0f31dd9579701e251fb73ecfa04cb00378c295fd7026179a2a1621e4b0c3b14e21aa43ea2adbef45cfbefa304563ac6c007d727c74f5dcfb9e2d5afd6d8482dcfe946be90dd9678dbb0650cf86c5855fe89f06b4921da9930d0014ceb3f6bb090442fffd3566c3359745eb9f83ca31c52d5b47f7ed20c6659bcd263a0491de2ae2bbec55c14d2fd68f6ffd1a73ae3eb911e7aa17fdd9b16db351d7338295af912f82ec1510f716a68fcd10596d69be689718b214909a6936361fe8cdca3c1d9f377d281770a7afbff84bf4d053e0d5bbc5da0b55e044d426460205efd00cd5e11e9","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5ceec2a4edd1b61590a376ffdf2241e0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
