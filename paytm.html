<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #1A2530;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #1A2530;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #F9FAFB;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"662738720b555a9cb3879108ed8a8a83c4d9ac2710f52e423485f8efaf35a6d301c1832be84286ae217653484d80d5ae19653aaa92a4a98044bb7866a742e5566e29cfcd3a2571024253472035c02110429f2a316b6581b0b5958409d08e0dc3268545b25ba823c25b649d0a5e7098c6c34da5a41d297bff91030b50bd5cc1cc809323e396f4f5e19004ea47afa2e7a88e6ee1b9fdfad2ca99bf534f78eb7c5ed3efa3147ba5a7b76ca7d216ca5fb4afcf6c07eea0b4cb0c5a47db75af52197caed2d0254e4adfc24dc06d368b52bd9982a7bfcb7fae74c969f43a64be62d2ed9beb9c800fe8045932978dd01f30a7abe18b3fc1711c12a552f8781e553ebf5234f3fcf12741d3a4ad0aa72cae44921a8b384f375e034095c8cf8a5c7cbe364e901aa43de15866782f10e03a64ee019760a76bafd7443f3b98a7a60e370e97ca78281c43b859dc06a93f94124b28ad8b59e08ccb510ca85fee1dd415b9aef42949b6a3daf7f2971a51b2a23035b29e3a8e4c735c4a372418014baa1f724d9c060373f0b61ec38fe48e3fc21387c53de147413bea2dd3ea7905d60983b4a57da4e70ab74c17deb7fda74e85d865dbdeb1805fed060a7aef4fe68f7270d2f25c09aae96c352ef377a98b4e9533157cac013f910eb7eb96d39f9ff9eeac179689bf1132a9bd090ceec38bf97abcfce1e7eef211e5eb3112463b4edddeb4b1b2e01910bc4c99ebe1b4c362d0df77281932f2dc2e6920c0eafc408ff105ec6c2cf6f990c7902362e8f8c9d4adde3146c271b0ee568e0c42129f0a02b27ef353d58a0f78305dc72374e02d2171aab46bf6c921b29d64c7be2f0ae96e5af4b987944c4687af1adc5af69c5fbfdf68184d4921cab42fe6f8b0ede32037e8127f60d779a5a796de7686e948104ffcb26c73006bae07a0537cd28c544d74cbf4c18169f0a0aec2f408f003cdc802816fe4b2dfaf3724c33f13c855165c3689bfb860b7af823721a93e14e5d9fd9b6b680c1174caad7d936360dfaaa963f597468556467cba209e7988963b2ddacf598989086fcf85c069697237b092b52b61c2eeb4c7dfa7b5c0c7e31ca18271360d1caf920ed8792b05b5999ef57102998fe8be65bdd33943345458d5a3e52910ea8f57b5e2816cb071e8e96bc44423dd9d2a5cd9cba2d3ba2f029da2ace28431c0bfb8d8f7017f1fb3f5f0d230c586ff6f1d3783a17af23157d6bd7b8c834ca24ed571b33de5d1bb93f91c2265faaad66e902989785ea60a228d4c78c8cde4b54bfdd2d373f6526616b7cd434a472c3dd997eee7e05674d25840ae3c12eb7447099b1bba0bb749ca47ce1c4eb97004084d9e24e43c6ea9accc26ac29e5ada1ecb8539a1b940ca91e6e9b684696b89efa567066466bdd21978ed90a1f82a27ccf3634ed062ad2f7d6a72db74795220b7260c57d16b815215a54f23795ae1bfd10852f6563a516770e42ecba8684eaf23cc0417c71c546091350f652b5bc00580ff1791912e38c284764889cf748df85fe1b28440dfdae46b55338add10d1fe42f6b784485fb4d0673503929da3f0ab4e17c7ade0fc9501c729d0d78eb027854fb8371821542d5e72744f3e7a4ae475f9b95a61a268da9c56ebb7d73cb541c4a207be9eafa246a4c1e3ac783f959491d0717336dac60088f6e4eba5357a41e4dbf8559091c4baedf8f36575b0e41e81a805833b7d7a802243b6ed8e48b1f8055a3482798e58a30a9f92673a2f3f1ec5a6111db402f144e54a2ea1709b4c0514cc1f32f49a517ef5056b5a3af13dde756e641873df403bb08511df4286f22218507684cb45ab9352dfb1287caa3906af505d8f0607116301591fc79f582751d626b1272727a51e1fccf81b1c482af1fc3a54bad3fbd2ae9caab968b38c262e16679ad5f3ce4c45191ae0b3ad0c7e2b55eb237fb038a99c7be8ab78be0eb6a910dc588317802eec23ce8a11d36bdee926880dca2be6cecbce32f7157cc8a8d38ef512a48899076971a42e1dcd5b0c603d2e8a628ccd23e7a2e3eb35daa36a9c4205239e0f1a000aa0883a26fb4223851313241f66f062ccf3f0f5efbbabaac97f07e590f47c2dc98f34d772defe090d538556e194febed0236cdc94e7be19f2a1140d923c0158342808124f232ae3dc8258367c6b9e077ec1ada72c0f8f20607afedec0091104005877c61382305907d2a09c1e283605650296ead88a29d6aa89d7570be3a21f37e8c585a88e7bad3d3d24911ad8903e4f037e68adee60c5820793a94b44779aab0ddf5f4a4b330cb700ecbe36c0e27b781674e31957e42377b90318e0fe510803e31146758ac51361bca0b640198f1d9094f77b9ee60759c39c77fc820e66e9a50d788b57f11519bcb5ec5cd2418445e200bd8a55856874291d50832f976678c5c8734195bfc72336be4abc389022533108b66fb0209765646e72bf726c187742dd6b7d477acf91301fc92abb08461511490f11cebadd4b6dd1fbbb5ca854579dda9e09208825a9f62bbccf7cc6c4cabbd4e3e6d556cee7e69883218d5689c6526fe39b66aafab877031b9eedc74f4473e18e68c21d59bc635c0f49e7635346ba0e4ef1579e709a089978cf786e37f27f2e604a76650b573d343256fa8f1b5ac940f0b64dbbe7380be97fe7dbcf0b0fd39ee77f050ffb2594d709b9dd957d86f40d9219b928b6f1359c618da082689a4bb83e349cda4f83cb589a1c13fda4874582c7a102335b15d5f0aa8a8992775c51eb9adf182ac77611e4520d7a43551833c592841e69e04ea6976da823d044e0eee48929995e091fd426884a3f35bd1e45937e3d6cee36d33751d809839426a549b61bbe5fefc86e01e459b2bd76f5dbc83b8ac552922d87315e7ac91b3320c61d625b3c08b2576cefaf14d86575b2ae14d4d13505d7c07df04e36699195fc7fb9d11a998740d9167a0df2977cc3747667746a358ab79a0000e6d36237a820a42f05ba0f277b51c735ae594a6676e81caea01d29a4facbde597bd7b9669b997b43ef63e99d06594ced46bc45a18931b6bf95e19bbcc4013912e12eb37c5fe5d6f1274024d91cc62fc7030698bba866cb2475ea2498b50fed251382ebc5e3a3d135edf68949ad145f36237bcf57c59de3e72018cee5d0f4ae0964b066233a675a203ddbb3018209c33849316dc95e9a61e56392c4a8ebdb3f1b4a0875322c1a385ca3f8985eeea6cf7f207dd78a69636d48841a095653704b2395a4e906c6d6829771275ed8b68bbebe16522c69ab1dc86561ace4ff6164f4681e71cd604a2933b7d10f162093f8fe131e8a08691a62f1c235486b2658496743073181e31c95c5a72e4b30716f36f674e65ea6fc89d2cab9959f65928f3a26f8fb5e0c40678c104d5ad2648877bb67c55fbaa2018fc203af1c676ab50513b769f99288cb18c39fe4065f98993367d13263d94ae14f5ff25bc870e71a013500837d064de47e7a74a5056aad0a2c4f2cda1b12b2d843a407563d9681dcb130aa5ce2dc60496d2434fb81b9025af8b9b940f63fbb9453e6fe07058cbed947275614ed3cbe499017e90b32592f9587a2f8e73fbf7aefa2a37069fe44210fe6d28f00386fd6d8748ad21af27dc0e65a522b2a3014f0881f1f22bd8a2b28fbe399d8761af5a8adfc178bb403957ad9a8de23b47dd383f430009b0e9e0be815649cd870d3921faa9cbfe4148a695b7c763173477ec72c12f40b4594d2332607b911083cce4322fb2c782ba9e43b1179f086f108873ba84c0bd9f0d22f5d37c624df1884cdd3ccd3f8aa7bd15d7fe0b08bccbb036f7cfe6465cf5e6148b2c5ef9a0a0016d97e92b2a327875b25f330638ed03d57811af534cf544914dc4de45e5a7005c214b37e4e2c2491cfd0f8ffa8f3012545b821b3434d7d69644aa86da83831fb820b8e166240cb268428509651d4739d204b9fe43b3dc2260d7c86d90341ff4e73d87db885fca2f9bff277baaa99e26e337256052f604d8ed1ddaed9136e2cc473d7182db09991fe5fcfe582d519937346fa9c7e8a2ec5e1c6581b6fd3141983ac081a7bfc5c9d615143c87b46fd149d0945d3076732c031c66d440fdad730100e89b6837547d9ee3339b83063e7279ec52064789c0dd747af89e2729014c646daca86f4cc7b1a860e6651497e40fd448c67e1409fc7fa9484a68646c23a4f085896c974bfa2ed81b5ea5379144684e4a758da41480501bde8059d397c96339b8922adc86edcda552b43be97f28f532f033ca581d953b8a60f7f66d13297951e6595175f16e241a23268aeedbd0c3a296019dd8dc8ba2e866c7c9a22bd3529b195bfa0cd15a57ce61044d9f05aaa0925c3e487444355f6b25f094ce4e4fea845dae4290b3e4979a803e82f450eccd2f1a0492a1e09cf664dac339d11009989c003a7afeb66056dc2ea8416c91846d15a72fe8ccf390cbf0ba86cf23909264123d27e85b238017224729f642c87432793315434fa07ed40a2dbb783fa8988e75cdbae7749c9c1c0c1672c4f15f0d612b3ef6afbbb3d523c2a886f56f5a577f6bc39facc5236829e755e064b30414471a03fbe32f92690dc3d73425f1f7189a4edb0e328e4ac59f8bd488ecc54e2ee3664a5c4c18e5d2e96efd382e0d874948cd592d14600558cc785a54c3d1f3898af0b8a4c3ed8ded1824baa29e6ab1ee12133019cc5dec504255eb7c2dc8ca08db9d303de798d63056482e6b34b3a8d728b78c936b1e7871213c2fc0e161ea9ab436d04587099e5f3ca3640db6c1443d057256eb04ca9a90daa2fd2e54d27d03b9b7de06e464c94443f1a03a5cbe6d5c987af8b8af4b85a63b6b8891f8beed580e9ef60f7269a4271364ec27181d55edfbc07d59968f93c084a577fba5b05379fa5ff30c7e84c06d3b74e0739a1c944c40d9c49b38a1f66488cc321f50a7f65fbb3682f045ffb802a123f27b2c9795c75cff67c0394ddff997cb2763df2cbe9bb7205c31831e213ab58e744c86d2502c139e307cf9e28a296da429987939e745c1f0960c6ac20d0c4edc6ee93952d77270f8f76bcc18d4ac5777edf2d0e91830bec2d8197ad9431ac291095e599fce60d57904fa1841bbc977b965ff8e32a3827aa5d163cfb6b194b466d1c5388483dbdb2da914b04c5a78d1fb9374a498832cb429e337033ee66f9d9f6762aecc978bdbe5a3df0cfa432d6156622e7235c61a12aa1e44924bfed1ab621a0c26d8d215efb6f544ea7a83ab4d1381bcaeebb0a50934db939b47cd0365df0d165979fdaa574db04e3d653527cab189ec3635e4fe8baf9009902923fb781898f4ab27af5cfcb5de16b09e23954843970669a7c352b072921a260a3855cbbb7b94ec7607890120aed891db01b851350903d13f9a05290662e3770e99ba53e067833cefdcbbb23d08afd058052afb9914ba79f1d03c7a13bf9c1ba86ef11506701ca05b6fc933b94ed261b1614e54fcf5e55ce524379bacc8538841ecaaacad6af987910b7f8f49bd41ab485773b3147d8c8aa4cf7eb98de98e80584c9fb9d2878b4a2edd8b3d1c14b072c985fd70b54e11658db7f6945f5429bd487b720013b95989a250d369d495b73c01432ee2d125db64df37009b274777e5aca46909c4a2f229ac15237ed1697bdd2e6fe55264285cbb4808c46c42d3e5ba9bd7d64d6fb32668df62fd8ee28d612b2ada0aec2c0ad032a4c04a267e93ccd42640dacee7221dc1f673b0cc519ccfc7246ffe217aa7f1be07d18998e25105985a70c2313c00a4339c5cc3c9daa82969f7cd8d36cb030488ddac02618be0816ff762acd9ebf6e1d13ff587f334a95010874180966126ad49df3fe46eb616950537b388d5dc6eba18c47ef1d3e36eedc7737eb20cc48a29362efae873ab7bab3b4d1153ccfb49d0e41e3ab823b811e685f431275d380a213b7764592722a8c2b0c3b04db40d1b4fc9e890638903b7229ca1fbba56eacf01ff981834f1595a0f5b64313505d5be12b7ca3924da4936497b90483f116fdf08dfdc1d317b271f463c6f06f07c0808945882a9b0d44cfbca54ba9c5b155786fbd078ec2c8a8bb67d8362684e0cd894c72dffa519813db0f7cebcd379a129be2f1261b6e73e3ccea64c5f79cb40b0e74f6a3ea53b1bb06e41a6bf706188c7cd88a8f27ce05c91eee6eb887a4b90e1a25814d39f1d1888510abd066e8e47876bfd7af56450d318bd66b34e6ee542374d032e779165d44d62ad26fe6db1d0374c9d833cdf51d314e7136fb670ac1deb3102953b2cebee2a3f2bdb4410f744b779ce1ff69cdf73eadc2f3e61d06ac4d29ffc349c3c4170df8be798a144d0712883925ac7ad463ae1130fb4daaa1ae187fcd7d9a33fa4d727cf3c0ef2e9cf76aebf38c8107a9c753164d9302f7c77065909d44d5f30f9d8d813c80d3ad8d6424108a41981715f10f906048f82d6b9be920cb8f63d05ff3f8ee8801cae052c84e5511deec4679d53aa34cd6a6224903a58c930be50145c901b1f56aa62e291c1a513bed4a7b884574beec94d2a3bfce7c2f9731fc3aece129ad0a5ae90cb1aa85e3f7ada78a95f3fcc1efa03a7364830509cf676f83e86682eede8757be3e3f72a1658f8d1e404a9686a54c521b628934708acba35b93de9d1ae417f7185aaf49984b31198222540303e0885e472f2638efb653cbf36f6e4e6cee1fc7fbd9571d6468a452006829522fc6d16428dc7195da52cec34153d64fb2e3924cc854155cc5bdc4e4c5bc357b97100a2032b895e381ef06960f97cf96a0ef8932547e38c8b71b0257f23d5ef1385f235627537f19601b87e1f35e40b7281a52a8d5154a89ddab91a3fae87d3030ac6fada9933a1935c233d5f8fd4ffaf17691e5101f558580bbc25eefebf66563402144556ff6f9588e56be377a2361113ad46c61e4a74344ec16f5a4d40fa08ecb0ed7e9fdc9701f1a83858fc57282c33419adcefe2c2e819ab693681a3bbdbf4833e81de47919a3fd7d809b255dbfe50062ee21cca4d2e8317c5f1eaab1b946112e2b86275f4db32e8056da65c31525f13529d1781e220a2100e05d4531f6ae603b7f67caec4ea3b60418d553d71b6f3ab6c3aae2d8bb56b112f4e4b43a09bcd6b8361524f3373af5ae2725692cd06135378af9f06de1377e092ee077cc01ca80463d470b347eef1c3579ebd695916690515ea75efeb8e9331cd8d17bf15c5fc082b689783be0934c94e37409df6b743e373ab909fdcbbe7e74ca23e2591e9baab9c684e6fc4efa0077609079b2429b878aa62bd1cddf6e4cf5336f7361cb24d971613b0064ac7d3ae6c8f59d18f0e49e98a20c0e216f29d6f1f13260da599b2285349ccf4f00b317bc35eee02f23ba0991a685dc60f24bd7029083141917bbb3005a233999dccec19ec125459395508f046fc3e0ccfa5c032947cd5162c5533d4347e80de360d4f907a28755c14db2f940dcd6e6b96bf2fe3f248e25218b2708e0703d6b27a5b0f385724ef9cac344e672717dc150e1d3eefd6ce3a0acbe65df67edce671d26bc55e049b26d91ddd379e43979c7326d6b344620a7e9a79664def45cc0eb045aba8d7c74018eb2250cfabaa30554e033dd533ab55ed333191837bffb21ee4b1f152bb62947980f18db61d287f9a0d72aef8df174f64af4219e5ea8c1b0ff9eb4fbed7d6c653b36f4dfdc963fc6aa31de3e8d89130bb0fe46ee97fa021bd48d30062af67ad49738b589eb0c04eb7d214e1d489922d530f705d53c3e76490bbe6627a764114e45778968ab48ea89b700a6f5808f4f7730dfc2198499a79fe09979a7937258161d0f5e1e3dcc78427f70d2af757893adf57c48f2db4975d58bc5be7a969d5a5ccf420ea7449825e859ab96fbc55759caae5628a3175c7ebcdd3b42dd12a93ce0dd139230b419e62977e3b086bbf89b1e297fcef6e303aaae37e0bdab1a005e612dcb26c127dbbb2bc07bbb99eddf9bfe20f297605ad6d2ef3d562dc591604281871501e73ed1007c2e552eb5687e64e0bff748b8b8f47554d50bc68c6a83fe2e5b07937f5f11e49e0b05f828377a6ecb521de8a78e0c63c4e2663c2cc7ddd9f1721959e953b6b172494f6594f54a390e5227093f29a4806c347137b3ccf5d8e248173b09bb4ffa104ab6ad2024961ad01156c69c9be0da27f0760ab8f7f6b04d9cf6d09aa0bd3fa99297132c3d39dbac383af168fd401d4c14320df66e31898531472ab53d9d0599fb414de9db9b3d667af792654ade0aa3e46f0f0d81a2934e0936a3ba525134663120cbcabb9b5d8ccab4f1660effd5035d5b3c111e8de67ad0083d89d7d3da7c5d0a93aecd9bc12307819c55cc56810f1a49684d783c64c03e208a031ee452d1fcaf4da86b659520430e5762c170a289b314875d31805ee26b6ab8006f66327d4a6ec3aae6e5d3b2e618cc09ab31f73e3fd682fa9e10857ce22c1a602bfb0797ce03183b906bcf8b63d80f1ce182e96c157b798984354eea7fc62cbbfaef3fcd87df423cfdef5adc85485714b1009bab3d16894e632fde734cc6408f014843048cee2a3f006e5096a4af1ab318f8119c6d3567c6afb3ee32246d7b303e9bc2faca743fc01248c3ad47bbd787d1ce8b10b070d34bdaf5064f900b773bc49d432a861e470c85a6ec6d8e83ed14100b1a7582e3acbbb18911d665e978660fedf80f3d2458c1d8673167b9fd5d7c7701e16350a2ad90eb46a2e6f310407a5d26088aeea548df1121edf4f9a319244c4076b7f2e71b70cd972cf9ba37a4c2325fcfa08a2f0cf774d123c592f7e277393d93884174a0f4b8c8e2956cb40813d27f5328b350f48132e42cef225c566dd3a237a00cc8b9e1c17b144582d95f314177a69308443ca96b342cbfb8712ea82dba1bfcf9770e24181e645dd1c872b64c34d3905cb483ba77d414c7720bd88240e9f2dc16436c8f77d93b38ec343a99d4cf9ebd1a900ea5faab2ec368adc537ac1491038df1002991ab8ccb74df8c89de928f1d951717abb99ff6af530cb896cc70e6b791913dcb15db510162faa9d91fb74b8ca338cfa3f5ae958ead1d7e8579496bfa76871b0f9de3bf6cf1fcaf2b4a82ba79fcf36d7d717dcb7bc0a0e7b52531cecfa75d3eae56b96e0e85ce5c32a2b36d992e4e6acddbd2ba356f1b20ccde25e44880946b619393b98347520b537a286ec88f506a6a2b3431d9965dbdb6d00c0fcd9a0d3d5349b27a848511e37c8a71d8f80b48e990d0f149b46a39d9db5954d48772810b520e2509e29ba008a3b4dd8e8928de032c53b837483ac579b3de61ba483437d1827db6964ded8b0b63d04ec106688bb354b693ae4b197240865fc050c325983824ca46b43c5ea83faca758120d29ae857fc9d093f9b7aed0539085cb76b2b54649c5a9a195587abbd2f4a73e0a0734bcc69eadf00e809cd2f90a4db9431a79b876d827869c7ee2b6f9f3c5a706f3a33965ccb7132436c7d29dd1b580ad2a0aacbc7bf6237d4d1cd12f414e4b57e50991351f6459cb86005d79ff09bd962408af9e5da09a972f7999ae013ed373fb8476e4d9ffa990bc42d601e2c96f9e7c57f5716a53da818e96968346817e6665fd7447e90854961dae1dbc645957916422da9c87b6e01ea0ec452ea7ec831d7e4073d6855cf0f04ecaccb292bcc6e6e919d700c44041362b153ce188f15e304e9b75a5d60e6b70b09b72027e5896c3a4e9bcd75239070fc75d9ea09229d12ef294951aca21a819e5d940da9b03ca2f0fef65f0a7d9c796b2815d94fbf58857081ed6f46a0a0dc767d708d2eb65f673ad035782d620d248d524cce87babcab36093166b8ccdfc21fb9d1bfcc19840a92b976634d77129367a23df072554096db96bf0b76cdd96867c1a3f2aa2398dc0d89eea13ce83f75f6e207f1ce2f47384e8ae324bf5fcc89d2c1d0a9f68005a7e9b99ce9cb6aecaa806586e958bfbae794ccf889ff399889dbb9f6d60c626fc5dbd064c22e55485cc19ecf020ab8c32a5ef43e81a6bee68364a0cd1fb390c7653d394f0730401c011b2f5f7a581387c442754cf0a513377fee270bca581f8eadd17b43adafc93c965d060f8a4db0c9d5a1436a26153ddfbc5e605a1a93a80eb9f8fc79b86647757e052984e09374e546de90e910fa4cf978005e1c62fc2d9af97241606135c08251f3acafe3261df572f50824b100957980f15d65e6deac10f540d875b66410f267b2036378bb986d1a76f0943f1aa4ac703c379457427caea2ea3e3ff146dc92ee059e1ee494364255bf6ad83fc1ec3d4b83571d12ebdbd9cdd033ac404a8bca6984e752458b0d247e85098dc44e3769cd0e1b7d2e071b0ddb2a43f9e4390eb553604e042d54277ffc29e9f470777abb4941ea077ff5eebbd7174a5a9bdd5b7635d1f489e8b70ccf08e6e62896f52be9f8dc29aa0b5aab0b1f110ad1d4562c5d7db271bc9182fa81007c4c288635a36b9af47153507ca4cb927d483e36be7a7394e37320f8f9843949ad463bc5bda2e193ea2e9078fbcd19525310c33b94a085e760ef27fe1c47584f2d78a945de55992cbe1bbbb00b87063c3ab56effb0ec0dd80a5eaa986c65b5fa4051877ac0ab88ff0a5a9a6448cf6571930d46ca120c4894ee1b51e641f092da9a53e7ce8b2efa7f8421195bcd33c5b66ac539ffe8e2058c20cb1124c9a64943cb9bc24572f9bbff8577793bc7067fc3019201710ea9829db5f1fbbc7af3cd7a99241e6e25522edabf326cb9b08f5fdf0280bdb660962d3fbe5470357758e0f07a11155a8cbb479d0bb4e3c565e247d37e6a9aa1b5b0d856ccf1eedf2807b8882d3daedee22f24c025b50574245e791c98be6a6d9f38b20e43a62045c06c6c6bd247f35324ee72a36b0c065b7ca55326d1ef747344f0a15f0048316a328cd7a5536737765b859463f6979889065ee743e64b9885e03d7744c479db423239ba4239f9fbef2aaea047c15f70b8edbda5cbb39adfa6850d4f53b825e3ee3ef088eb08e6155ce2f69f057c870157dfb7f336df2643534abf5557a7e85f0cb0a75f1a93998a5438e016c44d2bc5961866b5e3a7cad46a5ba273d77d1fe8a76d1f9b3316cb1f29664e6f595e1197cc4667e2b592518fc10acf39fe257cd4a7362959fed8d775c49e443efc4c71a878a9aad528a9cd152635b7d40c214facc4c67d2de9d44935870d47e9651c2d76376b5af115f60e202ec0b73dafcf9ba1a9971870a62edc0470e4f753794f3cfab888cbc8dd45ffae054746c42b205a1e272e3dcdead87fa92fe313cc9b7445445c8ceacc5a3b321fbaa4a1ba894fed3ea20cf7e95592794d4b059535db5d2762598c512e57fde12b74e4b4ba80327966e30c6a155341699ec128aace89d50937ef9c95998e4d59ee43c0d671cf5daead5834e63867b9b131499b615c525e711a2e2b25a5a68bd05fc0dcb061c279650cc1a9810ef6e3e1445f2ccbb2f3d465daff9af69e5f598be1e7ae388b30f7b415ba8a988ef08eb53a572c01ec39506c86d63056c1a38f8f1ec8097e494a3eed0ba19ca9b389a59a721daae479d52d844ad84af3475d9e9074414346f1446d01f665fe5ec457dd043f248588557cadbe499f08a746136b6522761360430e2970d1059c27d5f265ed3800f308fb0577227ecd68ada534060d0e722ddfdff7809e8b72e819ab85a49bed3642cacc8acbf71a32ff834b8685fd54418e08925e17674b61f3f0c82024c69e52ffdb60811c18332d7063414eca9b2c0b4a164a1b8e50b499123a3b09f8d8dc56187a3d66cc6c23a6d3e4a7bc2aa10df072bfd5a2073b87e69ce0f66a5ea95255d59a7d5b8f1855202415671dfd7ad30844eb037726d7883b16dfc43a8da89af755e9f0d3fc84312973818dd0aacca80c9a7f2fa6624121446977ae15480e5fadb8c44af0d3bf288ac9a8bd67d35264ced95197a469299f95f4c2c64f0fd91492f11642048fdf9acfd8319eed9b50dd6f80655ce10b0ed766f83c31f13c97014aa239af5fa228f791505d00b6d33fe70dd190ee4f3726f6de11f55c28b10b1900c802ca719523693fdf1b3142220e241d67d9dd8393a54cca2ee380ae9ddde1c5e064eb3ed8c109d34c42c16bacac1c8eefe645c4d41363e9e39d8bad6407540dd763508534fbef8f808a4f637005e56ac6056a288654ef223e857dfdd73ad3eaf1103b637bd4be66886e6df74717a37f873e34698b3df9e950b067d3eb192af8d495c27052659354fca90b660e1413129b89357a917102160fbad3541ed270e4eedb1d61b313e7e0533086258d161b173775e41e35b7b2a57c82d6d51a478fbf5929336385ef673ada9636cd76708a881798bdc9c6d1f4842e8ea912d4f9e3c4c9320be8cbcdb721ea358c7d6cc80696b6e094b2c1da01b0ee4bc593a73a7aa3687f96737367e4ec3019369d543ce384f42375c50ba880876b48befe87180d3bd88d6211a1c8d73dbd78d0e8cccc11caddc9dba22f9739bc0833b73bc2fabf64d49941479d493da4bd063b9ba82b965e5fb4084d4c4028102705669ea59bb21d21d228a5bfc782b0896b8db1c11db37f8cbf10cb17371a25ddfb74fb2cbfdcededa4f18e0a9f0b4c154f57d88c58a65de212fe06b9339b5d008bbc96e4649308647e8ab9bbe44a51f4ede5ba5db8ef8a8309bdbe92bdb54deb436198e085cb376ef510dabcd1cb53044a98edd13ef0694f6dbd68bd5cddf7fae4c80bc08ba186ce093a2bc8d7b29d9d08f67ac935f489534af679a7619d941cb9c86d203874b0dc1457d2f5de17a336aa395c6b72cfbb402bae8081bd65030c9d476cee549e2b9fae06f7b430bc447d045cc5be7a8ea44ba5f368d98849c4877e5ad515114be71adc58fbb8f269919e824fd01edea71137c3ebb926d1e3e28e7e60f7b2be78a49352ec7e160c94c1bcc87137eae4127abc96a0a198f5dde1d0b1f93082b43102b6b99b49374700174cd02fb311d25d66dc132f48407b6209f58ce4fe4fbb70c432e54965358c97e8c818bdaa4a80f656f61fd0da1277782d4cc08cea435bac2823b1bb963cb2751a26afb2072dd041f525b91db55bf759be51e103d5022930aa599616ec584299d7f6d15886d54a908f11f55bee1e08b0aaf526a9b1ca5e5486b39051aa398f2c08e5e6b28d78bd7485acb1f161641f27d03f7f87539f9e8276d170af8034e3b0fca66fa4e9099395f4609655b2f054d8552cd825bd232ef9cbf3304e951ba2a17cf2b7e1b6d1206e0666dce314908616c55fd584f2354823f91c28811f06e677204a2aa49676cce3837acc14be99020f129b1969bb4c6bd89afcf7ffdd7dc4781aa2c923edaba7f999b9c88d92e41dc280b71f909f19fd541e5ede29475e3f01e2b561c6a59188ba1a4c720945abd8676662909b57a0e60d132039a3b8b6c98c8ba4d0e914b098f365683f793274a3271a6692c96d16f07a6d7a5a483b5f1d93ebcbb8ef4fe80664404f727b40a8195428a797a069a5c104084489d260f1addac361a48e31544d1cde13e603689431b6ffec2fcb5e7760e91d9b9c8c466a88de2db2657877a3dfe922437e3be344a4ece5b1e3e53596ef982c5fea5ff8b7e4f19f04969f5b490d852444e65d2e69b1e9c849a75b6153d339fc1da8ac4635f264564dfad1f73e94d09cc28fc7dbc800e51b2394ef13b451e19cb75a8b47d0d3e230c485ffe02326859c7aaedae4a9593e750550e3461a13c517fe8f0c9438996a81e92847202248591f8da1070e243e6de69a86d01084276cb83c6d4fbd2896bcb8b1c58d8c934fae78bd4c2154997c85fa2d73a68e609975d6e4bb6809eee20d7df4801d40ec13834bd50eca3eef7655ecc9eaa4706a06478538ed07a198628ba6ad969ce8e49e5f3beaaa485af7b1a295a00bf4b97320ee157041ffeb452b979a762c5f01c7a684a6f0cc3b3daf7f4811ab5b9e830dac855a74e4f7cd4b0fb1274470a123d4443010036c380f0c339addbfaef2dc028f7e81b59e72d06fd0e3b52d0cc8905a5fd112e33510e3475399ec72e7e3755d2c57c7d2a5cd5f35037a5b3d41c9693d28c95ef508882bea1da6bbaa48c3c56f65344265024536332da471a1ffd416e4e8efdb0093144d71b9439ce21455db0fe7438c70817691a9022e4cb88884c5b5e2eda22c3c6f40af6e6335e3a478e4378cbd09309093a70bb0461bab4c0d8d28505081ae9b690547514b2b96fa50fc9732c1f424bb3de89f26b166fb1f7f42fb02c1fc1d736b0c3248cc74fa57e69cd9bb8ca46ee1b1e0c08630ce4393ac6220fb48721c4fc531d6608d8e70e9d75b560fe087b393b714f2d16750f9f5513c4c64bc060363dbe44949a6793c027181bc6fd4faf7711c32da493660f6162f253c0a5f40e7f1eef002940ae7b22b89c3615721f7071b847d63d88474cdc0ba24a54ee66b84c25c917da4ea31ca600d733826c56bb648150c8846378d73aae40b75783ef560aaf4893a97249692edddad13f6591e84896ccdf46aada7a1d198200d5064404896c98c9d0c5e719727bc75c2cae6624b9782fdede10bc5303b50f2d230ce46ecccb0587ac131423072ccd46797b1641ebb98bf7e49233c5bbb3c47c58e1a3380d2fd93675e9fd5c8d9c3f546077f9e03f6da102621ac7eb7a088acfb98ff36ebb47a30da089a087869a33c237bc5e32308301eda37e3681e2efaed54b35a505edae92158c8d1559aa9fdb35fb6655fd127a3ccf03bcd6f1fb45dab16b01ccb3264170e02dcc8483a2f98895447b77403833914061912a74d45c5f3416cb932b9deb2026383a5711ada2354f930d0171b51eb6cdab17c344d49022ddb159843a2d0a351ead93005489028b2badd4894250a3b41340940b06acbbfcb7d1f27d03fca073614b0127e3397dba1e19edc9ff1a5be0c1813d91ba9e7a1bf2ade61f94ac598ea358485e25eacb53cf7ed15eae2cfe15957f0e45c5b5d2e181715b4bd6122e6959b96b3a84010d16945a342c39435a25c7f346f3e8768f31d93c2021acda30bfeb52b25deeff25860914aa2652a89b0a5ba29e990da20300257733d0b1b7579b54a9a22b6064b9c3fa307df7da01c7742c1286ede29725c8e0e8b2770f0b7f9765487c45f252a450d47a704701e31e4f80b651d46a6ac453fe26942031002074bd9194af1919ab511dc71f1cbf8f5a0beb7570ff43a61030ebb23c009225a0023d6fc34f9cfbb448c130de82f87047ede86c3409ec8b8e446315ba921367059ce6c6027b0183649de5685d7ad0320b95a221b2dc089a3e2896fd33bd7a4f8648d9e0f8d9883cc88753762092baa87d113e9a2ec80edf68f6c55f55a64c587f04a88cd232798a83aee4e25dbf71fff71e2d779d3c79fa2be5f705e103f907bda25024fd9fcfc20b0ab93f730bedfc3b9f05b6aafbfc4ff1ab5cd2363533bade4f3fdcd5c9586605d46f27644b26f2e06c6b4acac985c366b344ee1e77952511bd74fcc2d236971c0d823efcc2889c83e90256c9718cfb7abfba44cd197afd0784b08928ce647ec1112da18023d475aead8d66ff45e919fa90427be5c6636fbde74c1e41b0bb7355c97f09ce6459d25249b5ebf08d3eada6b075b5d9b22b36530c64bc0679266df2697eee39050966ff1c6a2403b4fd8fcc260903c4092e8aa0ad89db97cd42a2f491c9fc5f735e11f843b27d282681574e0229228b344e8eac1a1e0f26d6afebf93749b54f31679c42a1071ae9fa78568f45f22e3ada7ccb95f5ad3b6ac0d39b0048cb520c310bfc1cb2fd3da1c30b197967d855a8df559d4e5f7e2b868099a49c79655172c7f4f7e2f258304888d01a38ce1136c9a25695cda6ff101cdb20749e10974111417765b04dbdae71ea38c33bede24532629c5369006e5de18bfca618bc130604cedeaace83cc4b7fbbeca96faae917fa877eff8c0da88707298f97e9a2fe457eb1dcf9adfc05fc5eca3b956ed174226e10bf96d414a558692a72fe131514f145e22f0d9ec0fee85add6c22cc6c3584e24133208c7d21df29baa07933a1c1aa817cb028ed4149c1c589e2ce023e66499ff3205798e0cdfe01fa98ddcbea10d82f1ada6bb524a3114b9a2cfac91f2475828c5faf0002ae16d6fa493fedddae09432ce96389f29b85f0d3687af033a2fa4f6e3d5e3898b4b01349020e179b49c1a714cda9d55e79e70cf2fccd3d5d83f3dcc36f8c55d41ad735535e1424e65683fe8ed7a0b12aea8f192663c5057903935473b8afd77e503e18f5152f2e5f9117bc8c5292a5c37b8b764af058eb087dcc0d7e289c66c23f5ad712d2314d335367ce5f3ee105250a2143285d1fdda482abe34a53a2fa9c25a8d061062608bac3af491ad673c635816e7385aa1acd2e302c2cf1c7cc4f86d0f708d7286270a3eb695a77182424657f0e985e172844103e7d97122a68426b58a3aba82dd31f9a64feff357683698ef7fc31b543c9b0107162f008cd980cfd4e0f5e37e4b72ca92c56c4bc28f94e0bec649b76f43ab985d32c416312b47a5dba146491fe945e8a508a22716cd2791be0f3896866a59d2117a0c717657e28107c75fcccf1cf9197cd01bcc394c976ad9d07e08c155ca48a6b6841bde498e7fe65c5dfa7c9192bcaad8a0574cc1f6d3acb107c414ddee82550cc88cccabf1199a0a0805a62db2b855c986caaa6a912c546431b3202dcf126a40f05cdba7e11ff352963f0cdfb58b8c9581ce04c189f6e2a718dd022fb714efe503e9292f920cc808e943e1784ea8313ea793df17b0a6f0fa71ca24d38f1749b4d78518a5ad89a277a3b6f65d048b73f405b108dfec0a658cd0ea016efb9da1cc27cc711cc5139afa2aa5531d542128fd4787ad50250a20328d6b4b23dc8099e848d9b4db3a0a1311e05a1498149a1bea1eeae06bdbf01337a3baa2d73a2ab6255704067413a40c49a3b026fa532f50534fc1509562e83e1e04cf30b77361a8d7b2c1602ba341e732e4d45b336e6f3abf6f6d7139fda4c0f945624c365d55b7cb2fac53bfed90fe2d0c0e4a9ad5f2cb2f7f42bd69d4b1077ae156282216adb8644de0ef6d91a257bce59e11b643961bb3a3fc31ca645c6486b8851fa62396a3b6a21c7c59e459d98fc95cdb892ee436eaef15ae0de7836bddaabb74f8003b7c6fb28e95a5fe115a4b5c5d822921839466526f6c64ff5afb4d118363272ae85b3ba34edb9df0dd635dcb64c0adec0342046a053af0d6cb7d77a3671d8f323a4244b244d71825ee6b6e0432c32830afbbfa310eeee970b85a3b9f6e4711f98c704b422a01fb0ca327039150a732c6c9886ced38484e0a4710a905de286b731d05db993d40f3578362d5a29fddf1903106e75622c297dbe5d5625e7af80722c891faa749dd60040e2426cbc9f95990ae853a837b33108bd76e9bfd3f36fce45da748bf6a6f8c849e84fee7d2a29d167b241183ce0f23097f3c1c14bad8fae21081eaed760e9d9dc8237318ec991daf46f136b8987cff88b8f95b17839ec544416083a0a63dfd3cc4440f07c55fbe4ea7e408637ee6deac6c150b5b839e7e0f1c07dedbb17269222e3765aa6edf3707e823d7555089f6f92a7878d2fe4e48fbacfd2554e385ecafd12702b0bc0d4156277ed6298d4044ea7bf3734db59c73992e158bf55cbcc280c771968809c3a624871c5a31f50ab4046114a2bb5767a24e2a3aa8c7fb94859ea477e75d7a14b8ffa1c08649fa223b5a71d65b2d6ba2820a0c9734548d7c3fa1c21a7f98f7175a2ef526a87dca5c0ac4c3840484a91b4548fa80e88882908f9a2a86afca8966f9013b167ff862e4ef5cdaa669f56f8b8b8dbb290a866a6eb566a6d7ef899ec4815473957863d6b10e988e870c32b65dd53e1f2f4cbdab4239be0f7b9e2a2b26a784b482efe6a5f12d65f61eab4d8d35c688e31b0f562524d2393c3117ff53278f4a5e97c7a91b1a78e005940de9658193bbb01406718f616f29a3b3de435bb9ec4c7579f731e6d7a65d73fcb79b59aa6944606991ac7826ad9b730e415fd99b485295d4eeab7700db9b7517295ac798342b8531f0d889ba3910bf10730979a5f34c84229e247e15f595f1dcca7167298f0e6ef4c1996b4e7eca22df5d74487900f4df791dc2052bc9029a2e6f767f1cdaeeb2868e5e01492f23de5ec81863316698e90a1839d9d3f54aa7e42f5f2990e65a497b00e7f819bcb80b4723fdb59f3dd5bbd491251881456f19b33b5d0f02d383788814c605b2f227dd5cc4981b607e85b3ef11aefe4617f1e6a396dc88f4ddf4be61a028ae199016adb638711461854ab9c652dbcb47df3cb56b216055f97670ec3ee1bcc408864b6f717366bafeb99b820cbf7d5fd3a4e72e73bc840f0aecc089e29a78ddd0be0345598104d09d17b2fa06c3a3e54edb97dd7fee2c03a1c788f012b0b15081d223119f25855c0169797c9979868ab436ac6b6dd06cc8cb9660f3c1da49e75b87308ecb3c05c8a284a89e52e3e6b84904fdc67886f9f6b527fc721bce02bdcadebf7afc62c8b9a970e8d90017357d51dea3dffdb023c48d1d17c21e1d42d52c769a32be2c07705728844d0be036b9eb69138830341ae57bcedd2fd20148869c8574bb9fa66c43b08c421a70e6e9350cc03a731edad4fbbfd8ec655bbf3c49100739966f4420f7f4c3fa425ba2b2535909d64c656f56517783e4428bccb862c1318d46cded5d49b67cabf2dd1f40636c5b6959f0e083168168c680b932175e5f82c202e63a0da9f762d5f3bbd355d7d22040cca3bbc026e6d4f861d9467200cc79c90b2270daebfe814e932c94fc4fe51b85593127cb3a0eb815afb34fd814131ed8cad38ff4d82174c716cae16fe4427890a548abe8c72ef756d0aacdbc95d88a4578e11c718451ab7a574213b2cc6a8d84f60fdd8aea66248d53a5a38c5d89af51e8797fabdddbaed889bf48bfa4d41d1d67593b3ff87c7e36849f74475c8e9cd0683b69e46cd9c574d57e4dca68d9593f984401227911716ced3f017562ba21c8806a84803299c281c1c481ad13e628025844c6880a25e65f64232a34789603b9762797eede22856ddb427f4ee2060f6ea027d85bf28ee276371c3ae1e8d3d6eb72a44aca214cbb15c5b2c88a971dadaed6b1c3edf20613f1980469a6450ace5615","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ec9dceb6fa59a4009f5ad7f258c64d80"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
