<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #1A2530;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #1A2530;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #F9FAFB;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5f2a7223724c5fc57e750faf9e934050f937f9934ce741ef1677aa4a7bf763736d83b3eb07630458a3522737ac00f312a55cc5c40ff249183ca359708124f022dc3c86cea1d5c9a18109e67d71115a90eb22897249d2ed688cb41d551806b26e15433e6fc7226cc0017b4fab48f1504564873cf520d60b016b4248ae83db7cf518679e6279227299119cb95a4f9f41953e3967949d7b852d6954e6c69dc5f29b4c198fb397682f092988690a9252c3c0566b994cffa3e98fd84d71790a498680285c2031e42c9a36ecffb018b50902a1e7112caf7cf23a4bf7709a692557516f20669ae085d95c6e95f0470a7c5e025f000273cb4a55fa35be52e28feebcaa04f173f8c7f1bdafe4638aa4765ab7cc1c4076cf61d1d463be1a9affe9a10f6f162c8aac446d6344cde58de7e0557d8e79a658d947cd34b041847ef7be80661a03a4d1fe77dad790fe4c7a2a77a5b27bd3be88d3ef79a1e058f413d0f3f079a53c9cd1b5394e1f4eb15e9b7cc92136b691704acb9d6a48dcf4e1b3e708aa1f9da33e06de1b65cb48eb55e80169c9d09e70aa092ab5797ec3750e88ffa72c4f2c6961a94c15f26e2d3b037fe5d900a50aa38fc40e7c1c2ad7c9a99236366cef022b0847b9f37d3f42d5a853f8c033c08003ddc6a75d9ad22dbaafc8958183229b8456313991ff8c8ad012786b9782fcc997e09e2b18119061f154fa20132942b725487416293ba977c29e829eaed82a13a39ead29d1bd93d44daed1be85bfb9e8e0cb570f15a174b050c27436076f19bddb66b6a9cfebea6115dd77ef513fbdcd93b77a9f704b8bb1d33f3ad4af57c8762bf8bbb989fc332fcee68426b2c6d5ddabf455f84ca88d64119de5bd56a317a205304b85775f44a24c88e834f03e06298ff9836c2a010cdfae82d4b7d8c7d4d1fef531a2d3de34ae8cea7da90b1cc2b937de74296d520a4e925d15143b602f0167dd59b55e1d836e97031df863dd8917ee3cc3c950cb0b7b544f0ccfddb313003db5b60fbf6910cdce129abded2a0224e493446983717ff720da1623a3fa10b903b6f56c09c620910ec87dc346d93acd969e6d3476696446b5e83e84bfebbd48a720f1032f2a0f13a1ebed65071424fbee8e186a638b793e100106b325a45950c0ad14fbf25d2d00bb46b25fe31190a0151eb54b1ccaea0c3d885f13137bfbaaa6dccf8ad0ff0a7bcbfb258f40610b044da24952ba7abe70e54a696ce48e5496cb2c5879d52ced1749df3a9fbdd0b25c34c6729455a55c96b193e83cbb742a48e1e393b6ab491c8703f643fb78f710401217a4e42bc5b7727bb335384cd8c66ec993860bece285f6b0efd66595b108825a11f66287c631532d3bc643f57250e2dacedbe05cb42722cee17a36b984ca23caf0c7d7faff838102b9ccbea7f170c0087178c10809eb80bad9c2e0caa4d7987e531d3b2e7737fd5dc362bf8bf6613d52ecfa1ad523a9fe26973b01507c1d501744b958884c31bf84733c0ac635d95e13e11428281896d99195c36be25e6c5874ba6d02a334ce89ed3cfe01a3e83c26e250afd3852fed3bb641d39f8221e22278f804657c043de5fa48697f48fd88c33c11d9fcdd04d3c33b33a3c30cb5f368144598e9e131780c41eee3f16b87ed6a884d306b47b27c02b2f60dcbee9bd2a8a45b0d1351dbba284d4db13db657ce001bb9e896b1412e04dac94d2dce8be858a2ec0ecff915b7f563960b1f8ec15f308d2dfd2ab7c56776be2da002ab9b2c1f47cde6c40a934e122e30fc3ba4cd818d2e11df0e59f6b193c57db02b543b2cac4ef6fb82b676f7098eaee0e13d3fef1c1d204787cdf056a02db451150cb0a63c947e128eb7421c20758f4bf7d103ca4c99f81895426231accc667cee38af87cd7f91dcbc427356ba20fee7b21ff9fe3cf4c0cadf885402915b15975289f9eb2c4974edec939f528974b7477debf1dfe09aacd04f31781430223948681496a4929ef90807b16c871a9ab215d3657b5921a9362761b1b470536b0d4e2b6f1e896e1723d15686628a7e4fcb751af686de71d3642941a59bc11f9007995b218b1d0e3cdcd0731521ba69c461ce72f4ccfa0b3d3de35efe33bc782e3be758650d84b4d7b704ea52ec4502d4775b41fb74f82bb12d41a9f69c0fab7e971b76ea13ea8a95fc2e06fc1e4d0243f82e658e07c07013a664249877a12d8cbd349eced493fbee11c0d0bcd5124a59fa47e72adb57e0effec7d11246bbf9d494eefba876160e933957c9b14362d1b83a7557b1105829ae4351e41d4b1a97b306d0596482f588a0d55e2cf51a999eaa3a5bf1f4311a760fe93a1b899eff12400a5a20c030ba87400698e445710126275d1e86294fc26ee06959adf4988c463d04b9a53cdd748d363cfa6ae61103d9a94c94b69b7649675ed24540d8c66ef69d2e4fa76f4fbebe6b68e933573b7b8758d2826b62c27758bfe9c106118d6e1fe04b3668877aaf643f24f135452dc167e0ac86cb88f35f66e5ab709b572cfb01ecb11c8684aa50a28c3531a95da3548642292f3d7a5c3fee97843c6d739b418efa394096fc946e5de24655263a8ed968160c91ada0f49d8e8ecd959f6001e433ea3fe747f61f8ad11afc87433b4ada51561019d60ab19ec83a773770baa60ac7d6015d5db7d66424ef12f924df8fae67c16e9ccbfae7e14410ea1f29746e2445b006b381a1a7e289ceac6ed00a6e8110b24507cafece800ef22cb1110e014746035667cac4fdb663939fd1b792b196c77c4d2c4691fd11ff2499270c72637ad343244d211483cbc04cf5700a01805188ab985714140d12b63aae90238b3dd593027410c952c36edd0508fbae138cfeba58ca37c2fcccba84c77b7cda6af98f41dba1eb7cca302149047e8796f58d3c54f6a29946a2de56bbcf7a3cae55b5fa63f57cecbb8a01426d534f91c0c190f6d9b40d6d2ea06ef368b3182bf138d30f15cabcb4b6632c7f3b5787d5eeace126147beda287c218473e38ccc23195493be59e4e5007af4267320d64ffc420f981178e1fb1324d0bfcb872e12062aa62b7b80932e2c9893f2865f814bea1405c4f75b7e4b9bafe44fd8a53836c5032b8d6a395040d492aebaf0ef924552a329dbde94141c8532e1f0cf441f6782f62331275a4fc209e651d93e13abb2b1c3864237efb7b6fefa4e06b4577f4cbd01c26473d0cce0ac736ea16134120dc592e75866e090533db4159b196f42b0a74aa7c75b9a6ac5d2ca495c4907e646c4a81f6ca0c9482b21f5af40369c75ef4d787883bb18ce86f6d8893d64e8e0e5a0b8925e8ff4723f4be53fe14457bc5cb66342a25ea7078fa1b60267e16e9c935fafe733efaea80f06e480603981b40772643cbe488a55a8a37c43efc704c126f8e8fd2648dc8a8dcc9f472e61843c7aaa38a4a83b51d8ddb6da77dc5115a97e7e03624cf873552c52c905ffde4750b326a59ffb0f70a516581430fa763d6ef6d16c1a3b05a6f435aa2771dc04c1f8d4bee0ef7fc9ec325932c5b8d75481a99c87f0c96bc87c5c974e55d6661efffe82440be4a515ae23674021e2be7eec06610687a9ccfb81599cc64e51137837a737ab802871f230bf3ef91320ad4c89229271479718fbabf50990cf13ee30d07c2133cd09bb2b0896c418a587a4cf35f0e89d305f42cca3c3b0e0198d2c5a7189b5b995b0c18fe75da5b598a080191ead562a9abc4ec0b74adba26acb2ddd444a0799a380837376f131fadf5b360ef4233bf02fe57fd4ebb8f5ee797abbeb036bac8e9212a63fe09b0ada9291e77f8a8af7734acb2fc4e27e377038c03bc5df6f6fd586245ceac550a637e4d35a2993ad9c44caaf0f03feda1de585684e09299ed5e794f2a6a37ad96201883eed7c8363296295bf12d205c821942b7cf58e8fb7b842e185e01f2ac002473db9d8ac4bd3f1f33fbb4922e852ee6dc4fd5bcc203531dd388072cf938c1cd1343137ae841c98721e4818e3e1ad01ac3be2bb45dbb2d458dccc0ee71178285344d83511d89a6e490b12980e5e5929bac7021e2dab12b5b5af18ada94b007a4640efd16fa44b2348bd44d6b949e935877258771d08d8a73f9c04adb09f39be5880ec5c754b99c3449a3e30cf75cd7317fa0ef4436c33ecdea25433d8a02f7d2c9a894752852990d98514dd6b8dbc08b55a456618f4b9ab19b877b97d61a22cbc1243973b53022616b105fb2c987c82bad172b9c9cd1b9ae52b8c41fbb5d98ed79b0e335493d9d946580a07225ea0cda335fc68660b904178dd4cc81923e4767b8f61f34987e75df93c14f13971338adcc695181122775c097a9a0cfed14082fbc961db1e7d68d47e0a416b15a66df070602da06a4f2236eae9ecd7f4da89d14bfaefb3e7ee4c9a1d9eb3a6cc4239c02781499dd5667c0580f2531bd4ef7bde7d2d4ca70eb1af7a7335082dd74d191831e94f4d2ae3b536d46a0e891babdef0c234381f8ce83a8851c76c6bd19d69cf981a0b00ec7a999f6d9351c48c9aa49496af24af027dd9e63bebe9046f62dd912c3910caf940b181ee14ddd95822f1423685874fc15db003ff1e004441a7014ecc003b666880bb9dff49dbaafd5b3b761e8a14e20f64e89ef6a188aa43070c1e0147cd7a722a0a0ca9b7e31386a56d0656de2022e9baa106be16c6dbea66db332f5096a37ab74999464d48db742effdf6509f74ced87dab992656edb32152460b0245988134ccef963b8b45cc8ebe48228da1b79b5d7650065c670eb5a416f78789d115015b23f1ebad7b3ef891e1297831d234d5a957cb55e70e49f44562095e1a1c5bd4dcbd33a646b840f03d01cded2c37beed8d0816b128a457d1e1b8421230db124cab89cc4f4b0473bcaea4c214e0f1ffd021c719283055a738ef31530fe483e0ccedada2e3a0b71f125dc97f931f9c5e43c88e7c5a6a48aa43edb22c31cf993d1c878eb829fe5b59e561168ff924def4242c6ac805332d742307816bf8c89ba5badbe1f8fd444ae55dc6f32d6712de81df79ba113c30060734aa958d2b258850a8b4d66f37be4fb34143173fe364afa032e43f69f9e14421f0b312d7bc6399c5b0600dec52a60d1fdcd9903ec3cfd42d27c6a623cdb555c848a2e9829ee097f8a398b21b6bd669236175581c177e9867cff83efdca39f89dbb66c468e9b32186000febb141af96b473287cc23d8c3ce374dc09611b1c4dbeba63863d0ba5cd46ab0e11775af847d62e57edef1c2684b935b3eea3bb5c73b4019868a0f055052732d79a1ab4fc70ba99e4aa01f249cd6a53b519685ddb85900e279a80d1c800db5c483c046fc4bfa4d8271af6b0600250e811394e414e6ed5343974e780d2a6255626aeb7939c0f812c1e1d5055bf94da2d35ba822c72d9909d4005a6818b6b3f3fcd3aa040abe384bc841f972a53fb172ce1dafaa5824c347937bc2c87e46377dd372ae964a45a36343ef62025df24d107afc764e068a3ca22ed355737099827944185415cde570f4573fc326250a7c666cb5d73aa3c79345dd0bcc7350bc7d549c80ab32dd420a492e5bdd57e6bf20c8ce1d4f277eec35290f4d602e14900206b329ac3050522f6c5f698f6c3e521b6c61b96cbd71f587f07bdbe85ea6ccf3044554e75c01eea8442dfa54367a1f7879f529edb9cfc35395a0a2e3bf54c7cc825ca3235d40dc0b2dadf84fd562fa863d10d45b6d4be84c8fb0dd8ee4b3c8bcb6be17dc57c7cd71ac6bef7272ef0f8761f8d0d1c7940d01085f61bfe5dca2f976a6c128ddad7c2e42b579bf05d42db0e433c956484a480efc27d4031b79211b08c280235555dfc9c2647ce58d3049afd64a176da6765342758a95d525dc838e30e86686b8e4c3cf27e5da925cc038a4f2d7238374fc73ce8963b9562bbed2544ca4720de718ce3288eafcacb046923e982bed000de39c3e74c8f85e58db6874ac8bb91e02854379a515ba5e921b13b09da6ccc4a785d0b448a9bac83486e2c383f0a219dd099e094a7a0e465ea6c52887fadddc98357770cd279223a78d97ac1feeff842d604cb5a657f37af4416e90a25175970034072098b75308eb9a67e60df837cac32c4b8baa6fd33dcd7df2688452a6680692d3b08c59d888696a05b0ebd6b1eea07484f6dd9fe4b302a7934b10b9e4a465af855034a894fa98aacfa5a4041fe773c88203c9d97a6f77b95995aacf799de685f417c2941d6ff27b561541c55cc1f1ec6ce72533d46e656ee755c771cf339426ddb373ef8c3f9234917bb64dc0c2e023b0ea4985b8a784bf2ab19383cdb13633983f61a4c6f42df87fc97fd1ad79d203dacc3bc94abd622fa68897ed9f5021d887ff902942cffb826f72c2dd3508e7852a59d568ed2c2ff08fc3663a9915976dc0db01cd128b2938dfa264995dff9d1c33b148f0cbfa47913de2c81035b8b0e1c35762f398b64c30e94cf3b8666851ec8f20aa357432f57871b36e250fe6af2f09628581312317d4d3158d82820fdc7e8682f1fec97314f171513bb291cd893a2cdf8fd0f3c7546434cf80c731c21351880fbb4e1ab10424263cd505c95f31bba94f81e1c5b43de3671d2e16a64d40513b8174e359379ca10feb7c4117282ebd40ccd11dcb5499f45c495cc37284b022e5331cd678313c6aee303db75e5db0bb14fc2c153ccef974845c6ce86fe573c08f68c9d723c75883a5d1cd9a3646ad319849679fd7dc2bd36b2445e8ea88ba1a88977252ff9c53d1a87f993ef24b493a038550aedabe8878d725d7eeb94a92affbd4d49c0014285eed341e49745149ef2fcbd0db857eb780d9a7b4618f9c95bb6da8418606aa061d74876314eed13ddc98acc4974c8f245bd6d0870d8f59cabc5682e519f789cf486f40317356886773b19ea83c65723d1f26580e78ee54a00112fceaef6ce82aa7db698ced269fc011d3df425d9c5a2abaa06b4f3a1396c624ce1a330df8cc9726ce67467f722c9ed275ac180a8f99e9f0f7c1daad5585c9e912ce6c932089ba6cb86a60185b62a123c9d56f6326410536d2adc5592cff934ba3bead569113cc0454f7477869185c15885d9957d168a4237fdafde4561469a7bd3d68e43706d7b64c964d6cfd2a522d577c8f35a442099d4ebfc279e512f143f4e99f1e9afca97c44e22a5742eda52fb12a4f7c2403e46a4cd28e50ecf43c1c7329eacb7d72179371a7c84c712ab63c8a4367682a1ddfc5864a84d765b1cce8bbb9f7f2297b8c54dbaa45b5c24d35a1544b243959c469ad1e40a9e64e33e21f947291e8cf9167b3b8e91e9ad661bbfbae7e2e997830b117bf1c8150e49234de83b9a12cc8e6fc6774666a2de91c2c189fe6f76f6d0d5e426b2f629bd64ecaf4e9905cd4ac17aeecacf466d0c3caf0e0070a9c93f5f7c87712f91e6b0c207534442b13d7be6f6ed7b81f5416fa6641b1647291e03f458d87bad73c75d64fbdd29e3d8ffdcb4fa5eec99e5768bd96c7f5cab4f26d43a1af29f02627211f5c3ab2e8e8602fee85033ef0008bcc6a56d66dce441dfe40aab6ec51f6de0e81f4c2e05cf098fa2a40b0c42700a4470adcee2b2bc851f99e51a8a4598095f922138b9df7a71af96b488e09a20c21720d43232f8bfaeed780e4112ef686ba51422220e2db2385c3317640a8f7dc0a512d0719c0753e75756530e67cdd7f014cbcccda55d8c8dd327ef07e33e187f28c4e2ceba3267b22e4819b54fd177028025675752bac87eecb851658780b98a63bfc033ce730bbd0631c80bce8d14eee1d70da5e35aff1697fb9a5d7c1e2e20a1313510555f0ef23cde2609cbb110927c23f467004839dd04f12f819258ca3dd46762cf50d025399693eb78d84bca0908d5a121a070825cd5bfd2e7d11f3ed87def14cd37d43a5ab79afc0051c5425fef13705955a359207b37c046f16f546650cc48e4ffe42d65ac21844d7beb22b5aab9e7a80fef5ffa2583460808c0d579972ea92441e887539ec6a38ada78d061582316057f489a30aa380fba5e72ce63fd568b5a3f93759eda2f15cbdcc4685402c93e6defbb6856264a3758b70473405f9a6fe609ab7dec12afef113f6d0a542730a09420fc59fbe5c87b960b769a576894f22b62a17f95d44663cc9eed392bce7bf5e1187895b837a9bbf210f31a9cad76945d04817b69ff8a6cf47dc34037cb956afb5811ca9e45f473843254c71a2788ee3eaf5f5d43399f616249847e856a3c92a093ac44408be270583ef9b91ea03e9b440443a0d3e76a8873397be8aeee84c88c6280176603b739ec3897533022cb028df1450da4cd2a88f38159e6e5c62b1e29e3a409676f7f0e0102b9973537e2435f03d79ef64f2de4ddc7a8c6a66a497ed5bdfe668de176521f6ced0e3a8dc853644171ef459b208a65361316db71379de5014b58ac0c3da6ad7bee169f78c6ccea9d507ba6592e1dd27d65b7045dde681b81ed89768ac1c10896501649450b490cf5661e1dab8b216f4a4b04c0bfe959c753ef93177128463c7a7a83cc054f73160b4e618cc3443e6134c34e713bacf5852e7e6345bc42fb540406c9d0fd073e92d963a5d5be7b3212a587b41edab69b84e70edb88ef3bccf2341ca9ad89a5b568b0c0819b6507b6333c6ee55a946c09a245166cdb974c5f396d3e3d2efd0c5c163ada1b4b3435d9c21efb3eadb6d349778dc2addfc53e9108ea129a167667a57785d97c705931c528e71eb50f44acf3f9427f0be2d0976c786546a3293c080a2a33b9c4c46c7fc0290fac87da7714484e3993495c42a6223c57d070f318e80f1aebefdecc2f0fbb1dffc3bd3c495c5f9ef9806c0797d9229dab96bd02fc11a724a765f263ed3d6e9518eab696575f31899d4b050343524b665f9766d5fda95ea16105540b23f8ee26fa974e2d1c8d100afc72abef281e7aff02c3fc7184ab307738abd7d489cc839774e4c2ae0339f21b8af9abc5ce76ba605631a82459829b576728ff93c061276a8976a17d4f3ecda225354cf7fc388314c49a9c0b12fbb1f3964144d2beb01e9b532e7a0dbafb29b899ec0e5d73ce06eb3d82cf50d1260d420cfa0fb78c91ac1a97145ba3f4fd9dcd18a70beb60ba1e52b7bf060d6d8edd7bfcd7b071c29d87be4801a753f865b59974a7c4e9a946ccb92ae81191bf890b76b5453454f4a81c78c5db9d70b24f713e55e454365444b5e44cb447e04007cd86c6d7894e30d297a62c02a5ae0b3f8b73561625859b45fe15fac6e983efd29196373b71e2f4e819811772be67e9e5e4c0042e3e8d0aa79669d08261f0a6694ac6580572f1369df204616d842df1fe2a99a0a336f8d9042f430e32b9d0de9b5e75e906a18deec460c35b1abcd01c70fc1478a2145ba333d356aa51653d94df3a5cce13dca665b55f0c055ca69eefb0c3c7fea4f45031e80d1ad9030faaaa748136c76ec295bae44f3c3be108d6498ca6fc98051ab98e77746ca74f9899ac59f4ec6a281d6f407c8ec34429b9f8ec6ea0f7b244b6e1849cc8eec7e6817ef975d07c30dded6d07ba73ba4dd033f1ce91ff6c15fe7ca23f52a68d7d4c8d97589acd8e10dd6d624b0b972fd5acf0299109cd0cf2aa3f776f9946f9f06676643576f175092ad8008862628bc6479237b0ee8a6d6a9bc0de4a02089e4ec961ce906c55dd9a2525a4593c8cc860c07e4dd7ef8ecf8cc819d025f0b18f0ac7ea05f54e1b3cb0496f19ec75a8701272b8fac0a1aafcd84fa7b596543c3f9a8d66697882ab436ee44c2b40748e1837019251d69bab0e59813cb84fb0f6b03c2ba18a26f559cf13b1bd7e84a67d4971ba2fedbf0c296ee4fb18a241d3d4a5f949c63fa23708fa2841e14a7e5d594c1fb720eb56f6c5116ece051a67c18f25c869a46dfd62b865abc2ae9b6e39a95892cff389d10a80026bb0ca15fa7cfe747ceb63a9781c88f22f34c92c8f61f89d58a1ee71a7590de1d26cf0d445073ae2eeaade3d9921c51599873c4ecc2e92d9f15a2556ce9f368c6ad4bd492dd865c62cc1b49e32b343a3f6ec1c72e049d9cef38c892e0b7901a9aa5a81c15ab0bcdfecf6aae41937e26b01f13f13c1f13397bb81f7b7c002361fbc93f5eceee089514be3327d231c187db1db972a1a926d72e4ae615bb63e4b508f99b3e711a39eb510f8b70ee0866c8e1dd6053b19236b657dedad381429b92a5b329d84427d122dacbcd77d95e2cde6e6eb1442fc3fadcc2466a4c31a3f5ab23adce9d854747046438c5c2fda56c2093df47f4457be3610369ca9f3474a6a2f6d01577b1a9361e51595743e3e5476530021e0fe040cbb132f3899523a3ebfeeea2d7dc8ed6abed8aa946b190612b8cf1aa061183f095c9ec4c911ba1646b595a246514c522058957327b8e0bab947f64c4a805e8770570515ac5e9278ee2d10187b4798c5435ef66ad2e029375ebe604e6fa7d467c159635cade847711279a1e2d5968474b067c69e6721c6d6b7c8e34a7ef74efa21d3acd1ddbeef198d44a5914886c073c07e37a102f966df312c6e0bc53a1f50aec08633356855b0f5e0044bc8b3f85769848aff8cd440b9acf9821ad2965bbde1b6f59627328636baeebf1896436cb4bc4dd52fabc03433f359021262a703ba6fdcdb492d2e2456a13d687a05842e1fc3813336feff9458e155b5a7bcf0de6079bde648be99bc1fe8a73f3cd8125f8ed0ebc1d96b29323a8ea15ade01e7b7ecc45cbc38075f3df2a811d2fb84f1141e43cfb9460988d9f4a1b01e0cab41ccdf36c7ce336354e357addccd20ea46cafa2f2e6b77aa74eb456b639b6da4c184b63637b49d3fea0f494c6ca23c1ce9116f00f0520a1adc752be3584eb2be9aa47273a90f398f145ce52c7aa2f3e605af6918dcc35b93dfd8c568b950c6b7ad4947c54b3d2429a4c1e59d0eaf5eeae58129e767011a9c34bc80264d6258469a54e06352defc8e0d681311284c274d89ad86f99a8f92ebe40aa59be972e85e8e15551f3a075aaa3910fa021cc9030c9a43b768a13624996b89c99a21660ba1b094160aebce6dfe6fe1b82989e78b266c66555349d774419ef92335c903b455791202745ed7f03014078b58e3c8bfa680b36cfc2ad6f06869f76a28ff27230b585b037b277e88d55af7578c6790fcd6e2564552f042214d2b0a5f895a3bd6a2571758943026421217746805ad1f39e742dc0f2b87ac55c8eeae133887107d60f38c432d454f986a63c8c8a3e2b47195f64044ba78be21070e2b94d40878738d1db561647165ba189b689a14d80b5c4c4f1a62a5ee1fdf2503a01f5d65b8f35d6473a45e82ae43a4da09267773fbaa48cd124a075c48697cfa0f44e6324a29bedfc65ce6e3d1f010c1814942440d6cadf17cda8a2fb2486d1ebb7cc48938740bd6db23aa534798c3c2e07fc23563a23254e09d19d3b42a23bc78bf455d36133fa4881b081c2098ad0afa789681250fc41ff15b9db611d4b674399da8f95e48d2ab09c9a9a9ae84f969104d6deb78d69a3fd68b8652439cb408faa867521cc7f9037d892557f579270e6e20986bbe2c1e9179ec87e131218e5bad5674d5d4e80898bdefc70c6e3dcf28f7dedd41fec0d07acb02b1def2cec7ed0c7a5ae7b8da423b33c71d52a538ea437bdfbbf9971368ba4538c216c50896ad35476e8e49f650164388479e305b6579d5892902efb2b8759a363ab22415f7316f5dc0ce7b7a7dad580eae63d6999e2f6c6ab07c1d4e5324f4fe9a8b2fbc81787b610100ff1a0f2ab26937e1256c81e71a82c2a3cef8e310ce0f459d2e5d09d5148cea53ecf2032acd48b435f7658c22e14dc51ea8b64822732e201244d51d901ba73a08437a7ddf73de5cc3a2d9d9e2e80d62100b1c20b569737d2b07553060c47f27c5ebdf4f6f94405cb139ac3da1f102497546252db956b2f6e56116cae8db462f2965dec1f0be416669412df555aadd3ad9d48cf8938333831dcfec3d9b69beab9f05303d4100863bdd9dca84e887d07606c7af3f53552eb97d2dcb60ab11df759776202dc2584c92a591a14ec3ba499fceee85ee8873345d9c341ca9998693608868691cc08c251a4a44f3c490d0d2243407adc7e795a585dd17400910ffb55e575064a0b79de6c959f6d01878daddbd193c60515f8161ec79dd47324923d45e393b938905543ddb895eee1d16d9ce8cfab6b54d09318dc51e90f1a422fe83bc5ca522196c61d5374d74941cf444541b88609e6c59f8d309e51a0df8120a2808e107c70e420d8461dcf93d0f2b5d323314a83836edee3b9c8a1165e177a52d77767f22a6b3dbd9df563aff3fc5ee31029250b96362615bf0f4c2565cada24d2c4b837244b7aae5c89a62b1ca0914ede6b7829bddeac5e35641a53e532d8e443e192cefd6e3615b4de0b8f532ff9c461c8f040792e43bda6c410fbc71df75fc2d219c86843eebbab8568bef3826e9a7bfe887252be83424c3c98e641e365eda3c963456d51837e8662b72690a4932ef1b3285ae80ae5772b09c758fb3bb7db85fe4e31a0ebb7af8116e2e775bc9c085a1d0356d80596fef51d7fcbe0c1cbdf0a58d864b56e2461d19373945134c068c4bc7a25c627462347edba64ab264e65612cb0565b30d1a51055cccb4e3f79d7760960751918daf54abe4ac029a7d4fab90c29c1cde33ab160678dfdb22c1ece3457123cc4de885f523256d745a7c939a20b85a32ac1961b77d8a768e2027e31e3da6b46cf2d7ffbc6b7b7b734c52627113a6e7abe5e5af03913f1d7b449a30a36b0298b2fc1cc5d13456b9533928cc9e03cd0c94080fe29f2e776c09eca724305817319eaf49a1c1f136e542479e5c6c6422f8b243d4f155511c8ff70c056d4d4bc106170f25d7e88954f797723ed168904ebe9b27e57991ea9379643033e19f2adb7c09e3531f58fa41eea2e87c9290c4c896a13380225e511abd4713acb5ffb8733724587331c93d91e6c2b420c6c5f3914a30b7c29b1f56d6410a54dc4f3c9494102d94376d976ca915146eb682a8523347803f35828f229a225f7155e6b0f47245f5ffdc46112920c7733c91dcad0833e4f6996c6d2f96f021a72ca29b66aa3b47e3fb0737e83f05b42e3decf083499855a098f740e4aab8bbcc4c33620cd206571d8ccf016dbe444029eb43d78bbd17aded348d2cac5299c92378704e204bf85dca7b5c1aab85459a0b416e19aed8a2b790c42aec2894736dd4c18430f60000f9b933e3679e03cadf2bdb4a1f1113a77a353a6788eb3817c9672c8177f7589db77d3e54d45a56d98669ddacf231a7cf23d17cccf877fc32272a523f63058b9ed305a66c78ce57021d9e8bc844ee728360a541032cb7477e06692c8d6bdc0259643bfeb0c9644d53c1c739484fe0eb8ed89c96d67dc2a5dbf21ceec6afcec5eaa1cecbad64440f82733db67c5e7d7eb42536c6d4d31b239a5e0baf050f5ec5b555e489b8778ec57f93bf8886737d3a381a1705da2ab174b075969ff92b7f6fcb36da33fac435b010b7425e39399c0c49704fb92084237872bf86d6df0578b4ed5165053bf6661783e488f4d92fdd6ea5e675fd3293745d299726b57078ec39abde77873f62cdf8ab7f3989e9ebd48a725adaac2240b69dae9c816ef12a98458cc9488df6fff5e4ecda0b1b85be6520343d8dda6358280025b77e96da306041f21eeca5bb25d2eff40ea9026c894c7edd26cd434641459124a4378af95f2517b4fb1c06600df9e0b031a7bfa36a1891c804d2b6fe1244ae867a990da66f419dddd66388d0f502396786caff3ab178017ca5719361bffd211a4a35db5595d6629f86e60a15a87899391bb6568ec366c1e66382094ee13d76351b955c2aa5d92f8b05f3228525b92bed633beda78e892d26548be9cd5fe9788efd9e0cfd35a3eeac1499238ce57f018524f7c9dfb5edcbbddfe3fb8f746efe317d4893cbe83f2b8e12222849c48ff46910c4cddfaf6f586c36104c7a5f415871f60de38d46342f19c8f027269eb797151f85611e02aabb038977ce102f544cd966e5a69b35f572a5f01c2ad0020780ae2c8606c3420fa05ddeb60d47618003bfe4e681728c39da742fea57f913769e439e34fbdaf05eacae498301812709e7f355947e6fec39a92b6c653c885d25d8b4753d0d2f50acc1a9d5582f245f1d46f2b7aa64bce593b16106b3b870d1f05ed555297e65c92c76d001d1ceb35394dbfd800226389142ebf028bcfd92ec6fcd798cb443c3a40fb04c21e1992a3dc5100119b9418236d87605a7c152385907c35f5bcb915465adba27513e6969374b9b502a35648822af0c42236271b15e7ba5553e0ce74838487625981b25df076fba91843540ec29e1110e68c111964f3bb8815d886ba8423c3045f746ca24e0e3feda1172be15183736133df5e5ca2e70d22cf0c33250d35eb84280ececa958321160022a0a3c9270cca9801dae6371fb3e7cc759821d3718c4794cb09fa6a4023f42918d70a9806e77ca32ac3585fadb6028a6ee295726b925f955cca6a5cd08870b48b233245379dc8a773392bb345718070f827fb69e6a53f04fabcf9f46dbb13ded53ccc38602720b1439f506729eb1f6519410b056fa9bea8d2b68cd6fad917016ba9273d1247bc50b751f27d5fc9e4b1ea53abde4e5d5f93684e10fd8237048f9f9f5b277a2cc5fd9ddadfa97f7d7855360cbcf0b68a1e4c59163696a9c0ed34d6e83a5c9408571ebb08ec7377bff4ab94b8ed38e7bde3b731da40def7c2769f728f2dd849dc3d7c84b4f9dc323b135c59171732e1ce87832662aff04beed64cb9ab1f9a94a07ac9ae1f48486b56b45c807afb2d3b8722faaf72e1934029eb41b198b4f75561164d5ea07fea6822e2c821110ebcc30b464f9dc10d5e5a2743e9b929cc431900519ce3702c58f2c5e95651201846412b1d52994d8039ecc08ba075fc81fe69bfde8d09718a35ab90bffe46c4b0ade6215ae3430334701d1b3ce2094f45f80dfea860c108c8f8feede771f1b4b4510cf466bfd17e1d9070ffa98b3dcad3f2e67d7f2411335bdff2184f7b431517a37cd1dc072a675667ccd49cc4367fffe8d556eae85653f7c6862611b7e7c9eab1bffad6073ca34b9e496f5b89ce24716d309e1850da2dee52ece0417517f30e63c2d0b6d53a173cda795ece135487b129d6f330bb790d9c2705454e74f8084ccedcfb9e780cd3eef5b4987ba43553f3f556f94eee0babf5c2d1e5a17410bf43412f050c674bab5b25040685247688903851e10e69f55eae11c0e547400541601a35bf1d33e0b2345f77a5dff996e652d09a5677c6fa1a2c3ed52f1a7d155fbccc1f70650f222f884f67a9ce46083f5cf60707a2f67bb9ecb0f4bb84991f53b53cbd81c3fd377bef1f87c20db06d0bbc29dc3354f6718125b873080b6413ce2a64d36c19c56146f622492b1d0e368e294ad83f2afb1c46cad977331bed352c146ebb483f7350554c0b42336620ab3469912a8e9a153f478be51e82f95395c5f2d6770eee1dced3d645a7b9c996dbbe7403b5c8be2433cb6e5d74aab07eb5f3eb903cf2c3d0c15ab85127619ed053ff4086f34ebd0311fd85a229dcd7a7d42f619b6697e0b9676d17a3a8ec64ce7d9f75a992fa7351dc0c43d60318ef742bbe8ae1d5bf619890d59f4defedb52c5650a3e1710ca6de200d79e41c7bbcf3a3c3c152f52f82cfdba5b98fa4d77e641965a17a93e78ce2a45f8ab0fedde413721eb35b2f8d17065c4b624099c61f1f6147910977c53c2a65929f4c55d3d7fd8b312bd426d5f7f5e564214b1eeed441f0059e8084f7bebe25408249d33f2cb26e9aa530227009ef4441a15dc50645d40f2bbbf67da329397144e111ee4db5dedd537bb6d3eb5f569b9bb72d5bade3e3b219f7451168e0167ea9c405bb10e52091a80d6c029a1043e1c46946823ce8c4881414e2f2af7f968954d057320687e8f5b8ca726fe94917b59559abffb90bd5431d472e0bfbead03e9103dfdcce15ed440a1993a76ad965c542949a33b7d3f5bc3c1889e4dd2752fa430c0b9cecc1e27afad52031e93a27ee5d8c93ab32c06d0c43e0350fb997dd25cf4f77afc72742b62086751d5eb0559aa249d5039f051687049a116a0ca03d959c2b33c6d8c8d93ceaf6b8e15d4e84455be0ddfa1172ea7646bc5decbf4360c25ef93786fab14a738c53dc5549962d0ebe8d07ac4f329f81cb64707ff8412b98daf9cdb1398a4fc7ffd494b9ccc59d26c0058060c8a8ab0e0e3c925e1d2cb0a0433fb4338e88d9c1f46566249fec7cceb3f56885b30e28395ecb89f55ff3fe3d0f36adfcac52eea7b3adb9e63b1ef8804cde0a763c9016d927d35a36cf74d4057309dd05bf01b552745eefed74beb82e453b2a555bce71d8d961db88361a4ac0cde61e35981dd4c072c8012645edcb1af15670d149183d27d0533305137fbab3f23043a5726c05f28bb047843e1d6cb915f1dd765c5c84d619286cd6b8dbc1cbb19046b0ffc4b2b5fb9d3383ad6adfbc0e58fb51ce35684d566ef2bbcd9b906eb93e6ac06b0be9ad4828dfc3e4c3c56a7fd1098c7edc64aa43fa771ebf26f5d69f0e4c146b7e3e97d869b4fa882685a504651fd3b71dc8dff2914a6a5b5c056068a6174dc28783bd200cf267998bf9547a989d7df23be5489352bb4d478d0d4f40dfb24dbfe36f5c0514e783b05104e414c74af6479d3e144df24de025171993f6cfb07a204cc3cf89ada19f235974240cebc3006f3d077c52e09c81109a6616fd83eee01f90bc39afdddd454756e39d46038a86f002d60f9a9036748cc97b090142a3a78a55319300f6d3f63097f44262466641dde85dc39095ef7e2f1d46fd5e09cf8f70f0af2bec2d728f6eb71d83ca72d75e365ae16e94b8d007c4b900f5bba468321584f68cfe4031cde659ad6c41cb2bdfec8d5cbebc385a058f3076d2024b98665aa95d08fc63c51adac78d110c52489d85a84891db8bdcf5d7398c7c6e0c89a6e19d99ce7d1c3e3c8d16a7f292184546914a6d29a73da01809a22f3c10ab179fa4277ef83d50b5f91481e3b59cc72131dca110a500c4bfa93fcf04e793438b7b9b25ce6d1e73238baa8f5dad807b2e4fb626fee9cf0a4e98fbef9075e304bdfdbd535953ce1488337f2d271765bc52966cd6a0212073c6a13d39cf7cd39a57f0bd9a6a4cc2e6e7b53844247f84bace6551a4492957f9bd6eb88ddfc34ce79df0874fef3953f1b1943caa545e565c2c104b53b836d462cb919ae879a5d38cc1cf03e81c7dcdb31efa08a015303c3f253043bd13ee3b949098bf6b47acb35e3a071e84f28092956bc546f3530e62edd1df170040e8a1802698cc84721539e353020e26f87f90cff00a5ae5a47dbd0d4aa244262bfd388172639d20aad232b7ba65969f0bea6d667f5ab6bfc0f3bb5614c96a4ee4bfbecc00a4da6732c8541076b8243940c1511f0abe3d7e1a0e86bfeb6adceb06a0b994f47bc0118dbdcda91d21e1fb720b1be2923ac4c0881d50cfe19a9a26a72f82b5a79a91f1940c699cb928dab3af1f08365c4f19944aca882ac3775ac8e49b1a45b1a09d7629ecb5ea4a9a64b85f3c984bb13b6dda5fe2e27fa615d2783a8facc826d29f5095d194ba7086c1fb9313fa2b36af79e60dccd0c4535aa9c9f96b47705b346b4069c8cf105b78a47ebcf71aae03f5bde252e6e079dc1b3b36bda3a51d6e84684704cc49542c22d9aac2459a5c848a7e90a6d2603c88c92dfd0f8227ede50ef8d366901efe87ad483a5b7171f66c97c1230a2c18d14b6b2209f2badd9f5390e8ea07ee4d0d3478d20045278ea43020e56640c68c3c9679f84b8d30e5a8afdcf458fa2d7af27cdef02bbe229001714160257af50a0b3c7535a900b28d4c0338f3f880db1459230f75aaa18e4e683eb5622f416e5d4c1366db49f75bf3ad28d8f1c30e54d328e050c1b90799e3a170367e2f1194a54a6532bb8fb4ad54ef4c0a59a7837201e91c77b39623f2f6624af8b038ab9cef2bc08377a6bb5f37b6b7b38e8e89df3bb4397a397d0d1c421bf003d229d662227d984a23a1b19530b9e5b9d6b08bb3c1911f9c5133f0dee73278fa28d66cc6dfee958e34a4b09a9f996587820ad4af885de75010d7b482e9484163114879edad66034c8e98f301a5a0af3d0b6df9e9226ed116b37b72337164b7d05922759681725d93648164de86c3c8d6fffd976d034ad2de9a63236fd0b8c8aa4f4986218fee318ea6e96d29b108965415e6330c06849ba8416b96da91414b4678d892105bffa1ece5985d13df32541efd94c6c3285c9164afed4b332b20816ac373788c2a6e676b374de1c254d438581c885e535c19c01d954dd7f6cdfa13be4caf27f8fa65682a17097801168e1d921fce25d82cac51ba346df4ab23db9f23c88a466a052b3a7057c565dc3944333f5a86229578b28c11e5914c5e4f6d385fbdf1985800776849391bf7ebe84febd77ca99880bc871ad754bd75010b92a3e465d2f5578a476e244e552a75bf3d664aa2f3b146f330d151a27779041b07ee55d694cd4c6cf85bcd2d6f7cf81f7f6774f34879565d2bbdd6c8e17c17d1a32da8ec21d7009b5766df7a66f953d6c54eb43027fc838816e4c7987ad3033205110a75ca847219572625438a1c4c6c50d5718ab893d5c93b205c984dfedf6de4436004e7d45e7763d3b9849791c1e48bb805a20300fc61f00c4c76346ce34e96088075745e49957308f788ad1fc03d2a975fec50e708305a6e6fc020a76a8a938741f5d08f274314152900abf08c641d698464e68e8c59dcb6788ee52692a8a656503a656e198da5e0a463e0ed49ca25869caf4d798446f9c2adef2db7863f40edd8f40e0f98fb438552290b31069b97ee707654cc856fcbbc2dbd0eb820f169ac92f29f82ec69c8e0132360323fbaa7d5c14be97a80b7c8cbefa4b2b83207ca5d9df205e942f411891c89f5918491fd3850ba93261f2e1defe55f78c44749be868a7f1bd3f26901a0665af3703f9a82aa03038f4ddae794013906828bcbf56d976208223a3cbb067ce18df1153803b7c2e2b5e2d0a5c1ee5b66df6bcd9bf892c04a45576b4221219fc65dfed643a119d658a739f7b1c045c25fbd2ec2621d156cb7e23509588ba020d7c00c4799e7553590616e4ab459e35c307f561ff1b3ecbd58804559a2d5df1f94011a40539927dc68a09d22df6d15fa7a07eac11acf2142936282a43cac0bdda637513fc1e47dfc1f3cc61eb58337cad6e246d3527c024821b3f804db924b1d39da9e6031172f0c81f6696","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"07d6efe6704204f2c7c54bace97e82f5"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
