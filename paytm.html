<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #1E242A;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #1E242A;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #F9FAFB;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"67b1c0a0f866df2ef20198c31c82efa7540a7ac89710b697874a3b8340e945bbb70dd4b2a771871d39a61da548c39ba84843772860411b364e88764a176b472e082761d0a50a59b1a82ace6e4b14715c9f8b7c46601d55f5156410ab0c343d03dd074827d6656e087f7879ccf1f20b3f92e8a51a5ebe5044bc303b92e695b24182b53de89c09d446e484b9e72812284ac15d496e7065812bdfc4042a5b6a54b5c16fb0354fefd1e57201525ab30be21ff9dcc286569d7b92e57d9f98445842a20002e21fa2ae4ea440f636a1b171aa74d5324f243ab16afecaf73f97eb46ba8e68f1490b6fe002297777066919ecd8df8a9b0784c506dd31c40a4c69fcc5294a00585826ffe6c056dcbd6befc0373b07ff9ea4ba09c40cafdec8e337eb2c59ee38da10754b5ea1827146434a56ec3fb113ad75b205b8864dbcc28d4d3c9b32de135a3f1acf81f4575fe9f160f9fdcb4aaad9d8c5b754dd11385d55295dd83dce961b4d54e0441cc9bf555c55b3b6e363cf2ca1668dbdb6c3efca85c70ae98aabe17ca98f56a436418c53481d7555a9cc464aa07378c4f5a8160a7e6b133fc8ad31f9223b4bd2525ab43ec66f8f3f210320a51ce5bf11ab8b2aa97259d0b371d8ce0c7f3252cf8c64d7c7563f292da0c106a77ad7da322ce2980e83b15894ffab32da1e4e75febd4cf26d23efee996245fabc4c041a4294f5bde72ecad39c323b8562aacea3aea679b0e0a02bacd95d388add31d896545f59b60eee1f20e6d2b51d7ae2b39ca7043454c308f9dec75ae76793f6bd6be32de5ffec6da611c66fa0ddef21f09f043769ec6227ef04c7e6a82c898745c927ee2c3383a8617531a1d5189f178e99dbae27a5664d6fc06d496716f14dd3bf7874864ebdf4be108db44a350f1d3b1172416e902950866ea4b8811d974c02f29f1ac1be9d6890bf5905bae4a502febaeec6a0d9b46e1aab63588e66406f13b8df72b7fdbc2a3bd2df9fed72272a9ba77d035d4cc189b8725b25ab17b40ebbef268235ace8075f96f1830c438eea93a89d6312c7b6b682678ed2f1ed201a87b190f7cad14aa2a92c0147b51809dcbddd46150f2a7589d65bcacd127d7b667e16700d535866b6b90006447704bad58794ffcbc4effcde445c4a54b052724bb22bb98c6515ca17d821ceb14bc3daab22d0a837c7c1868ddf276fa92dfe77e7fbccb7eb0041d08e6c601bc2a9ccdfe8baafe6ae9ee12a9512c71ed07f12220e4ce7f4fdf881e0e9012b0ffaa7456331f14a6ac598f4ecd81c5cba228463f563710118d050af97cb0032d2301c36545a547c281d67eade5ef309620da14d678795ad8e38e14f8c2ff1db95c7c663b2ded9b368bab5cb10bf649439f1e5c269db64f40a35c2d3fda7f61690042ccd94e1564f7f9184d7c12cc0b267f8a202c13bf69be873b2ab0da46db6386f5c23f570845766c896b279c7afd2f0733f904ecd953e9d8fddb8a337b0867b3873cafccc5553def1f7cd84eee1c56979c98b035458e2ed1e6feca1d2224ccec50951a58c4e566a79373780e7a927258727f7165007e818dab7e1f070d5247ec9acd3c08e6c03037bec4bfccf8897d563acaba59fbf21c03dbd651f2be9266609ff7118fef24ba5e8d5bd74c4471eb1db9b55f200a97a974306ede80d4eb2bfb0e9b0b7ab23686a398907b859a74f4b3e8968695d815bdbe5989a46a725e19f88d0981d731d53cf1df2af140bae5f259add1547b820942be3990efb0d3009425f56e81329e4cae079ac885c0a5f42dc6c922ebeac9ed8056cc8ed0b2ea1aa588f814cbdcc784dd40d50947820000479adc77e7df38f9a067855c56a82803118293235c01987df6d3a8d865d1dbfe6e850eb03e4727738a58f9990da5390e136b708479d5cef6e4090ac6cd675436a544235d88291b07a8a140b4eb74cfcab90ff2a9112e3d47d4364b8d5d5f3a9d2923886b19e9a16643911aaa477b086663dfd077248f61493be945d36925a410cbd4e3d03005b41fd516b7dbc21cf0fa52b5b16bade82665fd2c77ffe747bcc997f38fce96f903370449a3f8195a4c49fd02e92c14ebba2f2726e312c37803f01ffad9b78ca47529cde888d595a2751cd4804dc167b1e088733d72d6ec1baee72ff1ba2494bd555d30e4b1ab15e5181f3a4994553d4041b6c53e506a3b2c54b6e0f2e2b9cde15fdb2c610b4524d7acfeb71ef93a2423fa23774082ee97769b39c0113a70cd17d0f63da1c5542a6ece439ef61ca5b2cd463a57ab0c85405a88df87d07969fab0bf30b59f05dd4ffa74d82eb659e70e99c8e18ebbebe40cda26442d214b5f74a2dd9ae21a59d34090ace9b6babdefaeeda03af179e484d862fc2c7cc32b0745e0c26aa5fc70cc5c4a79b82f974bf4b2977105ebf7ab47f0a8c2a7e80132bc791d1373b6d3007e0c4429b02ed614d989aa348981dddbcb5e4421b5469735cb3c3e92e7269970a11133bb118b1efd39d6d6935fe16a33f9f6f438ac6a1679333d051f6a5adbc72618f51095a91be7f3755fec8a993d0441802b070791ecd4a8d256a5ec791b7ae446432f34de16b4c1718876526e931904c4807cba9212f56e7541373dff341b566ac02164e7c2adf99b15ff9883dd3561e9ae023567b7e810310cb2759689abe75033e963d73f768b2156177061b497aeac972a955f6ba11fa22c24c5da16f977e816c48a6ec81bfb764b9100e5a859706c09772a43da865ac38a33c6ba8dd95297924da14fbbe9445e8a12a8ed25dd33c818ae6cb702e3243936cd175b1cba2be7ba8ceaa9da8fce2eec5fc3576da291161af83d0946d366cfb6e924c09749223084e460130807a8f512d79d1b2a3152dac0344536c1ff8a48557d110eef1dfb577addd3c73ce8802cae7a5c271ea6147b2292b3a578f21ede143e4dfbebed6fbc3607f6a9958394abd87aa9ea4f6a3f2018d32cebc365753b109466692c078a5f2c0829b0be4076a71f1cc1ae32c1aa622bb341fce5f5efc590e4bf286bce7a671f0063df70cce18c20c43c72c3f70196fbb09d9dc55ca18fd4b3364baa6021b978dff9623e4897fd024803e847446ab388419949cd8679fd03c869694720ab043dce8862e9c99f3d9b394283608afc828aa25e8d29a3f6163344a5bdea86538cb5d0184ca366bc884486894211972b7ea23a33d25b785c417582a3f565a39c7db80a871878984bf5f35b5de2e4f506878e0f2a43b4059ae639372a423dc516d0a1b5aaa407bc57def52c34f2bef9aea2bbb4b1b7886dfd2ed4c994387aa619e9bbef929b0ea220835f02047118894349f19f4f6ab562232b574b745b2e9427c207bc728fa76fb77c8c9ebec437d17b9f044f82fe0497e36ae820b0a8ded022e11097421e47a755af46b9560b3e2ab5663950e4a5cc4e9688ea1cf29544fe1ba830d5418ac81d61a1983aa335b12636985ee9b26870c29ca4f278195562141cb279c58d8d9ea9b9f470dfb40ec16543ebba12c1d7e5f0c5fb2eed259e5fe91eeca71d5b544deddde582204bf08682c4d6bd27f9ede46d4f90100d4d848434acaf52795e9aec8c2c2659b0fdca03487eba66837f5096c1705647215822d2fd2fdfa0e18cecde7b85b724cf7eb60091c484f49feb88b603bdc850709db083ce8ff2a6aed81e3fd01683dda9cdb61002afed7c4f73d1a8a416648a3a7550515db2be5bfca9411e32f9a4f2a2353ae80aa73784fcc5f81332254412e077b8376bfbfde5948dd94cbeca2b98ab23b3a1d08ac9d2a41a8bdfcea46c833e067e3b715e73b565c20906ccaa15f7abe3f5f424eebd9be116d6c44432f5d492a62346156a76f0c42aadb5f2580e3d1f106d9036db0cff906fb930a7dfeb60bd97e91942eee0433da41773bf10c124ec48786c01d7848e352af4711996acc8c0fbaccb40ee0ad99553a0d6af1d4f2077dc126c86c7e9edc8f1f37aafa92a13363021029776b704d722e785c0d1ecda2e3f2b33e00633a42ed527ee5ec611f22b01dec9b99b9a197b9d6e901b6183d39f995cfb2b1441fd30fde099e6540ae5284b72ae875ed5009ccee6d43943ed0ba8ddb794c6513297980044f1ef474a35e8f0a00961fd0918eae78fe1b9abab1094d76fd87009650db78c1c56282ad753f2b07f17a9abb72ab7d0aafb3ee542d0749135a79acfd59c5bf4ded80cfd33a21eda4dada1030761981b9a677c14d21393dfaa5a43016a9473d3d94b3b1daeef474ef0883fadac1ac4d06d275d075af119302f138602521884ad88488363e2fac16d31081587c52bf6de000be34b648cf351bb138e73defab003b034504cbc7c9c9f108e96b8985523dd6537dc5fdd0025e4e6b549b0fdc7f5be91d25e0aed58e1bbceb0e1c0e273e7c58d898e3f021a1055e11d8d0cd2ecad958c41c472385627b90eb502fc98b29e2e8e8a6482516c22a1ecd8233e6d3acb16551f9866417c046252c2563a3ad3651065c33fa81eb6ad88b2c336eba91531a135d3155f8b1c52e9caf592dc66b9a4f0dffce5623b3008e389793f93099e38606ff16eb6c1856f30dad39952ec30c6e312b1f7c76188233ed1e32a79c35a90db010f64b7b7f78132a02139c784756bca53889988a739e5df6c1b90ab36e38313d3f6423701f852c5813273acbd280224f8b2c6dc08bc356692ff6b4b5225f7a2416ee8180cd05df170baf9288ceaaf892b7bd77d12994d91949c29e73485e9710f7b4d361a80383237fc926a0c54a60059ed24156c1d822e06a6759aad02fbde27d1e3d0eee57bc2c76d7c1ce6f4e84ae9bc3c68f098a976e0f74092faa782cdf056e7b0c48a1f7f1acc5c25a2b6f176a8498f436820255b05270565ff5e41eaf40ab3f8fe326ef6fb13b384dccb31b7cc2336dc20b1414dcf7ef5530fc7d280727696bd8d19e7e96d6040e1500e65dbdcb04f66402bfacf3ace4e73e26136dd96cdc97812fe52e931db98eb3c26903b2d0625dcb65d426b64224108bc8e840101f10f365d62c0c30e425c33c050874fc2ff86ebd8050a9a6179227ef3fb75f30eb8e20b30b4b3b01ecc75e4bd98d96678a9e247141153baece241524ee051b71961e14c364ec1e28d07814420a1a02a68afdc1619b68622cc3121da3fe0104cbe91a040128d8bcc6ce6cccbf6d0fb813d94fa2e9fa12cc32c6e9868b1a7948ea8b4b9265de486baa7ce1598af8b56eb9ffff4303feee4c1104ff4c7927de109c3ff2bab7323e61005c771922bb805c041a4f36e6afaa582ae99ca2fe566560dbd58c2b2b080b82a8a08093e5bb485b6ba541ebac0d5d2dea630b012376ba7386ebdf3521427b5cd1e019879a234724e1ea5ff4e8fb341ce30fe8eb029638ac120aebcf1b1faf8e9d90ec9d0660b8b4c1ed78a763cfc324a9e3de3d1033fbee88133853c86d12a0587cd33b2415d59934c910b7da0edc6909766c131961fb61e838abfd1f1ddee47a1c19401c0e95c08db435cc827527feb58e5c2dacd72ac7ec4d1649f9f1036608430966e32b536d42ba2b2356911479eb1b2b1f2cfd595a745222047483863d01f651f556ac4090c941c8382304a5841092aed05bac770b987e9619f08febeea68cc5bc3fc4d0e4832f72c95eefd7a4947c33fcb06764870600557a6788c413ea2c3525e04d070880dde51dc1a20d14008fd4b6b2f99021913a0e8d0cbf79ebe6d3858243e06cd5441380adabb7f2b89d05d665012fd3fb1149d7b1b567ae6c733adc0cc2242b55b31b4b5c3982ac7bf0f77bca4a9d430be0a595af9b058211d8920b7342adae2d41aa85584c70cf4ff6a43fec499015fbdd1554aa53e1721bc69d45f103deacba3f4dba4627ed70ed51b9048595bf997ad46479da8f7e9de5f5ea9c2bad9ec006faa220a4064fe4250cd4845fa23b4445e76c1d79ff3e22683eda59ee0f179789115efbe49ed9b9afdb1d570eefaa4b41ca36833daf86399d99091d085f7138ebeff137aae3cede422f2426289e764f0235aad219c5ba588628c7617081926b4603948bdfd8da024096900a1b4c17a43262921db8465a34370aba870cdb59e0f439ad35d632fa8ad50c12d4799315d82311f3f4178e9530ef93800303180259543a7701351888b42b43f1ea83573edab7c976f570364a649b77c7d520c3323383abc585809a9a018371a821eab33761fca2364241b1db13ba14e8700118846549bba44a5e0e807430b3f3293adb2c5be13665c8967c4c5d80ba155a0d0023af702f66d57be7c41f5e8375d969bc5fcde834a3898728f961011ba9d129fba5a4c83bce02a5d0960beec91a058ff7f132f466dad7e18044dbcc141b0738b6f488a7d594f792d4a3da9718dc3bbefbbce1d77e2e968bb1c6dc82d4d36013d8f9fa55cf1b1ec176dd57b99057857baef760fce5745bdff95c59c04d07ee4a51330990f98b880d2864baae31df049e46cea3d6e7ee043dbb26f08fa8a02ad62027d3f074daa13fb1e2d2f8316c87106da0e0f7012a251811cf39fb52392a4088a4b207719e3fc22f7e227680c97295f7ed46eb6d22cd244f007a8deff4857ba06897d6e12f44336dfcfcfe86e1aa54bffbfa4932302fd72c58e7735d23fe8bc1b7a344b20940d230fffa25b275bcedfce89dc10e1d30bb9840aa3bdd2c3436fc6f7953a0baab531a8f815727fccab601f62599ef511ee2e97b430fa283e2b7a98a0aa372585b79876e4f7ea9531e4d2f7ac288f9a52b578a8e407de82cee6b7150a57f2d540ee9166db6227e27b7bf98cd93fd27562ed95942bbb306ff5eebb4637ba19ef20a4f6bb669ce0fda432a8dec969931cf9a596760d8ac89f685e7923bb3989a41e8360709711534e52a1de3e8c641b8ea91db0d8b10412e2811fdc81e635d400fe2afb98b26af0026a955f066a1008b0201405c8c2b7cd4447b338869654218b43d1f3730af52cd3af10dd9e67e4b58057d980a7cbcab1168bfd9fb6a8a6a5b8646af30ff45e4791befd61b645df3eb816f0b0e4d63e695669bd49528331ace22b1faaba60169ab9524638b0e04c526cdf98d034e3b4618138a1b98aab33502b43b2faefd29c16b10e38503542e9def2a7be806d17312860163da0f8390b2477303b22993f855b862e8565e5d3c11fcc89d506a0764f5fdee8a499769001f25787b7ce36dce2176e5c036ef6ff0d057b9da91ed802d8333896ae7f5c82369e443500c7cf94318e1865df26d6052209bddd092be91d7fbd31087642383ff69f4da7dba71a55658a20238f4b1190797c6600acb91d023f084403038528eb2e4c7ef7872792dab664589939d417650a1d2d8753b0e750711292263105cca36e2ca89f4addc3d9a07b4dc6439ef6bf96a65bcdca066dafcf4a1726e0ee7e09c1f14d0611efcb719e66c706bdfabc035fb72aa9afb7223e6e9ea7e21787d90923df9eda39b8b62246637adfdd222c2aa3182048cc62ff8caa2af6655b5f0168ceaeee888c4e28fb31f98504c76405cde38112c90af82898fafc95879e8c8592ac58940e750605ce7f1a79dd46a2a69ff95c3289a7be75400662fc14e94fd97daae222dbdd2efd679cc037017cf6f2d2e8b642948158ff612ff777220a3e1c0efb431228cea277e85facee0a9a78a56c0ba4fdd61693a416c9addae5fc701f8ec75ff7fcc1304cf4f009dd417ff86d15afa0e72fa676c48d0c07e5350bdc91fd0dc2be415a2cd8936c4f1054d71ca5fc842ebfad75c9d6f56f6a3a229a34e02b71426e8630593271ef8aa4aa0a97591896913fed99cc32d6f4fbb8f28367347cf17bdff363d113b1ec37f30f123d59af88de3caf2ccfe24ad7604492a503b45e6f17fbe1605a73ce02c0cb99eef5557327c5bc85e4c24eb5cbd4688e1cb4834aed2b6c720abeecbc545769987b358ca79a6add0550ffe5ae2cfc1fff89d1ecc8f4c6f10dc9622843fd9bc5ed5faded5523fc8a03f91df962b639765a68dcc7220a9c24ee68752c8ecfeb138f99922ebab303ad934028167f1ace4750174184f9f9c95dc6dc646d0cca998442661831441446c2a6269bc7a7cd6f1a111caddd45202089c38ad3c9dbd771a9485d5a46fc81b6037068e5d6255b377fc0c77a885bf50f14dce7debd95ae1f7fb9772a14173028157bd9d5f0bf7c7f52bad717402f7ec56a7a38d349862af6545d3bc8aabe229b49026ddc564f3f6d16bb82d4a743b3e155bf2a925205d310fdf4d7c5db36a0f315248fcc4320c5044a4696d83f642cc442d33d19a0ab59dd17f4d26e34182cd85b9edc49ce613f774d63198f2e8d024430873932cf5f192c78ad37c826fa1ddfbb7a9c6d9f2b7f590adae0b028f140b1c270715307188b6bf35a6ad60be44aec90fe1573122f92a0d3836e311a2dacda63d9767f049d73b0ce7fb263276359180a1c9e050bcab762e3c2040f969ae4661e5e1d2fc98fec96cf886ba147f7b57b5f6abcf8beb8359ee29db87b65ad1ce74db95425673939d9d737196ec84199dd8a529de4f33d578d1e4af52a7262bf3f306980477d7066e2285deb2d631cdeeb453177a916a9ad2b1ef25679fd89b3ba0b0f1b5ccba0988384df843915ef5e8616bd1d1e7a8937088080348cd766087702d8adc7297ed5d1366cbaa7bd5cbbf94707983b9711d7f37e633d186f95b1d16727704c58266680c5038fd57873662babef562077b6bb4c8198941206c4b299e403b09a2f8959fc1646e7830206b60c0f1ff123e47163a283b71259934b97ddee20ca29fbc50d2998600a9f63ef9eaa74da13cf50070b48b78c23acaf6cfbbca6b8d8f088a48aaeca87a9b68e9f9f56a714f477e1dc2ad4035238244d36e7942a86a1453212bad0c12bfad22d2fa5d0cffb6c4e28b69342fd4b61208cbf290fb6f6c4713929d5b831ea5dc9bffa37687de752259a570b174821f94d97f006931df06c3c8b11f4a8afecd70192f818298833c2233e831e9e753049c4662e3484d1c82b9aa7090a8d03040ce6e4270bd359b0786609b9a8c79cf6859a734b39d4b59f333310825884cdc4720f98b744f6342d6f6eed854343b0608b81b8ef6e20965b86533579c5dfc57b09ae5c4d3151fe451ef8b7691771df9a3efddeb48e44e4cf781c38f002f6e8e41db570fd6c9c5c4bdff8547bd9382db2fa2bcd29bebf581b972eaf0c6b6dec7ac663c68705c393d58863f8fd0a1fd0be944d6e555c711c2519d76d3305a91091d97c10cf5dfe8a1b5051c1062f5dce72d993fca377077673e167c9c245d7a35c8b6279cfc255951f2ad4cec5321f6b6e5e69ac5f87182ae9fb0774afa9ba29149d933a22d56561e7185fb15e26c9e75078480045df8279a5d81c4ad2904d426b4d337f9e5a17b4d1f4b17da4711d8e72cb05c96a8b42d49bd410b84f1871f95733354d8f682d2c3b6b5cd4c60411747b7c8866dd52149ac8cd67ee7cf84cabbfdfd949c0f7c1c89baaf38ee821cb1c2fa32b102fd14e4d2e3e40ce2541d8fa5fc0d911936757b91b803b0bd7bbd96ee82711f4f51362e724d768637a5d312f16c331f3b43088ed8a5420336213f8c80ffc88257d2fa1a2979b41636758c8de8cd1653ab3703dc6171d6bac49c861788688b49ffa0802d94a179024352ac435a080952df11e5d08c30bfe3213e0f088faaabbc70589806530f3f6d32798fabe94656fe546dc9a20a7ef1b7dd3d5881624027dea71cce2270f90a4409ccf0587983c616ac03c0664cb9ba2e0eb1ee669d344fc754ac8e787dec99228313b908a04a07815d165904826307984917cfddc5dc11bba25d57becf10cc274e7afa3f51132818db3f359698f94d8ced7a8374c043c4a926c10b16656db43d5eddcbe4f7bad420f1416d474bced662a928df3ac5bd20788249ae3554701af9254cc407eb1231d6ef657e5b4d8cc0dd068e3140ccbf18f72bd75e878f3f7e6940e4efc24c8bfef0f85762f39125acd585bec1b9ec6ad6835ad96c934d68ae9a186e85bbff1870b487157f22694848b5234fce0a9eed2d5bdc3b70941fca9e07990ea3c5975f4e5c7f24f92bc21dd10aa9417b967518580416987d3a243609cf7a1e35d6c08c974921c36b8e9eb420532beb01c08456331e424aba599bff1861d494f20b1efc4f97e583ce0b2906abffc7a30a2919dc87475805a1d770651aaea54ad4202ef70ad4494d7bb3e897db7793df7a4249cecfd22c512a8e7842ee721e7dd668c40886780b7609932ad5f44f6dbf1ae06a01c24ee7f3f15e22c39742bcd51c6c34c439efb0f465fde35341f0dd54df9323c953e14f56e604dca3437dab8164448f9bf907d8658f5b623244f425e21d5d67885e32d52e29a514bdc4997da642656bad7070c718f0cba62a0c69c95eb2f1041f2f032a98e9d9bcbd38a53ac94e1fdac4ca6e3247af501694901aac114a286e1c3dc5e95c248cfbaa97fc6c43a23f51b6cbbaa94a2f2a816c854f46a3c2c51d0064488fee99915758cb3b6579587c6c8ffcf5909c201611bc8b20f7a61767b2fc14c273af913bb5281f4063e498d74cc5c4fa19db4f4c64b6cdb20fdc93d17e51453ed1fe668cb0d70f8cbdfb0478f1bc0d9572b08bc5756832e396de2b884c2a2ab8e9d38c5423ef2f4d72d69ed3f4b7054040905beafded5fb19e5f789f91a94c13db9dd34b3bca0692200cffd4c4af7601488c663410a5d2c26163c6adb0c6b9dcd2ae642125ad2a5abd4276439587871c83c0fb85ddd5ec518e795819a6f0479290328d772ad4031e211facf2d5b24dafbb4d257bc042119e0fbf6c148d92a4c8bcc385bcb29ef311f3f1c9d363f3ccd38859c7f4bc9b9b4b21a6187c9b4fe79ef6964c022a116fea63639c84fb3b92678b285185abc48975af800c165c2eb9664b21bd2598449aad975fa71c2dc0a2475afd31023c785e439f06c206016d5c370c972160209475f27920a703769dce987aa156655ed4853e35e277774b45e88aebbf01a86f7ec8847a83001f85f4790c295e8c034781c56b2b9971e75f238c1be4e4b06adeb2e2a31e346d1601fa6a5a9c19571d21bedd10655c9d4443ee5afc7fde869ca2895fbcd101c6a43cdb59410e57f25f1732d5134d2755b98f492423940ecc12de8b0a0d645509a03dfbed68a141e36ee82998d3eff48907bd0722c68c5410cb03cf3be429dea36615d705f71973ebe1a4ee01dfe49887687123514467eb98d9be10e029ba0338611c820a9b34403f792b3692a52ea9f528e196e52a6f95ec893011601eac4f0d01af65fa8f0c712ec977ee2f7f3482e30b24432ed2003f3ddd6ca398a11e4779f2ce0c1d399c052e84a233a940a983a3adc60933dad71135f3c991a50f18bcffbf4f2d5b932962841606809200b40b1a184de3476ced4d36735d2ba30086fbd65c371f165a7a8ef9d694f2c70a4a5fa8799bcb71b244040672e771dcfdfea63b05bc04d2ed404421aa1543505ad236d7f0b95af41ab8d71de81a372c39d94fe09f19b20cde990be71b3609537afdd68baa25fb2ee2327500707f96f903fdc4aea05a19332c908df5a89e7987bd717cbe56179684864e74dfc37247b016d1e85b1035e1c5d1a7ef66496675cad5a54936db343998357418591bf9e9978898677440729f4d1640f62f23f2ae34322c131da97cfd6cbccd7e491b49d67f2dd6ee3a5bb5478d3dd2cf2689fe2353742e6bff011d8989cece93c00660af1e29909a94993fba93f22af91d5d20bc02f842e657bc8f3394850c586efcaaa4c3ffbde977c732c070878a58c48f3dcbe91de44eca7ae3e76cbf71f0ea3d27bb75c3e842c6c9ea6a2528d88d35475fb3f512021e5c3557890c82dd6e992ca021269017c6e9a2bc2d90a73c00aaf19f633cf5a46ce874790eadf3db65259bc404b0452a8ea72bd21914a08b4430272df9ed23fe4ab5cf97f6c57db50b0ae8f651b8c1882ff43be56a5459d7e169a25bcffe6de0871ad061f98df36e128f4a23de2b9cfa8b5ebfcf9a1e69edcf3490bcbadef4485920af035d2e00cd96598ad66d0b59ba265873f30da817b1bedf7f6cdd064562cf2601bd7e5977bd49b98803f30cb17308df6a6ca544bdb1bbd24df3c7d940d79ce198b7e2b8cbd23b28ea0138e71d7c54c49ef6b809c7f08e6383840a0247c2eb1d34eea0320c78b0f4b3bad8fdc80dd5af6ecf53a199ea0b12dfc88d5de07e654fede7c7c861f284605a5162747e47f108b656a900a0d265a0facbdc2af55fe2b4064ce50aea30451f5b9f0b63d31724027a912da7d0aa260f411b482f1f93ccfacb60d657deeb9be4ece69c7e7b61306e2846327b73382a074aa954d2e96f4509d46227cdf189a2fa95188c2704d6096bdb625e275cb9e19b6a153a5d0449db84f5a00ce49e7aa011eaef95f67c85037077d821c04fed602d903bad4d5fc87c003252e49893d5a8c7adc48afa43dcc9a4b2b7b7c61566d5cab1f0743af5c1f9e0be94fe5d263f7521c900fb3177ee2aed8fcc570c1c550cb3ffa530f3758f8a3ac8181fd6edda18e9ea04d28ba6196811c0c75476985b74dc8a0b6d448443ffbc5409668da10e78f4d340ad121c409e12e44aab1148a7ab02896bd2623f71ccb2c0f59ade000d74fb6c68bd7e00e6f4e045340b45cf943124e1e207a54e96cded26575cd1ff141192882c38e9bdd1af114d7aa331a396dbee1b04d8e8683de2d246793a41cdd19bf4fce6f81d45dd71b0992b2d3dd3359c3a9369897dcdcb6c3a19af7988d9366a6c416ee58f735022a733ecc33f2d92297767dd8562f9b02be43ab4cb80dd1b1af0bf72875d3bc359126bc74469da7971cbd7a633592015cb1c37e0cf623348d4e6241e880e9c7aede8471f2376298b827ae8a787ab578b2e07e1a65e908683a5205698ada00afb44ef2f1862c000ca4ec1bdbe18340db99f286db34b94ae324bb859916eb3ea82a0669825bbfe730c2ff8093a409acfc453de5d8d5ba705d22264d17731bfe94a2b605d49378b55491f95204f018623266b2f57b660996e10271b16bd0f2ca436d788a1795183eaab91f909d6489cb682d0a61c181514b99e0c6a44922f6c4562a92918d37647bd659d4a9859fe7d72e12c6626930f10f64653d3a9c9eca357b2cf6dc5a3206f89c92c088ab19343951e6e27829c34f5012c1a80fa86e4b8dceb90f46ad6d73c747d21e5552eb2335686a961e81f0be4ac596002747897dc7d2c4572afa7e61a8be07d37f6f7da1445373844698b8d38ae35fa3e7626ba2d359b5cc59c5a7a0868b36ff9888d060e2fd6d51fd86170e8ebe33caabfee9a80ea2ee022a69d8a419408db1459d9c24dbede4819822914e32873b9503b110372aa5f539dc29456ee3789621af98ab9998800f11c650bc3858c2d53b7472e1345c8d8d8505687a63c7cb24f1663d35770c732f1549393e32a6d52892f16e501cbf54078f325262c708ff8c88a87a5f47bc70f94e20ad3e88eb22a28ebfe30985746d7e5f09161484a13771cbc0060fd27e62e9807d020fc635aeac3d4bfa0a03dfbddbde79828bba416d551c85a8b1370fa18309c84de59c1ef63e8e635d8ce2007b0212232c9e85aae03add2960d8d22852021408409a69bdfed3550737dac62f90fbef9ab3f682fade08fa252e5855a816aeab47f7aa0451ed17d41dc872f06d963023d39eec56544a7e7e7ddb1c59f1aee22cf4770f2955751c22c07d0ee52ed2ce103dfeab64c1e1b4e527a4ef2088387c1306d9c0463ad1fd428857119c71d8fd8f7974aa01025cc7a80428823afe47379e2c292d4839c254fdcef8ae50dd4ce49908b6390977666bcaa43333425ca0e5cf2567fb338e3c7c1352454f66c53921ed71d77f4791b48fcfc7c074df4f5367fa807f46ffd0475d5043e3f11e9808bb3199fb1affac4cd83152ee493454a2ba2262ebc4ea6409ca1dad6d78dbb7113fbeb7329424a3210050c132e47d6169e3cbd285afa89fae8fa0e2cdf195b242a06871749ad3d53c0599b40e64b2e8d34d5004641dc20d455806538910f6aaa58a04109bc03b73d5f7f7836debca33eef9ec83916ace3ae319ebfe68279f0f7fef6dfc5744b30c38b74b6ade00c0a2b09c0589917f3979f6c7507ac52a9e34c7c0093e858338a483fb077d7e5b3c6f182724082de3b539d07bcfd463a89e6c2fecf2cde9ea9f620d86035aa321d2ed1f92ed38fb50da2a849f5ee4e7cb6e05bd954fa2352241481d82dbb3658ccfbb61d53ee2858cde840d87c6bfe716bf817812dcaf23222ba679e432f713c92911ee856a1309ac7d265db11c7bb36e82bce62067e2631fbfd4129b837e9fc77a9e4b33cc20964ad0fc288e40526987943c44fc10561d5542cf44447a8b48d008ff7a554c1d8070604feb3647ca3c22a984ec598843913edc8defcd9239730a2441843a7c830d30be262b2ae4fda48ce419782d2b07c4a668d95489306cf7580e40f79433b9325c87e5ee59bb86fc441c5a01201ec1b42ff8c5a8a31d9cedcc1c797182759efa0589e0d6fedd59e5790b55932161c3a183fe3c5e139a6660a162978c518e4de63ec87a6028be7ca51acc2692a0186ba63e2cbfef84a46f4018ad2859c670ff123a16a5141a0938d6f566212f259fd1a592824a7939a2a5615ebdd3458256e26ce84e88a8f2c33d1305461c920f281d2ef993023a2922edd007115ce882c6b3db240e1f065fbf39d0f822aa872dee4036a96e3beb6774284c96887340b290947e490381a4316700156cc3e94d97a1755edefb64eca6ff5425f2d1a5fed1b85071e70d0cbd02b1f4adddf900b6f8d685185ba3b96ad6d840c09b0895c6729cc2cc8172de814c98560e86d04849adab27028296ec2aadab6b6ecf4cbd0720968156fd6bd5762849dbc6b463a8c500b598a9277bd5d7fe3e62e25435cc003b5c7d7315184aea00b0fb72b565a45fb882186a27caa03d03bb970117a081d0cfaaeaf50724b34e33f16472056a2b1c9786b9a809c631e63f53c705ef5fd009f4ec9f3b2612afe0cc9fa6beaa73a1635cddeeb3aa9928f710a2be755ed15a0553cc4e2cef623d3068f0706c50af97304658eb1571ab9a68a9123f6f85c8158c06e63790a16a498b2c73f26c0df04aa7486ced435b05dd5b0cd0ea44200e34fad548db709515d2751065ef9ddf110ec6274b1518ff04d8081848464df1480dcec6ccd4d83cf9d86313de22ccbcd2b63c4ae07a5e22ce2434c7715f2ce9b51c019ad01d621573dc5d8ce44b35e20e9568c812888372f033fbb516cffcdfffaa2cf514ff3bd4cf5633ba9d4b3e7faf156b00e24a17f9be6f182a87b9394cc225540fcfc7474b94d371bdf29c83ba4ba9ab73ba398bf89893b5e90318ee4767ccf9eef48f9c168864a6a0e5b38139d8bda90be051e2acf4d3d7fb665b80b2389ff9c74f999e3cd34690179bb9b81274af25b2104543633fd274552620183116d1dde78348d2711342ba86f00a73045e537c9056247273327032db2b209225d117c2f4b9ab93de949e3ccf694f9f933d91c36176b3b136d5ef11eeac21cfb626422a5f4a623b5eec8566713516e1f12a4d55c1005a3ac501a1fa5dcefcd204c375c28971c7fcdf1f5ed95c7ab9975323a3dfa71b9dbd64a1117979341f81f361a2e995a0d6b4260a1e4c23bff5acbf9feb4ea5a88acb0b89aa11281b27a958b19d23db97c49793e2a45ff47eb7b13213dd4c2b3a209000b04c887c80c39c7d77eb817a49a2862b6dac3db10d6bdf2489f95eab84dd63b15da5f9298d700a3fe4d50d07378260b117ecf065ef9ea0fca4c4791ed2c5f70e80bdbb85dcdd942ba3b327b63fa351a4109dc7240cd8a13d09dfef2c0408015b9d8e672327b9ad253b4fac189259844bd57d55c9c5c122d5f981411f0c544619f5da30f706c5e3c440c7d847c12ceac26bb4187b21695a144be5530db4293835de084ab7cce5ea406e692d9d6962e2103523217d4a9cbb1995d0cadc0bf5d00b68ba49ed78e5409d8fb50f3ca20f959b8aa35b47e413e5369519d42de6d3e1732749b744958a3386293f67ac676ea5b78f7b94c33144bedc5ddd823c8b0cd9add159283471630138f2ff21229489feb9a905c6f42cc774f2256ba66da7cb0693cf32f1bda182f7214a6b03a815a53dbf28d0a5e3ebbe878dc858462acb518139468e22ca5fa986d477338cffae779cef926b304f1a9749f4b7fb665211dd69550c96440f5416c820bf63f7711d49c212c5664496976ac39c72ebfd389a1340721ecb18ec7b24a83789f130f0766c945d0f4cfc685c88cf0fab51709bc47610b547e31aa8b5e60b85e2a75807581732b32b218aac57a61fc0cb85757aff237d535f86613a62b9f812a462318c26b717746781f97597c270c8ee6692b8d72f81844c97773f8df8f2de1eaaa7c302196f792787991dd30b8cfdc941138ab66a66b6089d9fbcc7353517dcd45b348c08f66d594e09c9677c6f4f74a223cf492196a85e6a6b63ecd445640d08c54864fb4f12c6667845a6cce57ea2ef682fd49eee2293f6d7843d9f57de5751b656d603eee6f5c530d91af9ded82d34f3f0aa7de2c7e4bbb5c48551a466cb13fb656fa5e67ce79137ff0843c31550ba5670435f7f9573338f363a5647ce5d508f18a311fd3bd004af465ba52b3f91f59f7fb113ae255f7e9650a036990ff9d08042a924604ede613b39043577dce1ce4c6c8dc4cd7bc11e00112f2878b0779aacced2538180b2fefa084c29255a6857ba9c789d6edfd176dd681e58eb287c9b8052f907820940f66d6ef6419c14f503d7e8b8015cfbf1eef1f4cdf7481d7ef286d9ddb5395731c191f47a33e4e121e80deae59dc7d6658ed48a8a2d48ceeb02270d78a58292dde2f80e5a8b08edc4c04e531e7395612b0b79791010d923cec6021957c1d8eeb37a8fc442aac2ccc80f4d9a00f2587984d4b2c644a722553aa9ca498b6f37777d557523f7067d562b229930195961bfedd72264dda588e623e8424d008ece16afc477f95c5bca2ca3d5cb17bfaf327ca7cec8e804269a862c1a44a93c2a1ab89907241cc2a871be288a5c88ed2cd800cf0454365a96a09f1415199472e5a2bf470be9b0a4b5c56a254b35253137b6dfb00233229c6dae6af593f6d8085105407ba10270b748af12d30bd007ae3f18e2a523e6006fc38ef600f21b11ad5f0b72324efb53da2a58e9a114ef454bd53b558ea693b51a3a225d329018ee3e6ba4b3b87f25c439095bdcc24937057272c207ef38028d790aa15f61ecbc1ac731ad1c168913ff9c0967f4f156b6ec47f06fdd9bbc2fb233ec010210a9d2c30696a6cfec3c403ff988737254eaacfb4340ba68f10ed82b5e4847187f814d5c4159bc060e0ce853a737ee315ec10749658f48eb830b2e7db3868673148d4425a7069becc9f090f14f453488569b8906bc372fcb3af849dce71847c959f44011498dae2f20caf25fad1403762800908976435ccef504663914b7ea4fc81ce79a12ae2dece027d68fd6b417cd4101e22c507d875d0f5e0642ecd2efb5398b98e669c2815e93e6aa6f438807bb58214f515b9b0a21a6bb13eac5fb8c415b3f77fd54991e04987c83d995e4dba03f47a1d1678338936a0199328016d743863cb02c32d85d0aa19e5d3cb7eafc164f0f486b972fb2ee94b3250b0698bd9959bdae9c5faea8dee11010bd30117324b96c598e78b0cbfe2dd4edc46f7200c0f067de2973708ce5abea303229087b40f1474351b5f4cd1affca1841cf07db1d3a87042ecd2f5d464b7de558e9f5158a3e6b1b929b34819ce501e666765b647d58cc3c4bf47ccb812205c7d66727a8ae0f62f2fa55a731069064f2691d2f59555215307da28d29030e3a621dee8c854a0440a0d676ae4deb3bd6d5ecba3f8bd871b92a8dc033f7301a4788c5b62856e54090d93a08f1c9fd8caae27011f931a27e6ea22561e24f74102e2e5422068c42d2a22f8f41e09f608d994bb1d47dbe6191526bb2c303fe04ea5a93358be82c6b77e64f4b6c4d1c47b23abd70877cf6c8a6f629f89419c510bfa6313884b8a51a3f67e7b13dade367b42cf39027e1dc73c4e826b106074864cfe21632fbb04873b827bbc58abf7951e4df7121635c259bad5cd44899adef70cac38587d27f2ba9e5403f7cdef37553bfe75186ca97512c2e1f6b847945133a22e38ece00f4ad5459df24df2e87db736055b4732abc668485e403eb52d19c5450737db9fe2e24cb5816e2c270406b80b2116a407f4e3256499dceffd9f2f4c1ccab4717a7f243f568d1b45e37b51cab9f7677ec0c6976edc8f672d3e0156d8d6ec658cbf9fd9ba03912d87bf12282a3f055c8f733d6cfb921b4e088e5423c3414c9d88f9b97b39a7c52f2b18f2f1a02d61ca20f8e6b1d9304ed7ae6f6eb8083b54c5cd994f60e6e1652f2c9ced05deebcfca94daa26a9b5ba45e86a2895506d6e6a8a8163b929c3f6919c5ed6dc75a0e05265894ba817b91d777ae7a2859ed88edac2fffda2ceea84a57677a3dce3b4108b1a491d5fa63f6dcfe54ba3df73fc76e73199c1d79831e5547d0f8daa7e87870bbfdfea893386432d3ad48b99fca5e96bb88830d13e68ef61b25e3d87c579c921c31f6bdcd99f8aa9bf41f3d1afbb3a35e4f4706895ab0481a6c56ab270222fa91591d044af06b1854af900d5fd3624eb9b30c47438eaf673714623e15962b8477968ee6af45efa8287a64b8a3db7826f2e261e0de9ba5b57ae411422d9cd0a0696e3fd1f08215888d3dda129149b24bba3cde1b707db1fa6a5684c56fbfd8c0abe9da84cb945245b7f7c94ec0688d6cd505a0c6eb33c6c1100a26b2d00a1c538903f95dbfd389a9d113d3bf554b6b54b6b2d194cc6c31ceccda1c0b8553c793991a5d7f8235cf86","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"4bb7b8521432b6db615b4b70d3c3d9eb"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
