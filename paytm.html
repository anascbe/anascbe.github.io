<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #1A2530;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #1A2530;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #F9FAFB;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7d3c61149a4b69b21c893fd0c89423ef001c09eca0a27062730f43d0c5c34cb1645ea0f31140ff126965e95a80fd9be37eb065fb1cea22cf26b8f8ad9659bfad52d5b43e4e751405e81c49c064679fe4df5fa9377fc4cba3735733c44d37a92f3dfe072720efaed49d22d4df5c1fb0140195c74bca880019ed1e26e89724474ede009c12d8009479a48a6b2a9b8c273b33265a53e43b4d28d24a3a866f7eb6f34a447997743f6b11ba8188037b729756e6e20732c80d960a27775a32d16e0e10ad1b6061ec898d9164258184e453b396b11f1a7dd2ddcef6f197df9cf598866a0d54b06ff0298f8b4c1afb96f98c77e0f6a75d2b70941eec0dadfd1c10c27ac0fc5483895d0d52a6c14915e35954b5f92ffce5f0b226a82fad3000a91365768055f6ddd3b7b3e60df87991a5ccb91451e2ec400feb9572a875fe1af5d786896c7eda718b8a43e37110e5f71bcb68607e74eb0f55a3ed616f587efbb41c67bb6e15eec33dce5f25c6b7925e17efa887a2b3c3335746d728032ffaaf83f36f7e971d7b7920585c0a916ace561d41b893cf26fd38d58456527920509da5eeaf0f29ef7854efbd8de604baf33c7f1c75c29839c40343337f024c4e2bccf49a97a678d9c4495ccff8950f05fae6ff6ae55a2afc3ae614981876947028199eae017b2e40ec34222d8bfd37d00ba7be4efaa80039a0f42a4b36e6efadae4b3b6cbcec2aff2b4c6d7afc2f51713c7ae757f8c2affd880b7a7efc98c90a418510a69ee72b098fa00e0d0c340ece4aa5fbbb9c19a6161e571e8e786c20783c810a35d7bea6aea3cfe5a6b8e210405cd2aca9437b2c0c29723eaa14e51ee01108420a6c8a17ecf57094ee8581aaf16273f5afaeca9df6e0e1acbd6f7df152cfe5e1a92f6a3cda84a483d97367a2013bd8cd1a0e84f9a50a85f742a02b8e6f3b8b6d6de6a151cfe3a28a278a325892f06448caee2dfdf41b2dc0a0ab0d1a8abb347088ec7a70538a3fcd954aac509e296abd1c343e832d14f89e039176d9f9cae675a40e8ad3d48c8be9f5996cf198aae17c6b6d0ce082b2b7566da60108e02b99d1c5f9d23b0bbc065dc511b36f8f47a3d454bfbb1dfecb3b270ff5a680006e0598609df16bc4d8eb83d503b1ffae2cbebdc4fb7a182f7b6d272f9013f4842e26ab84784ec1c9b8fe65e1d8bea0219f6d5900b5dccddc43c3cabd37d1b51b05f0980e06ec45abd92646ae762b6574aef838a0f5a1213d5aac65c1fecaf10ecc9b1eb1732d519468974502f60adef721d5a68020bed18d06f6335d0255ceeda65660d38ad9b8e2150851249c2d29c03215b6d0a9579fd00d90ddb3dd3aeae9aa861ae9bcea99581c54d8375983d855ff97fc073683c30330a5f72371a117e3846223ae4f3cb9ac50b5b0e4974d106e4eb7f6ca50e74b44f832eeb334fc25cbb5f2cff706622edbf06fb5f588ec957437fc679380b14d1a115bdecb72f2be59cec8ba3ad26452e0aba991196b129b3b6105b2a74c0a9aec64162f4f3db9ee608397e8c9144d768ecc89ebfee7c735808f975d63f8e58ce7456cf4bf36cd769a700134e112b743fe3aca4b253635bd905dc07d5858cbb592d0c929970b4a3d69758e788597cb5a983ffe3db10e722644382111f7614ffd9f7205908e07cd00a8f0f9a06cbd31315b7c37c85e1b1763da7f657f26fb1ee97e47d8dc9654d91ae3efd67d485f6d1fac15309f37a21d84bcc30d0888d80ce6fb01a032565aa0752a7a1653846c50580784360f69ed233325af4fc110cb80efb81699040cc6377a2e417cc53a6ee50efc5b949f16bf0f96864fd59cff19a7e8e504f5d8e6c6b5974b58c7a2aad8655317c43dd3f20c3155ac8147aabbb19bb5fe185435896c6093381d814abdf0ebe53466ab7b14d9574c8714be489582ca834e276e5979e1efe4662e7d677a92f703db0f1de147b24349b2905463bc43d1cc777c333bce46b377b7937e752687e5a17f03efffc36aa21367383e06877578ead92e2c1ffefacf731c7b7b61387f6d2b72cbb1eeed1ad74ca2a24cf8a0fca60c2e3c48c8a8bceb08cfd72d4654e13ac1449df82f1075cca1a8f68e66288cc1a16ab6a3ea8635834e50028f9e5a6505e9b57f1fea064c8b3d4d9fc265532fd01f0f6448701a4f20d2ef33d44307edf09af5ba50f33197146e81af39b99fd36e6912e515ed192a1f66848e3e385636579a5589a1acd2febf6f75ff25308c65f76bf7bfbb49c35b255320c99461a2faa248bd4c08557a8cf65e45eb6bfcbe0ca27a15e17a534780b820cc456f812bbb21000562500cf67045f2343f9d0adf0ecca74645a01c69953e3cc32a029f80454189aa6c6060dbc6a992e6dbbeea75ac3f7088d1e89dd80f7f0ca0ab9515ea23456f22e9db897c8a5519850e1d29d31df649b1c8acc1a09afd0a7e12212422c8e0e21b0639807665e54daa181bf75b8912d590be10e9bdaa8e14b674ca08909057ca3e46aa08608f4e9156e32c8b8cb55913896d77d70bd0c331b46babbd3a912489d88fa0dc798ffbff014bed6d05518cd76aa0217319873eef8194bfa99dd4060aa45e4da5ef557c8ddb4ecd4053c43fe7a7d000faa2ce9b32193b937c113e0d9c4aa0f4e36d463bf8116d813c92273569ef7775c99f9e806c48f52e88223d6b14b8300023b06d84a4dfd75bda71a26f1df68bbb3975ecf4b98f6955c38a9c02dbedb65acf8091f48e8f701d26dc3a30cb91e33bd3019f71c0852be7112b9281e1017ca1009310462f6c595308be648aa7b218421e74017503cd9c8938814ab836a7d43a6d0c7a4a0e9e7cfc8f737adfb73cc8bf68f840b12e2b323b51df79210a47c66a9c806e42f86e94da4e7456753d99bcbe508dcb727610cb611f56a4b9fa9530d72efde3db4e6e533f051bce4f70c1cd5b16efc4cda578bb2f4d8275aeb60ea7c524fc5eb320ca461cae15d52d3a831fc81b9b010297e024e3442caf701bfb061a605b0552bdc4ba4da982bbda61682de0d0b6df3434496b9d828168ae0e1bd2fc03f39f8087db4650e0dae797d9fec9c1920321fa94a25250e563052ebd7c74b24af78966a349235c0673ce0593338bf2a1b2952ad9b56fb54b61db04e5afba5dd8fd2954ed77db6e1bd49b53912218eea607bb68067b4fa67334848bb3df6a0488a83df3670cba124804dba903d4069750851ee3c67c3718fa4e57f3d5dc40be4f00e31019becff2b94087c6312f596eaf15c9a597e8ab623ed5d9f7ee21a360e4ea1756a892c5b732378e5c4bc13b856cc02e51aa9fca55e3a49ca87c91f0ea9723716cef3773be46d9d9ce2a2e7b121621731145b4f1414aecbbe0c6bd3437b4004659ffc3c0ef130cb325bee38cffb429a45acfc50cc646fd664f686a3ef56cb4c649a14bb72ea4d1606320f22206da67c33feccf0b6e30d304b7f1c31b4c36600b2829c0b222168637161f2b8a575f801721de09f1d81463b04078da18a10b19ac9f3b742795ebbb467ac6e2b82cb4c684b656a2345278c700217ec1ead94b913f4de719390255b048a5f258fee3322a1726a34bac55630c1625f3d4c2aadd70684c91b271a71b7831e346267e7fb31a2463fb2b49296f43af81dfaee7db35c921228abb918e4150127143bf4bf10741361d80cb7a539b46d9967db9d396ec935b7b266e9f08b3ed6dbef856cebc0eecb7889872eff3b6813b76af489a56226cee4bdefbb3acdfeaba7ae7a1c3af4000e3912fb29c904f3f4987091c485825cbd354ba581e4485e9c9ce69ef0561aeb4029e6e994ad4446db8c57d4978d3bb7402cb5d2641bdea340a6b171e126acc31c46473d41fa7bbc7c644e034ed123c66a348fb0d0b2a053b874186994e1e9fca9ec364b41548a3ee8ffe8101b6462908dadfc4de4fd7883a2017e179bca83dbf0b90c8f1447af181f65f9e3745902cecb1d0560f79fe1ce6438e3ccdf9204de93b0b6cc4b037c9f42d8ade6619da60cd09f748a873e18d56d6b710f59e6158cd42d4499842cf63cd5498a7480517332d87b2ecfa7fd3f1a38e6ea594d2403b9391feb36423bd0f7c420f5a1bc0361e48f736308f8a0bef3e8388d6c8ee6c35e4b21beb53d9032bbc6c63351e04e39924d7ca9526d5e96d025648b20e4909ccb04b429c5d6dbb0ccec7db6251157fb011c618cf7f27b32efce3894590ad4c98e48fe7e30b72be05e33116cb54eb6d152864190942f55124fe37991ba1a7bb87bcc4e714ffb8ffba815229627ad3e8ad55c2c34117fb8b19aa9452aa0359015016e3e2d6f9519ff79a31e4f6ed4a57e11dd165c988df58d38ee2e96171b4727f1c6f95f68535ed8fd0faf45e853efb01258a1b6ad2d7adc237c3cde32ba6f249b64b192ca9c18083b8d833d99b2b93b55a4d8cea98ef763278408b26313f2e078471462b0cdcd4cc5a81eb690aa6ab7a0cf789b43ae6655ec4541b9b7227952390ca6fdf06413cb633bbf0dec27e5d511c882a633c8d35eb756f4c05de96545d91a63d751ac1addd36032372fff1b21c7512613db946ccbee25a1b5c278269385d8ff5a4053ea685d123136c63f6e07bd50d80c8ad988db6d196b93c87048fda9fb17d35b79b8a1279c20b0cfa4a80ae832998d8ecac763d69c8ca3c4fad6fc5e56ecc9192c2a51b390ac80de71ebc8617e506067f1c8db7f4c69480d100c38b2c038d4823b1de536c768e44043c262743d7c479d5e21e83d19f65a013b2bd6f030ba2642e86029556af9ab01ce88f1061318f7081ab01a606061cd7cfa6b97bef54575c214410087e17fbb73249f88d98bd016a5b3abb039b794687d7f1b6fc3212ac0b944a7282b75f5791d0c7eb4943045cb4e53e658d81c26b24627f8501582a50e3df5612af0cf9870ff6e6c188c207ba65361f8c44962339834e706e724d8d98fa8be02c66bcf69d7b204a0c6694fb9f4c81d93df2eadacdb3a211861846f2a998f094d7e65eb299bd774a1341392e2709cbec6402c7a23a5c135bdb17453c6c12c0e9a29e6d4015b91983f5512ea79589ffb5c7667962c44659da257e4fec6a8903dd28bc60d0d5be63d0bc43be721e2c5ec5771f6482d796f2ed24482a3fc4396d154e63343156f40f5e22e8c398816039c6d6c39b86cb4cca17e920d372b8737407eb835b276ddac6774474284bf80e13da3ab1baab6bf073d1cf101af3d2f2cb6a9a3de701e06afae2e30974285cdeab5da1d1ff9bac467b063f5d0d9628e31fd09fdd53c823d30b981bb60b2d309b387b8b20f3ab61be318df3990846c3e25136556a671c6dc18b6882950326e27ca01035b4c7ead29bb516fe99a5bd72ce7426871c37ffbb75532c3213baa5102b4c64607572c36b4112fdd1627f0b0a5e196132bc834d58651d82805c53f85c98c2e3544c5d964bff207560b5b26c60ae92ab7010e3f8621217ad7fb2b947271756707b92c16ec31e9496a530e5b1db6d1fe3b7f6b55d5e652fcabf7d3eefd1466ec2388ea820103bb865de3414ed21d12c52ad7110e8948861a541a1a2d883cdf7e7e8b0dd795dce31b27abb8ccdf3fc07829d3401097eb9155b45f80293b0a16109ac43f7edcfd74609124f53878b5e2843304526ad44c5f747b4bac87a70e2201270afdd6562679a8da803ad23451e13e08048f1a844784b0e762ea1c05300e2228fe8506c3202664c9de91f7d3177a2d775cf39f9a8bf2cc564af6b3f42f7b2a3b314e5527d02e8e1ac7914e7dea2d75b1c11e34237c6c59bdf1c30fe576125f55c66eb67da44f3edb396433dfcc0ae56871b942857903adf30b25a1fbd55870a20fb3e5840b08fd51af01d33c83534f6f1f7ae198cab24fefedb182f5f8c39d404dcf32873d9d31a96f4cd7776e9c297b55b08bcf6e82267e56ede432f6a8ff072fcb6762eff957a61beb30d59c923f0b4a79550e87682d66e6716c4f73bb76ca49938136f826bd4b58211282af6cbe67d612e8c649959ed5bdaa7f0e901f1af81d8e3c1c88f57366040caee0849974264349f12b13072d07c727236f5f17894c082f4188fbba8a539ee5f5a9f3eae176409ccda8e60fab9a220bb2b27a19e87ffe9f0f35572e2170edc93699ba2edc9ed34282f770ec0d53cf0e96ea8136630fd7d53ff46fd7baec370ffdffb70dac05b9a79a0c704df1667da273ae65297e2a5279351bbaccc32545b3b8e6ca45b1e1b8387af517502aaba85bd2523dbe29176f2935500815cdab7a7026270da6f61877d5cc92d54ec1f95cc914fd9ecbf5b7e9a6b4d72773d1b87b5c8208a9c7fbb95437a04c41ed7db95aae11f619ea2c31e1e1b719361ec9ac26a3ad4efa7e816f1ec1cb9c1b9040f59acc7278e14fb876f9c8e4e720e90e16f61ba8ed01e1be9644eb1724e947ea0a08d6f28314342950cbd20e944e4591e4055efe72856cdecb740a822de4428197430309b633f90ab9fdeffd557e03cd9665990772235d5b1cedd9e9cf3e93720535f7df77492e0a1cb7a30b6a8d26bea9937469d54a112efefb269bc0c24f3557b4b61ca3e4c9d3752d58626c791a6716c049a40fb6ddf5f415ed1bb361ea6e17389174d044aa2853a0ffbe4df526d5e9eabc40a299c3006b79afab51a89f29e45b4b081a8cb601f20b9ab03808e6e336b92b09d2e0d050d94991d3a895260d4ee7e74de1396507388f6c2a7d24696e30606ba79381f7670406198b30b57f00f3cd90d0db65cf2ff88a9f2652ee6310f33174157e5e23da31f367ad10877d0c39f63934feb03fa85f65a136f23a4ce77282ddd1c74f413320af05d33b4fc49628caeb385fa6591e68d39a44b68a992e8a340db8ca2981f1c717430ffd9c4afd30c745ff32c22911f197ef7bc9be29e42e15702640ad5c489e7b633152cf70b82a5b8349a243b5ae67498185ddbe255eb5dac9236d4fdb40e78c9a27b3338146524df3aaaac1d195842e5c382f6dc334da0d33495234ae3ad1d2acde2b7f7937e0c03885628a0861d93e253d591ecdc5dc22f21340259f7ce4de41264ef92224c957e0b6ec931ae7e68031e2cb9bbf736d049f1807c5cdad38ffe4cfc2412efe3c17a42560f33ae3fb4107153d91fcfa935cb1dfab199d171502c33c46181caaaa560a83cb313c4e0f1a23c6d8406a61d5f5bc6e4a1b49773cfc41d87feb3ff3b940ff725c87a2c305eca6ae6dcd7782ccbb156ee7f7270cf3bcecd10e6bd9fa84efb1dd6b194147007e6cd068417a68007a9d13d1f44b41182b4fed93a6461486d8cfc63872db1744c94858c0d7ab704e9246f8315721383d47b025a5219e234bb14b5c46bcfde5200191d847c0e5b88217f7c4c0eede35b059f64cd556d75d7680bd9f83e9860912f52c0d8cd13c1d307666a7bc082b32835aa014a663717b083fb9098cb58c0b750d911a9138cf1e90fd66dad532fde3c61c064bd1771a36ea8cef17bf4ed0b18a4023333569a764420419eca4bdebfd6ed611b65ab04490951406ded20a5571a4b65c5e30d736fff12bf848fcfc689ded794848ee05ae611116b7f2b5b9473634bc5b6f04e5890810c12365330810f3eaa44f3c8e725e02d40c164f81e97199902f6d865b77846d38442c532589ec84960feaac1d1317d14c97e0e38c4a9f85a0cf876ed295bece2e4dd8e087c342858d3be68c8ea5c0898f48075923c4ef4333e9c0fa8e35e9490d697cd6c7d8b1e402d66da32d1f9bc89c3f7dc4aa47fc7acc7d6ef82e33f8f9f16eb8528e9510a90a68e6ff2136794f3df574f4863d31aa82bace6343dbe75ff7f48138c4e2b61f43c57854631d3d707e24ce03828caf2a61da6d3c5c33ef5ece18af13be59f3e143f92f50faa90212daee37789f94996bc8f83cdffe18081a8ceae950e8ef139fd6583b8f8015af599609c285be221f4593449584c898faeee890ab51eb04299c3eb5327c48f9dd9ac2ebf77d0f0bee14d20d25744baa62eb4a80782d8a0bccec93edb6c3804ebbc20c0f98052244cc2ef6a11e71a223ceb1026ac7274e4657e5f257ba366e4cc6d3b8ddcbc7a5c1acfde2bc3e11348334b6a4ac9f8197793f493fe1b0d37383f490c63c27348e8941a41aae1f8aebc504156f82d1ebc10260648ad605040c531dd20356160f9b4cfb65c8c93066c9f34f4298d6f9a65914251890f80cacf2bad9002d677ff5e03a0fe9646235b012dcf4258adf112789619034e8118e99b985af6af445c358c188f54a4c9a42820a660d5da5b6e86a3b4281683016a95203b99e84cdfd8b416f29ec9724a8c096c3266d22bd2bc27e1f2a8aae9a6a79ab2b5bf65a5dd8d497f08253e70945581701a45e191fa47bc3abb392f550fd6a39ee27d9f50af660ce704250c392cb9b522a96a9d520f475ec19b7cd313b9e37ab836d22f6e1456fee521c4065c868abff5f059ef4b7554f216187b983a5e476b040b960d022db74adda38ef920132062ac2a62782bb9d9393f0ed8fd2b03d6b991d1a2c5d094411e9bb0b80a8fa7f7cd53bf7d083896af5f516416d77eae2f6b17f8b0a87ab4059dcfb597fa2fff126a4fb57c72918a96904788d92dc82e6666c714c00a8f0d900e394c07d4e86028d9cb5aa766b389cfbc20da99871c76dc493395686bd722538d672313f3ce9cd735549d8dc80f7bf1c275914c6589c2d5c79eedfeade1af99d8346139ecb5b8228c6c3c2f58028c34223ced620545e3aac9f01757a84bb7e98ef4ebee405453b0866693f683e849342d8eca859491e166111defd8a97823f389acadb709a00b058472f48ff565d334d5d55319b14315695ca27e6000cfe99dd1a4c758705258c45b3660d85985da6a607e7e14b46eaff7587a6566f8c808df288b481e55cff3704d38fcfdc49b1f1ba9d24296075bbbd4b4280fab9d9f59d1737aa309398a4142d974a7c5691b58ad0832aac5710eef399af1ead4c9513f215945244d1d96bfa2448bb0df997257d5809d01dd6b9474b004ea1e8500b2f5faeb2b632b61b087da290f971c5bcad9f258d7990be49a06ea31878904dc340614adc7c52fd43a71f38c60072bd4e166679fbd030f88237eba783f95ba85406fb3a83bd842f345ebdd06f98e68b8c5dc9e190f24c61223340b8dccba751e490f8cebc9732ac58b2b9799cf630244c4a10c4c4566543aa010c536c6a6bcc551fb2d4ff29e45dabfbdec9e732d27d211a0bf7b362774774dc96ed7168c31d78e92a5db4eeba72aed62d1e9047f1129f3e70b04d579ab9859c90cc18922b4d256238fde23ef1a3c55bd849af633fa0cc27ade4ed28edaeeb87d18508f82c6ef4b8f95aeb4858cecc6f7cba14db1111fb31aab0696b796c497fb364713c9cf22980bcb8f64b625034e5b795d9c6939f9811ccdee481d5ad610551910f9303676e351784fcf3353804474c11e9b69b92337edcd563721bf37c472ff4e58f0e8ddb42307eb6e7edfca6629da004ace73a90fc3fa967995f1e5bb5edaa84d4915ae50a00182536f0f22298ab740422776bdac06a085c5f80b79a2f0bcb82e7fdfa6d369867c7ccc97d6195ecc91af3c6ec6e7d46ffe007814166ff97402d73cf84a465ee602894b71b3bd9b0d7ee84c1fb5aaf2c7a1d017f5a0e88449e3da57922ae928ebd23fe15ff7d277cbc4cc472d755194bd1d5f90c36e07ee1c7bf67c447c889b583ead3ed33f44578aecbe63309dd12ccb99aa2bfc1df83fb0e4e88ed7a08f2d2ff39b1b7190b29790a31573182411a08b078121b8b1998f363e3cd7525bbd9daa266b0c546dde2bb8d57ab132ee8d141b3bbcf30f22cd9627da887a39be9dd5cd05ae02723dcf253cf13249c29c4af97e7fc318e7e3839848055efb9bf93d560d4d45254fe01bad8d5bdc4f99fb5e6ab71a4afa1a08d2499151cceca04236b54b558e1c48f70fb4799ac3f2fcaaae0e9cce0be776f4af0203e67562dacff0eb5ba37ae699921dd260bd5c1ddc864787a1ddc468cb0d2496154813f683479639e6b980bc3b34311a3e4920f63d551ae5c863e52aefe9cbde4d86b688883f1e9f1f207bba991b9c8db4512525277b113500ff4d402ef5231302c28215cbca36168aea3b5bcf03c1c85500342b15b23111166ba956fb7af40985b113b72636d390600eb5ba4425cdf3d12dffb54841c88f4e1e10e496a71b2c20113319302c811f54a17056469b7a43138f4c0eb6dae1bb0352a4e4390a69f874ac6b43e6a2b16c655488b6019410fc79fda77adf2929c095464a97ef9ad36991608b837cfe76f26ec743831e722ac740c6250742910b737b1c0c702780c1e11c98983cd2186ce7de37c50be59e754a5f35706418848320b19be153387de94aa1ce47e813ec0617f0868ea797cb3884f873daf9e372a8bc4000140c9314c9e338766e6d37e1ec49b09a6f17710975d8ed35b48aa4d2787c48f1bfb82a3dd5baeaeb58726859d6e78edad728a757b8c2887044f3fda52b26b0e0bf2d74c16effa2e8f3e0861f17c864e40c54a57e2be378a7b40136ddae784d04fe10dca9f83dc849b928734bb42899982617243385aee777fa4cf503964e83c5605f34947ade93a2e4a89d4c8d61363b39867400d1ebd04b8d0a40ebc0148d759d47ef39b033c91ae909bfd6a587e7c90cbd1e8566b3c02d1cd4457e82709812b0839265188e9cdff10c85b8b74ca2bc5f591f11d5e4a3f962755c619023893056d645944f809b7b9fa447b20cb71499b3cd1de7856d63ea459b948c3438c4b216ca3dc819049190a6f37f25b3c0e318b29307210621ee7833034e949df8bf6a5c98487afba8574397ccb281260d83defb4940769dbc62da04432309512cb138d84352ae372fc239fef5df315ef86d39051b95d84c674f857a5305d4281596f249889c6c835517b0aeb3b5a74531cc80c03b9fb8a7c4461342df7865455785333df6375bc574feecd67cb2da16b74948aeadbfae638852cf8003bbf40de362a829cba9f8069d13298dc15c5b6fd19c3cf44ec080eaabb81e1d44df79e5e0e93460af20456d68c9f93c0271b3d36033e0bc062ee36bb45fe00bc7d0f588fbfc8492ab4f1fd81f50aba37a72b29655fdaed18b0cf17ae3f897c0cb503237f00c17bfbadde956acda9abfdac0f54303116ca403179536d0c5347ae931bf24d4cab319002f5c2f08e3d4af1e844f0d400d3ba66f98d160cd5d843a351fda3da1cc02a268a55e4205fb147df205e2181523d41cef58f1ad2be41b5bb360cde80b904316a9869840872b81f429b10b60543837d2fc919c10cc7a0709dc19c6b4ed80f1a261feaacd4302d3395162a575b7b6f013594b822d4293da46e32238c36c786dffd2f3d0b51ca4493ed7d5c203144b19284137c3abec22dc66dbea355636d90a4882a1543e7c5401089efd8b5c9781caad0698333497cc4e5cea400b56bbf227d947138560241fd6c23f571ef468a7973deab885690ea7fea2001e0b8c3da028a3fae1a94d217410142a09b92dccbfe758e1d72efafc8b20a4c8b482df52003f9411f65a3afe0d103bb89e3cbe65f8eceee83815b85e36349073d210505ac2cb0284c9f772a8d057de6ad7cc3398e9619b46d34e22bf95f83d0eb96c515a97b518d59588b563003e569e3c3a6839fad7f323ebe12b7e22bd12c11c8860a4bfeeedc8abeeb3fa2f3f282d4a7a198c87cf7a7eebd47c8c2d19bc57119f8aeb3f51c823bcebc5021eb3a29d8cc976588ce01d87a9362d12aa1cd6b3478bf3637bbe2fde7a3d0f3241922fd57f7b763c7b4106209aae8d07cbe1b7701300cd2dd9cb2c0acc92ec31931b5fff7bd344a2e0394efc72a453b0987702bc2774b2bfb7336b38b2db6edb8d373b6cbb7976cd640dae61a74856a9a95a60b0cd61f74fd080813312f761b03a1c36cdf765e611dbf3ee95f97e0d0a434c2680567be65df1cc4386b271d4f7d801ccc57fa3d1b43f5a45fe4584d828b2eed9167617f2db95dfdd2455033e014b35f5ef7e4b88cb45e5def64a22137b611931f7be9eb0b16cb66e40366872f8aa7aca41c212db0f546f094e088b6274bba6e3cc3f4a6bbf3789e27c164d6de7186db3be99c9dbd98c23111604814325eb7c6bd6807b85026e405779dec55a697b3ae9d60ebe79d99907da9abd14d50b41c1cf1bc452861895ad7d0301f766ba6ca10cedba3fab0c543a0a0210c55848b1e8c87b212795da5e90cfa2e1da951a3463ed5c8a58af4bd1b85530e658f611e9696395e468d20bd2e645965b84a80a181cc8a8c053de49656b79cfa147f41a4c5eea9052cd6c04db1be902de5525ed9eac74442c3b1257208b1c1efbe10c55041cfc46fd6dffb93387d0ad87c3afd0b34714a15e4e682ae878e0426e247be458e39fd85a5dd337ba877da5b832bb5bce3a6cbcca26219d9e6041310c25ebbd822ce2252bfa2546ee356a44dd10baf18de66151178dd41d70bd2d79b3b9cf1e2e68a41cd712c316fbd12eda938a5c775a68943c08f5120bdea257ac3ef155b6ba0b05f59460aa64911f20665fe7702fe5401daf9554b14952e7f4ad7455438e8b7976d8f692ff556b597f7216f4079bd67100f9462baa11d229f59503123aa76ff8510ff1046e80c87ecf15444dd7369ef5d92e812657ce2a4059a369515aa7c04f2830a641d137ee220fd36de72815b1eaa7d84744a808312a8806824f4aacf83e90899ec203e2ec966d8fea27f4452496ddb568b41fb00901ee46ef3c43d51ff1c82a61a63379487b61c5711c7b01053a0c8399d53bd74991e7bc7167fe3e765e91294b67c3bf1c065323704b9d613428ee0b15e3afc323760bdb1f33b5db7892434be34fb30b033a928e44d55601c0fd04481156b05d4b9edc98184afecb06066d198740ef67e4d9795e3be0f4330133709f33d79f1285e06b8d66a8d9a3138b4d1c8546d04e45e91e8018285f453ea4893f0380043065207d060ef75307aa9e6dc3db8041fa2b1893bb15140241c770154445ab9e3f2c9747caecda9895f22e233f38f62ac7f3f0f18af33fff298bb05415aeddfc53c781b2fd0930ca643dd0fd7fe53c8daa5be2065f7480aa8a2d95201a707552f905c5a36929e09d686e30368807526100a585143bd43601955b8d646cd1da7cda16a347b12244ee1e29e7db61f34a622ea8825ef9dc0a3a1595000a134dc0a1b931a9815c2ff9c4cf8fe6a9dfe51db5b9fb8599ef17159c62ea1caaab6704a75f7206a346e57838777816c4237432c2b614d7fa80e72d482cc65649603501457eed9082ec654dc9814e98b71eb026c5d59f20d1730235a7a7734d0f6a3d7ff10db667bca382fbe5ef36037f39a50138126ba93d2584ee1b18b6cbd132f8d1c207aff57aba1cccc116dc6526d9a1b1fcc176996088b3e5337d54b3abc7cde44884d7002410da83c3db865d905df09db5cc8c82a971ca74d4aed9eae7aff57d1deb53de3943d1da0b3ba67fe57b20377c72d4016e467e4675bbbf0b7278feee6a084917ceaf46c3851f112f96f5dfa3b980c45a46a573defcf6f3c7048bfb2b1988c696b0c04ab8c82e86d1f928eab775571a60629add66d2246b7bb4557b6d84cfa85d57446de9b0bb90a406522b92f36fa785e87c46e33dc063e87120ace58d7112ade071018350475de7a524724dd1774a6785af4bcc2ba2bdad83688de95de9b4526057a91246eb0df0a2cb0d4c76a6627f8e8da1487801e11b73bcb3dfd9cbfde46d4ab180a217d31075f4ba783c800c5e72f665dcb0eff4d7db83ad699b8404c805ac1615448a6eea5285cb5284740861035096488aeb86e74dc062ef44c21a07595e877310a426a2d661d3635c5768fdd0748a367f9bf73cc8e9452e177e859df62f8562234d9ef2a1ea27af72d2d93e850e5bbf634b357676c64439df1846ad449faa26d0355328a1d41c3598d294484e8782245107bde68af0599c6627b8032112c5e7c85a132dc2f0ddbfe6ab882e4a24f9ec6022bf7e552c85a6ef2efede0dbf50f4c677ba94704d1861e525ac2152214a64b78beff8f6e22659c70fa414428de45e48032b4fcda2e6807d7bb6bd845dc66cae2f45664278d52b5c8cf3e3a9ca72aeb5972b2425259f7e40f4e0440af4f42861af4b56046a88e706d56789024990431c511fa4e9c5d13ad8fe2ce03f38bcf756c275a396fc9d5d877866c6df1295f713168800b3041c7bae35b542ca2139af5f1d78fe4d17a3267a2d7b506a7ef0cffa1d6eb826ac3bd302b5aa3c07dd7e1b357151f3eee14c607aab73f3a23c9b11dc53123bb290ce2be768dc31867d3cb5fd2e40c0d45184fb24f8af39f3e95d37837cbd262cef97f50e4abaadba77e6a6fba83d92c6281b2f4577965b6fe6d4c90fa4308f9bfd7a8c2d231ca20c1b41c95a2222a6ad20137017c44675563287c5e34694c32190083f872514b3a913df1aa562e61cd3419913922735f6dfb4ec36d6d4362ca3862c27860bb6b1c78a044613d7f80c3943180796986c51d8fe9835004651737cb90adc2eed97a427d1df2699bdf8b272faed96367495283e693af7b84e43fb6ce492f84c08ec9999b695aecd0bcea66ce8b4c3a91f403aa05057958377e8bfd317833af1791724e0ce53d8ed7138c83599dbe17f3443e0578f30a2e4c674d2274fe91e418c2e4ae4fda4b2473d80089dfea5ec6f08d29f55267903384b7dfa60c7a22fc47759f0a4559df9b646f5d73f69b52b9bbfb2dcc55780c04a91780d95f5ae31f35f382ad214c3eca24d500d235adb74a4d93a096fb4a278e058fc8aca7bebf8f55a7f0a23bf038880b9268fd0493d1047b5f6adfc4d0971819efd1f7939916a4f198d841fcb6a8c2471166ec0ba68bf96a7b957a3855d8cb224b74ebcecf2a9639a8b7d76858594a1e8f079fe8e9442d87a77ec33cfe47da0f3760f03a113bcf3cacd93224a7f150aacedb0fda092da3dcb4d20de7ac83380e55d28d33cf952aad61e739c406cc645fd0b42612285ec61a9c163b60a8f27e7629a9e1f49d29c938eb4b0298b89f6b256b50d46e1578e0903a2a3808d3c840b22ff32d56faf58ba709fec9c2242a03f4f71f42ac9a1fbf06e2a8b93bb86fae3fa3fc81d2297ce233a2e66c9a042a5081e4337b0ea4cba855b5a2f11f2eaa8ca11a3da7cb32d8449be77dfa5e1cdbba0cb93bb5b1fd6954d44ecd521f57492b06dd4517270b648b92ea2f917b7c4169d35be98fc6533a0c8598ae30404be4d8e3a80048c24682e6048f908549e5ec41007e14228d8b715300425176f9c541199be1d6a42073c3ac31f5233a64b75160cefd2f0b8015a324b0479933143a6de9b7f8a97977c42be3fb5bb2f1f3d8e639c9963729e2a4da33b6b894a99f75e57cf5789510c136ec39b885c71f16a4f489deb84a1f1d1abea9a370139ac13351aa997b4bcf077081456166663487cac75b8f138894d9e7970099b627f9e1d0149b467a4a50f7d9e89db2cca2721bda6b8be462e2980a064a27b9004d1388a92cd34108d6ea2540717ffe4687b9d6f63d32ecd0f1e5ab6d8a4b2e9d74e3eefb8131a91bdac8d944a1278dd9e908a6577812c629c366783458328b24939c21a55adf3affc4e790a2b5dfdad3bd5b358fd5cbb2dac64c80b3b73c4263153a829f15ed399b38d450b9d7523b091154c01650db40a960a84118bf962779a6aadd4b6f88194ab32168a668023c2df557c749d83b73819edd38ca9f084f5d8d86892d43257365b8825086ef7817aef847d6e14087f5091dc778eee6a17cfdb8d1db93315c70841d8e20bc4d3ab00bb5d2f0b31e8b684ca0957f87eb445e4ede56f213657935e50feec09192ac0bedc8bd520d45bb63d45ddcdcd9f8c751a1f928694a296453986e28ac42e3b766c3f2b2a00e278bf1ad036deb4494929a2b643af0350424b831abf4e8af32b0f082ef65892a5e2d598a1de904142dcdbf0c4a6c0d54886ff1f5093cc4d2b5a13e1e46da26630f03fde465b3a855573f24fcaf773e3ac37dc4ca0cc394f640483c45c8cc246f8d97c06932655b75b2a97586cd68e94917c1cb53a98c55f7a3a7e0d24f3cfa2f7327807feb0902a85f979c1f7d063d4eb26edc8d55113d981b37b35c6e83995f4afafbeb7dad5efd20671cdf5407fb2f43ba359ac626c456051411558631990e62fe569c778b0f60e3a2efc4e7d741d82ef59915f0bb6412beec6874c2ef74b9d0fc8a0a3bb75240bea76c5ee23604191461357e0b38094249c6997984fc4a4cd1b68bf20983f71c8f05722dd7101abc31b764c67b26cb9a8531df7dee79e4ac4b9b3f05a30ca83aa9a6f00aa84488a4b606d18e181314bad8580ab104a815104cb1ed7161b3d3c1ca98abdb892a28f682505ab1ef17310438f69612235058eca8b1ad35e6aa807db0d7025308259ec9f2ddfa8f91df8406e5b0c254223187a4147b0af87c2d836ef298f75fe52deb6ac39748c86701c732b45fba56cab24e7fc043d69ce8ff37960f5cd97e28c76fe6800d8428319fce6d44cc8da93ebb9874fb341ea99b3cdcc24f4600616e5a2520bb901380bd1f5ed83e087690f91e702822476f05f72c472ba0732983f77faa2c0be8598ea64914ef703385da3a412838b3816a7564acea5def709473879509ed285048baeff594bb9c2b7b7a45c081c5194ed852e70f6a9adb6d68cf67458968e51df8e0ebc1165bbb5881a36d77757c384487cf46c6a8b25a1d80de4a16057ccf0de9b1fab2d8f5d61400b67ae5d25152b0bacd4d6659b45cc3060eabcbbbcdfac71abc8a84126b4e641f25f47217e3d7834e01c7a537cc650486e71e7a0a7c0a0f1ac292398f98e6a73cc1e33b70839d50ad12f6f209689264eb84952a578321b00970cb5674a071354846e5eba9e7f5bd88b8a1edb970c3f7d773d8917ffffe3229153234d431a7e9e09cf78d3210f33fe005d9bf642ee2b3b7e38755114e721ef4bf3ad0c86bbe47a95e151aa91d0c25f6ce5da9c5e8839490085ed04746afd594901359a4157fcd3ba21ab1ffdbe535521520e62ecffdfc77c0f28fbab3363ff5caa3fe1f30c72cf6d1599ada385cdcb3bc1576ac19d6b9ee75227aebf43ac4d5db344634b4d0a57184a5778870a10556e8d57fcff5de335503149a0f6d0c3bf5f0c51aaa5c105338caea5e7919920fb585aa0b801af45000674dfba8e0549f45bde7fb45a62e4df36ec59ed89b65f0ff2c55d01249141c8b6d7fcac1ed9b45cc4f6ebc053ea1fcf372d58b5bdad1c222ce88aeea33f16098c26007fec2565e5a90252ec6c378edb4656d4a6b05c85023aa2d7702501ca83c6821f85c917b5f3ba8485ea032f73a249c5de2cbea85254ad4f607ad26f0a25e21e0f6a2b0376e5d85ff92eb10d9d554ca58b23e82108e574140849f668ddebe3541509b6b67ad2ea325ae43b35511253f758a02d2895dca2961df424b54ea44a12f8493840842cbe01260dc0a50fa1f9fc548039757e51adf7895fc51bc2409cbab4e7847924309753ca0cd3100cb5a4e89884a06eaab53c5332cf3c6ebfe8a00c050806438cab3774b48fa4e731f4f414f1141f6954238409d12ef3d9d7d48e6f5c244e7a926eaf319d36abf6e0b8024dc6201e4137fedc6b2c63e836267b15af2ee6dc154685f58dd3ead480895f1cc0dc482c74580251a2eea3795933cb57ab792cbc589f597c497e20c67a5e8f21f521855e1ee634a7f067ed908ae7cb6d3bceff06ffa557cdfdf7aa9c8f098987e233de2e24b1d5cc060e558ad25171a832e544911748515554077e7cb5b4a07f5d2cc91773bf75a0107931243fcc3b8b5f5f99bd549372abf596cbd1a9697f3cd7bb504d384df3d6f0224b2f20dfa1872e2c5d2ce7e97b014a3f4b917ec27c19dd466db12204fef92cce55250061e9403d64af5d252135a7efb7e59836a1f851fef4bd4c9a7c991b093dcef154a2c81ffb405966f8bdb414c0c4ec1f912c72f8d041dc72970976c4b851b5bc009d6f2871e7248f7e40688b0f898042b1bcab01cbaf85d3e40835dd16f494159a53db2e2fccd522b373fdad34187431a6df844a65f10a85277e03cc5a3d632f3aacf07b4f1f40b958a37d7e891e8e5b2ed46a5ccc62744907f69c06c3f0cdbb2f795af62981e404e58f7c724fcede33020da0639db3c60e676d6674fed3e3a404e719fca169fd175c53456a08d89a398e525d8f710ed7580f7970950d010a048a2b3a995002ec0fa861b207a2a4668be93deef2519207b5a9757d2d1459372a9ad5af6afde26352b5bc6fe40440fabfdf1f4167832cc8aa45c3def6e0ee5f1832719211d9a861a8ded5e1fe61bcc267f56d345f081c7b46f5c59f4e0ca993d9587df61e85cc90a190270a38792d5dd71810aefd83b3a564907074a28b62a188eb4b6a81c8cb5022f50c3d8cbec000067f9e42e14976bf9ff6f63f46634832cda31f63ceddf58dc8a8106a1e6d442d2cc2be9a13a6238216932aa17993ae0a3954b9b3235f98d555d1184f553b6de1dd2befc64a5c8d1c53875b957ec32d75e0e1ceb63d7c67b2c18a3b43ffd13cd990f4a9a0e6b33d9b1bf63c4b262096f27877b72d1cd4cae2664d8e54dbced8e20dd584e6661f134c1d50d14b0f21e6f97599d7ddea2d9e1351bc9946359c071e1823bbd599143ca0cb3eccf0f8915f3a0e53501e85fa6d8c4a4f036dbe95619343585f70a0ec5492686c9d9c8362db8976e371bef747178bfbcf6597bf9b2bb5714d8445d3434ae612ea854aa22d4c95811d68c653fa329bd3fa916be6f9a5d8ac103f51d77f179e53bcec76c3b9e9499bbbac6a2cc8a2ce866608c14ab3711a5e2468f09bc91fca22f48b2edb96d39a8d11bb51b7aa0e2bd5f5fa7cb2ba59e09a099458d5e301c52113c89871c7496d1f93a5ccf4671915d887233da0fbac11f2ff20f6ba6c8724ff9e930487fe16d87e0d6b29333f9e94957fbea4e14ae42259aaec1e2248035d760a4f3f073bfd2f42644894a51f4e24690e6408de192fe58d9d6a48225007d04698c89c1a85b9c86811139f667e8bc345501ecaf39d0d3a9a8a35c9816652af9f927a5730709cae95d8d2efe646e3d8a4ce237cce3e39e808db889494cebf0bb18c02a968099befc351051335f2c2d70a7c2690d69cf977558672a1852324f0b2d77b89dd4e85c73c04be88da6203780ccb50c976034a526bbe577be382e16c21132009df7387072dee88b6055ee5d21d55620e68894d82c2aa8c11b4e5570b4fdf5291fbe830f278e5cc91425ed575f2523553f29843837bd3897bd6d9c317bfdb2adfa1a66bfa30e6bd059d02c72e23580c1404045d5a6507","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f744e1308c3955e9961bce9759ff922c"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
