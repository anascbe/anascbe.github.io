<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Enter Passcode to Unlock</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #1E242A;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #1E242A;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #F9FAFB;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Enter Passcode to Unlock</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"95cd22823c73c231602c028e1bf6c202236bc166b040d43359ac801d64a1635e3bc08443ec28850c712e9e1e663ec9ace4c3a8e18c8e69f618c2038b0f0a95d9a169d9cd9b42b91a3cccbceb6efcc1513c794ed8bb421e2042db50b112dc36eaddf0515e185924e5fc502be7bdc71c5ceb6cde358c78d369b2319a4e69738018800215180a59b562dbf285dd9311bab7057e91b3b020723aa3292dd8658179bad8e77f61cb3cd55a7ffe6691c408e0097576cbf0db83a5206138492df0a3843dfdc668fbb12b894f808da53f96b5b0aa02fee8c5700e4ce737f435e3adf1decde31a9fdcd96958d9357f17dd956997315eca4072b18ab6540286106db168c9df6e0b2927bb498443d45b34fa76f040754b397663249af2d4f14892812ce2d7b47870e3238de17f3a9fd2d0401f2063b231412f1e0448d02afd6ce67d8f74df431b6cf3cf38d6697a90ce01db8dec8055549da48e6a65c0fbec2336d56460247165f94cc420584b18d16c3ee08ba8c8f4380609167236508369a79de1909f700b78b5815a89e9c0ea1a2a51c64c97d6dc80a03d4630238685dbda07950e0b4932d10f6036c8d6895c37b5dd42524de1e09534d3354ea6d95c2f28ecebbdff16687f473233ff381a7c67c2d7f4ff94022bb32fad64fb80d6fdb780b9561645c2848af7b477da7fc496a3a918c1797d3480afb7e75346415a44f495de91641c5e5ad5ca26f848cd09e44687b31fa6d22491d4ea7a9b90ddfb443c240f61db81157cc38cb818291ef40229885cd8858ca19e2a7574ceea389deeb3a88b9bf81408e0a3a6cfe757a26cc921db4a1989ca821a28b1842695048ff0ad48c1f1d187c8fb0c640eb231ada22b91b1b18f786b8e4e7ece113c28869d0ddaa89d2429f1c12e5eed6545f84613988d6c0dd8e3a38f6746ac77be389656ab962c4a29093c2b02a0640fc91ffc572838d6221bb8670b5be8ea6e06e36e31ae26d6441ebd6bc52ed927848ee9383aa8482f325875da7a5d9708327e2d5647a117cc11ba314c892a09756c51a66c6e66587cf5438a9a1146780e0c081cf3f46308edeab582f93f20fe8a6e8f243f70f362b35742809b782d285c0b2ced8d09b686e7d6912c6e6ebf1849d13527441f8be32a866300fc353bef0d7e19372aba17966bc2c85933c17f75d26984af4c6ddce5687a4f7cd39b56a040d9e4f720e5c610c2204f8bb0c43529bc1f4d437aaa9aa40a1f3f49134f374f5815eb6a3f28f0cb7751e850cb001042afd0ed84215f8f9b48ff8f9570ee6d45ae84c47f10afb53b93550244c84040032e81b1198d3e00a5c996245465ee37e1a40bd985ac23a2b585df4a5593a6f5cb53ae96d2d86b1bb624ebfb786562603b9dcb95438055e339c75d6ebd2b44bc717df0cc7906590860933b6ee39c2e53d2a54888371a0104e02abd988ef94030bd4848bb928f4d4e1170494b79693ac9feb3bb6fa66aeb0d9234f754a27734ac8ac2c2c722563fb02e6550da6572fd18f068d59a72e42519eed3e0ae5947715757e532c2abf1dd1d0780b3c28a9ea309459e88b1ab7933547176e788db19349dfc245fd03f7ae1e360b419577c8394cd7723cfe95087b6bdc00fa7e3665b69777b19c97416df16d0d98f20d154a4fed8f80d23fe9d18d8ec4f3bc109862fc2764d121e869ab71e09b49c8491e78dad892b8ec9a081b4f91338c06b9b549138fd9b5c41025720ba4620cd7c286f54ee6d5eea7f27c7d050155602cd59545f5dc01e342e6ba1babe598602137c4489a702cf5cd8c4cfb7debeb4bf8625cefcd318fc5cf91aa5a0104aabfe5e672533873c7ccf10a8467685efbc7da14a254623fe179ba4343dbef00843612c38f69b2387a45121984dec33b67e54cfaaf6cd2fa966eb2575980f27816d6517e50f0ef5a1a17d3c9d5ede22382c5cc863d738a726f2b6bc535da274714923819e2a2a99fc8b331322e4c21d5454d855334834bbf4c87eef3ee8600792f1570f6fb4e748438d810d17492fb538d41a4e530fdbff720d5ebccb3cd8619c7d23011e3c368eb6e036edcdffda2e2c22ddfc8f56646f94fd7ef909a01940c968c5be0f02a3575b290157304e8f38d6bfe5f2ab57b32a4dc5d681dc4b791665ebe5abb0ef92fa500e2b03ce1ae5756fe0ad93530792d7943009a4e9a114b3390b0a578443ebf7e1da4d99a3af05267c01c55fd80895d0f7cedc290d2d36ab3b15d731fa73ee780887adba6577d98b8f3303db6febc8a5aee77b6886463c23d2ca680fd30bd21c909ebd9e8acd47edf425d130b53de770e2c9fa5a2044b4e57c9b0dbd6837d5189aa25df1dfa877404dc8c20fca1111682e8b553c074177d40d4f3edda7e9373186e6c0cb0b1de0277c8326cbf0e0bc9709ae0e7ce3dd26baab7e4efe9f6708cff2123dc22ff0b7d61f42bf1e3c8321d8b608ed4221dd0b268dbba4f3e5bcb64426d930dc822128963fd11e3f89091a6311a921f696919457ba7dbec7bc717dd4ba39136d218a9dcd8ada90a7f201b8f9a0a8a1a02b5fc19c7d839ec16174890c2f5e8a2c7aee3e27002f489f748e4e4af57ed95dece1405d7798cfcecedc510963ce63f405b404211b192ffec1d102dad413e358af81aff39b63ae4d51265f8dbf93ad4a9f8af7ac5dc70068014e666791583e04c0c4051d47fff0f027272b345adadb5a5d1b4754be266ad1712e1c62c6e5bd252e5b648e81c888f1d59f74b8c32c11793d9bfd19ae3b73ea5ae290a7e5fed5a84bc964da95a9dde78177f6fdf5baa972a143d0d3fd0cd9a2d4ba0d3786e3d1ea4f35727fa6745dab8249ee458eb052d046a690912e243fe7dd8d78a5447c4eb14202fd137edf447cb41624d6c1bd9be03894dac49784cc66e6aacbc594951d2cf48dc21da9f88d4447751c17b92fee521d828d3ab3a685c1e3122ad931df9714c75bc336ba04f735f479f7c8d248bb7d805ae6864682e6ead48468347a80b537dfea9475bf6c79643056919f829c7b0da56a9ae416b625888953dc8e400cdc506772e60bee7d05bd9c30e3580f38368fa90403975f41b4e21a34c75a923c8f03721a05c396e4e12a4b3a5dc024a3e3075eb82d83a30ada35a58dab5395b7aa86d354bfa4550ad44204698db1fc1cc38f0ba6b9eb481aae30efc7b51ae4d81f2265792876d54c2137183ea35eddf38deb882d2cb033b62173275a57edfa17b96f7fc412bddb0f21d6b331e1eaeee7fde96c55c5075b4b915f522d700671288739d223f9ee9f91f116554990a92195187d246a3c8326ae31cc0b91a0c66ae77613725e1ee4c285c8044d6d1a4766d1adf50ecb547e5d6ac07fd2324d3ae9f550164e04ee237d4fb6892ed1274484207f6c6c6f52a4f8cf8db698bbb05e54357f3d0bcc62687c1f17e0233e2aaec9724215c8b8cf233f07fd4987710cb45415aaf1b44169a995b507e155f55e853d816978c01dd0aaa6786597f679dd05444cbedbb3bd6329155071f3c0500e2d43bd34d9f536f7b5dec153815f0bc86d50a8b8172c4db1d81412c1383ef83f6fa90ab3a72766cb551b4a3fdf9047ed6bf879648e669a3b6ed6bea852a0014302ef534ae171c44453cd5f8245d29d97abcf8012c71e1a2acc2aad761bc484f66801f6999142078704ff7ea452e5e40555bf0e935f1989178c265a18cdfab736f7e03da71977340233c0e4ec8c501b350ed21b17c7ec35ae086a5a5def025a5e1014a0799cf56d1cefa205ac05aec2d063979134a8c8863c0a52d346370e64467e193aecea25d3c08c62af30009aeeb4e5f14972f46f87d35ba5111affdb2f2ed83be359745ecd16ff126dd32d034e39a86b098515e71eb2eabb5b4fcff2d02c78a305cc5b0e4f5c9bca299544950caeed3653a0ed771085adff8e4962d885c1129918ee558e84f0eddfb122fe22ea19616ac1dc3acbb1c93f2d67dead0f1c64d843d0165c5ab987251222c8dece6d92db71a20b7239e352fd6d962c2e9c567cc7e577317671ade75e8a0f5f025a92142aae7f9f771b9ab7debd41461ede5b7494b4e5ab58597bbe383ed0d407d4ea191c1e63424a2bc8bb7b7cebe9fe6931c0e8316da7e8d020aca0ff9d26817a9776d42ef23998e340f9e028ea53750fda5f9b0d9d06af8f42a624ef07d4818c66d72c3fba83cf57140715b40b226b22a0eb0b9ffd88ea99ecbc84be9edd2a231b646667a42696d043833242a8227017bfa1c18a75024d51920980e8ba6daedbaacacdc7908b237f9f47bc5c9654da786d27a9b0e5c51a7fb9703949e8b3ef1d16a2452b6cf11290788b096eac30a3af678cbce3caffcd306d646af7ca981a919f356ee1b309c44b551d87c862db44fbdd001150710dc60ecfb2800e3b2e9dd827aafd23d00e325e90a6decdbf8a204b6db649af8ed73dcf4712bbaeec696b122d138ff6c070d58551842e58a38e57d49c4b3b2da0f304175cc482f7e59492b62a5f001a5fa296dd5c24722e9d898bb7c987f8d9f315b58feffd4b53c469185cfd576e2ae3d37bd7612a426d9e15908f0a9fe4ea833696aa9e1f7222bf6597734e67c87c9e18013c2abada607c8aa1c0cf7b2a7ee7c102d315fd11adec8a591a64abdddc69eed5ee927ec36f5564ba440bf62dec5eb3365fb81bcaff8603eebe3dd270e70d59198af9e9de8003f87f648817da84f9e11aefd3de900c3ff61c43fd3895d696f01df1363069d42c4e0cfe7809391f9bb24616abd22fad7739565020a5ef39ffdac7ab378c0486398676edf0c2455e54266fc30044d9726730f8f7be704966cd25f09640e2025edfc6d73b537cb2d11fc220780b2b2e6d653ef9a6d07b1692aea9ca531cc73c5169657c90e26b457334fb967dab527ca59caf0e3d04baca14f5c50391f09235b8b098838af824210aca81b3cb6d8430794062f28fbc286e45b8683894fc7209c28f9424bf3806af833de51b949c11c1bea3405b9a0ecce55d243dafc90c39f65560253006d12d269779a35824141d84163510cc83fc8adadc37da3fb48455f27c10fa4d0c644c6032309f5c004d88cd75472be219f9939af1ed57dd561ec216c29af79a3a4a948e7e02ae493e6f36abd1d966932241bfc30fcee8bbf0fe5b1df762e259a843799af8c689ffb261a2a5929ec8569c6f12547972167f934bd9ba89909751d1798be654685d8d4c7f4792403d6abfc1f72b96ababe9cc9d227e8c9c320f5ae6fff2ee45b84e03f207e8e2fa6c6739885c9fdf57fe60f0486506e140ad40798bb05c1688aac412e1a108226b27e35e3a98f79999a060b069aac96f0e2175c85624b00e1c05d29932dd01eda52aa438e4ce1e0b53bae29417d5cc0b324db5afcc536f145551fb473363420f8fb9140d9b09e2c36528c8cabb6019ab79e7ca6da06dcf225c0b2d5840e5ccf1bf24e8477359340a76e04c14ddd11bc3e53dc78bae660e37811062ffd4799a084184827ec25c875092a7453b8ba6ffeb717e73f2ea0dd120b54ad8ad0c8a3e18596de8924757d3b10e3442a7c1dfa067369975ffdbac997d7456c5732d2de3bb82e7900ddd18c5e39dede65a4c62f3e29e01db58ee0edbd1c014a2a5005ece34950317d27a2e897d752e135f23b1c37a67926efbd88165853502604f670aee70a506154295efc186446974fdb935a90cb5ce4237f3d86878fb9e6e760728b7803cc7f67adb02f4b63cfed3b23863189b3ee90f11619c448aec502b5afb0e5d5b9ec271b7e994208c75ef82be8a7845f8e916d954ec31f433e585e2fe717defaaa59a52d020bc5df7eb2b5041359ffb74ee7f1c689590c58c8b90e20582240ef0f04252faf26c41b53f8a6ae351cb12a6f6d1ceceed42d0d46edc0126a1bc93d6a87329c2bd17fff8cacd4911bd08c40bd59f1327ad375e524d9a90ee5603b7f451bb2c5bc9cd8f6a524ce928a3fa25e761c096c54043472544d434bcbfcccfc01d858d52acfcc75bf1840a01c606d5fbee0e2d93f70b25f28afb1da0c62b4edde54e2ee35a0f4a5b842830fef35dcbddb0e3cdc19d431deabed25bbf5b9aacbcfae0a27326557a4b217b81b049d2ab5e5f579558d99168983a97aac77224f16926cd5cf98941bf4b0d3a00d775f2f112c742f636fa16c0600363a947d7c104cb4a23d3d88d43f9d4eeb773cdfd2627dfebbce6d3a1ab4c08c9d7f61c2d7a1480eb9e5bff3a1e404779f11e9921f59dd69700d26f503a39920e105681bbafd0eed2fb1e97ddaaceab0b40e5ccd2e8e0bf67ffc08cb6fc7ce772bdda14c23fb183dc34d31e0316a2d9b94ff94752043da161d90acddd63f9e0b07dd122df6bbc2c9d9f21d72fae0e58f96e3bd0e893df1b84259232aac40437a6bbc322ede6b2f1240bb4e2e9f8c968ceb1cef21a0985c787c5c38db5e3de75c9dfa132fe1117ff0e75cd5611720afcb80647c0746934c5cbb6d7fb597c4b946f595756e1215c8cbae008537542b24a68cb2cfe2bbc415b6ac888cc85367f889d51bc58d7ad4041d65a4e942276372d2f7e97cb09b3b2b8485499feb107da8885fe9d97030616fcce2c25abebf54c7e81257cfe67fd17880953e687bd2d9bb3c1797a77bffc6ff4daf0c9ee5d0292c7dccbd68b499583ef5f86fe98148a13fba2423c8660742ae81ff2a007610c2996aaccaa6e496256f55307a7b67d64c888a8ea7a0fffcbe1be8c864442575497c76352f24289cb7b059e0778b80f446ec649f031d20a91474b8c9a37c4b5a7a4aa43704d8f19c8c8f5ab9b96685289d5766f7c2c03ef19ce87b5477884c7e86714fa66c40114cb5ed47cdf9a4055622bd142e283fc9aa67587f6e3292b718b06ee17c5fc7739dbb99dd49912b325f0713b62bc71640fe0a24f3381a5625fe660126751b4cb17d85b1e3dde5fb6fd052bb2ef67e5e2e53b6e4701a7659ba3bdcd8b31c320d86b85081be795c35228b3a30da4f56c5714a3fab36ac65e74e376206c59eb9e0cb62de226e8639efcef85200d20201d9099f82e29a973763ff64c6a46046f227a541c55cf623382c9ff6f9f0bc15041a2b3d210d9b5acb8ea5d67a7364c71b0eab7a40851ae1c9e5a2d198e26a4acd16b8581c9b85cc48d820f83941e0db0bfdb256cb87c90755556b40cb9755e09419bee5684f4b194cadc8ec8a9679bc2061caaef86e610e0152d3f394bc7248bfd35fc50d441eec8aea0740632f8c9433a905944c1c52472e3d7b053df7585df26695574995266b0a424ebd3f23f790593315989627e37231f8bc17a3061973933ae2680fe009faa616ca935c7ab0c5694d463d7963ebf194191b739690ef30f404907124f4cf0fe9d8993670eaac04c8ef7cc86199f4f9ae2dd3341967f43aac4875f9b5f1211db9c32aa3b2c40239aaae75515bb1b58cd82279b1dee9de55b8263c3b5a741804f051e57ccf8a004defcad99bb1b4d91d815a43e0e46a110768278eab6bb12fc727c9f764f31d293748ed8af8b41d3cf9b395da361f260215b0336efcb924cd610381e78f4774cc742285a7fa3b21c7a5dd6a5ea574e9bb25055f05e1260db89ba02974f63d70624c99a4436deb0a161b6b65306d65f6b75d7b90daf114e7982a92fe69923a82a85b4892e8f08549dc6fa653a1bfbb2ac731df109bdfda73837624148e8aaf0975055a73c14557e49cc64a5bc3b48ae125b97de2715fcf9dd6a8d8a100577ed6ade91e2752b66dda09c72da00a4ab448b40dbca7c26dbcaf111ec62e1205abdc5b6ac9fdd7d57eed8b900620675d3475785e109508414a5fd65d93d499e1932e84765f2835eff9dceff53a24f1b55761fa0f1abaaecae01ae3c57b253f906a5e4fb12b1b32c57ea024cb38a70dbbf3b87f7b4fb94f3ccbc10dac14aceb4ff2612a7a3c3005b0f612b35f26f42d5e34db112f8f9b965609de4f581c65136f44bd74db06f4db89413b16c264ce7f577bc6dc26da9c4a409e2bf6f56cc7a5d7eb7a474f60458f23032ce1410262685c3e5a7e59f5361ac0b7c3027570148512d6d230c86e2313e0a8632e68b8c87beb8280052f18911a25eac8256de9c4b804202651a199c6ade374d153efa9169ca124c8387fae090b4828bc90461dc263340a53dd2bdfd4aea167925430c5a733382674400ff3292d641e4c23bfad33cadce0e33437ada3fc641ae12fc516d2f488952d2062cd8af2fe84b4b0487a91106e73be2a1c580ada312e496f41b8d71d77908a269c7d54a09778a54f4f8c3dc15d27979773f60011b48d0724e2767f24499c5ca2835f0849c73eb85ad643a227dead40351d8c48799aa46a073c4b6f1905b87ca8457d889dfd10582d80ae625ccae33876a5469f27662e8a3cfce38ed5f18a2533f4578b3dbac2283b379af16bed3a5321d0cbb33fe93f8afef10709dac7b86a8ca9ee4ab040ecf38a516cd677169911fffc1d3726e24596f05ae471b6da2b811498dd46fbc3cd7661e467c01118f6bff8d63c9d797f465645625c4e97530e3b7638d32b68828186de6982a9d3c28896e1c557acea6aed4fcf3b473195a0b8eeadf0073436871d755b40f20a132337bd945f6962667d6a43d5e10ba48639165ff996e217cbafb59f667e98113bce9c93f27f2a1079d4f0c3088b042beb529ee0bda602950d8be50f84151200b83db878f4999551a69793e4a9ddc3cf2285ffbe0875ecaa246da7f6e5ccf1196958b68229ed0cd7a1a81290ebdf4d084e1b9908df084d7985e1784c599393560b59ec983063037555fc0862636b3d27761071a06d711df36d39c3e35aca4e36179c2246007b8133d73944baedbb1ebeb4195b387892d23a017dd88aa9ca5d43fea52be70fa91837e557f0db0cd527c483528d3094e4a2127a17004af2a416f618d220a9a466177d706bb366de284c0f1c2962d60b82ee74139ab1d6924c9e41a66a01193527864785b418f6c0f99f7fb61a5d6592a3de4f7777b9ddbb7d5c665f676943125ed3fe7106a7765b60bf0faccd0fbd9cbaeef07302216afaa7508b7571a276794d0142863373ce4bd5c6f214563bd96ca03dd2d96d919d9df5374a7b4365345f0dbd528489e9c1fe958dbb6dfde11965429b96a4880e4c67602e8f2b490c355e39095f6fd81d9266980fa03ef05bd5be99515c499d110c4e1c0bb8c17fade8821e9f00cd726bc9bc4063a850fc55086f40582927d94db18751913fb64fcbfda61ce1333cf89a06e1a4725f666cfc059c24f92c2e995e181b649edd39f68202337d9b86ebe0b080f0d45a8075618c5d98e4900c7a09160c9745a5635c37b2d8454a9cf433315e057961986388fbbc60ef1cdaa6120221abfddd0765b1f7611a48d8bbec05b25422c7147fca3e3d82415ecc6927342835a62d5c18278b44ef1dfb576c5219091009d0a203c6d60ed32b8b0db50ff12f1131bcedc51b6499d6090a95e9d664c2ad0c1e41772b2a668e565db1856c0edb7c3be000039526b850862e37fbf3c86dea0ef8af14e144f8afe880df830953af93aac83a7001c21c475d1ca42e93621a3fe1e3dc92135aab51c88b47789650b27759e30c958fcf40c0c84c96bd5eab3f0eab9e820dd5d98cdfd5cdb99901dcac5de04b343a53d8c7afe808489f505c2846062c66a32b08f8d47be20c4e26f33077228c7f09515a0c88a154ca764389207a8479fc596850a7f778671cb045f0dac37535f47a513c39f5cea532420700c4a3b012a2159f0c3e75a5fa3059503420510511ea8a4e6129e4310f7df7652c2910db337043c342a06d641fa72b1edd35bc40d21a3f1162c8a55327b0ccd710c7c96010a7f330f7aaaf07bf9c8065af533b42f9d4264cf333483e8a0fc44e451769620a7667e41211aa6eda590ab3115f734e80f81651e880beee50be4bd765c906934f7490a03e54f49c30b265a8d2821f271c8aac34add202f6a2e7939aacc4a5cfaf65222ecf4d314d0090d8503794b076298a7558c7bcfb52a12d28340b1a755bb1f193ee8931a65f6bfbd3a048053aba124cfc0df11db932c45e75709acd635839bb74ec6a2e44bd3104e072b1a40585ad19d1065d4d68aa5c204c56adeace9fc47c300ddb176a89c5c7e6afd05302571ac13cab0378d965fdfa31f44aebcf129855107998380a814411274c31410a072656961efb6e57aed680741afb94f0c127d8ceaa64cd880def9666700aee08bf8ad22637e1321230dc8ae158bd0fdb177378bd2a2e974892738867a195478ca9c7332ffe427490699b6b9324a7fba2b164f55636d1451f3147b33789ee23a729f40d1f02be245d3ff15ee296364c8aa47a4c7153dffcdf6a3f5880e0b3a5beb4eb9a7cb627e48fdf72440de01215a74a61a01be63662bf4cf83cffbb6a3bad067735b02ee67a535d751e1756a3c0c238c217622840ffc76675b3a7e02c828d817821d5cc74bb292201211813ddb7054d1d1a8d32ee8f90a2882315dcf078b5a446048392ed1e949763b08a618ed76a948b628bd2a8d72ffa3eeec2936aebc61dc6488630e12373611074d46e3824e2b0b1ad38111d76eb0bdbd7114f58f68b6cd761c4a2c353b7f49877252c11b6f1a7d8c82d706d5725da22c8b413a1c962472dda922efa1cd89a64a11989058ca6a104be08be4c9683332e7fb6469700229901c0c821e3b543461f922e75a5ae277c2badddbe614345696aa3f2152aeecdcff2a608d8d7390606ec9efd562e136c862eaf2e3bac5cae8eaae60cdde8c11cf716d386ebf0683807a153fb21267c6d7a142a0824e7935a54a49b2d8a048fbaf76db001125f032d807c5eae8efdcf43ebea7a664e2eb4c95a8788187115b5fca2beae9dbc1ea50890d4851f15208d24d5fd29210233e750f99194ffe5326a04eee6eebf49f4c72301380a3bda6b1e83412d7fa1cd0e0f04c976e48dcaef66f1b3b32980e4c593d7a3f0eaabf24eab992e17f83ea1030b712cb40380c70a1419c6099efc55fa47ab21249253708e8cddc9971c85b5773350dea5345280e4180ab9fa051d44b8ddb05669a99f9a22f37e434173a503a71cc2f36e590f1590766edf8eee3d4e8c049ca0983e0f84b7ffde998afe81d9f75ce1bf942d13ae5d70bf070a8bb60f3048cc79aa767011a1355ec7720e6c9ab152442248ac9302a2c26e09193fd614b5c6138dc864f86b671cedeaf610c651ab5028cb56eca7429757b58b2998ea8c1c9b9497675e0666cc5707e476a82d8e3432182cc96bc43ce868e24167e0a0b504678cab68cc5733f5e21478772edd8b50b3663b5ddaf9f851082df04df0c50b29fe26da57fddee467d6f6b7f171afe993a597f865f6eb1d7457e35896ef257a90b8bd122923fdc3d4f6f897cc9d0eec6fffd5df227c6603202cac3fbdf725c67bc7061ddb1c31d2f49b74ef8e9e4a312f325ad0aa52558b54faacb77adb123490514fa6b59c30a7d4541928ece7b8d7790adca7fb32007db58ae17b611ab5e070d82a597c47db79f3e4017c195edda65d7c23ee769651bd2f7b46f408b7a93abce94747007e3822e762e9aedf727a73b980de857b6645fc26834cfeeee493eab3dec2a477d788a86b71e6c6dfc788a74eb775aa88f6ab183f3730d9cd0783ee7563db8b1a6da0025dd03b0475884d40c25e64cbb9e7b28e1887936f35d4370a8a6f26de171633e6489927d70eee6b3adaa0d077f15b7892a851c2f35424c54d13b4b1b3f76d4a5b39bb4315cb1a11ef022a6b7f517f304b027be79b033f2b58762bf1d52bc2bc81434d19eddd9e9fd322bad88166ff089f006fc6273dece311157e54a40d3c7cd32c1301ff8274320332dc9c32dd1ad58e161e31d4018a05830f7c8eafc7ef0f11b0323c89157d1a5ac6d7b6832b52f66d9ad6ff4345b71fcf0696718eb697db732663e72151ef7aa5d66cadb65f8d21753fdf32a5969406962e73eb3e9f6fd4eb5d1e5fa458a0ab1fd19314d7462115dd5da2de8f1cc40e9f2ffb1798d7545b571feb0481a6be4bf51c34c8a15f6b4b0727ea233d8389dd27c199bdecb7b61d980a012343749c45682d0904cc2571689aed0edb45dfc249430372153d3b4799f6612fbb2a50da43a7a84082baa78c64c6d963eb508b9c007bf9081ec8402b9726159ee39a59f4fb05b787ba498a2c729a0798a085e6702db7e7f69bf49e77f03b939c454e706e5ab930bb4d484957f1085c911dc15721ff092f1ff8f740b874763f3615ba1bdc8b05e4b92cee524d4c7ed854fa2fb25dafafe1ad0c3fa11a5841bff6d4176d500b4b0d556ccac356d8ca837d0db3cad7f357cc1231e5de55ae1bfa408b6d98b882aeabc436cb8db3c74814404c1713f0a7a26a33c25e54f2245ecdba09f86b75e01a5fce01dcb4432ebfeb9d62faaa79ce5296d6666f00d81f2e5f6761edb571ece649842aeeae9d8d8492dbcd4a4b3c0850b9201ea94b234fe34d05e7fd2364d7c09b6679f9bc55ec53141176d0bc9a233464eae40adadc574ca08f9b74cc816b39214851c76ece593de965861eefab6c36366b0ba5fa6471994384855f24466d75453485c553ec1a0a452ed8b5c22e0bf7ca45fe774218baee68632b403873a281ed9be3e7548ebc76d3e8636cd3b40c08f6fdd835c69d0a31d484ad263188a2b3b18163e97ece4e541e5e7038dee0dabf19ac889c7e7daf6fd38338dca2981648ba9b5c043ae601aae740efc353f68b6c4466d4201391d82cbd385b64af5cc7928e4bfb81031e56aa8569bb1579077e6c8c144f3fabe6b9b7cc0d1ba468a6e7e1e48767facb7a2aee7f3f038dfea5d39fa6a17d5a7605a04ec23ea43fc158ef28c2f95df6a308a2d43667ea672ae4863dc03cefbf234fba4aaed962d6c513b1bc4ed0dae764eb16b1b67fb77f34d97afaf46349c905f285ec202670d2889403d5f6147975d18266274534291a50c2a20b89d852ce1f4a0b2380e36786d620fb641e2e30222efe13786a18cf1df2d5f59cf1f57a31d804c70ca95e45dc03e4b51bfcb38d303d8e110217e1e5539044c75908bc8b80ec163d02e7c33bd7c006855f0bbefd8ceb2f6fc8921ab0ec4605dffe2edfa6bfae0e8f5da12abf5b7e463ba7f1959603969b6634d8de69e286528ca51f4078ce5b07bacc54ae2c7f21017003787efdcbd8ccf70c2603cae677912264d60252275f398ad7e1b1c3c86bb96a39547be3822388e42b965ea5975f98c78272f35017f4ba6ab0702fde84c2e58878a947293a5d8e3aaa377835f6bd82ca1073f96722391f9df7f6841986bdb9dbeab9a3f7ce76ddb1f340070a0e9f1981e0898b7e6adb99f6a06585ca0cbe63461f03dd9b5de8434c50a349ddd8ac6271740635072c6affc82f00df25d73007bf0b9288a43d91139f8c1d93cd900845e235acfc7f521d0785a4313cdbe7a228e4bf05a7db0434ec98c944fefae240eea289b9d1c8db4bee17efbcc6a931fba83889d9682663ccccedf8c42d6f159b80a1f49ea447db002df4039c5d14599e4e5e50839c5b0e9ef736ef9a546538af744879d6a09f3ac0f9db915c49904ed3b52880c33359acc5c8d0e46f961a0c464c6c29662f5634a36601ac9fd5c5bb03e88ce295627154e8d06a2094f251908501c7074a8e2ddb7618b6af6733eb04449b3be1058ece9416c296639c495e77ea56c1e9b2f035da7d55533701b7c239d2e31b90d9447e332e0319f077e6a05d7f7e3f2d3379768f374fb8c687cc75ccc6cb7ae3c2add455899ed9192dd36b65c07d150094766f2fa6c196c85eb1525e2d13f7e231288cefcc1fdaf1607194d382f635d52ce27c5f832d818f27be639866c58801eeeb522253d332d78eaf26cb5025cae3f2ccd1dcd33cf45e289ec0b1c1383533e0f6c46ea445bd0ebbb3035fc7f3b738c3356ac93ae3dd63c40cc25cf1d12517703e3f2a6351b8231ac17c25c522d028285967e22c01722814bae414015c7a91b0d2e6343040efcf28feb26ebf594f28bb3667f8d9987fea95675db8a86b7be70295986cbec94360585d0459022fcda126e7e719d748eed7af624de69d10f87430d68e80bd801e51b72fee3f255b013f495d7b4666b1d8de4af42a4eb52c35474d82ac9b1e6ae1227f62fe735fdf653c01e69eccf12ce202630625c27b5dab9790b78725a20b2b5158c5a3df8e0722a8bb3aeee2a249a9764526e814f535789ee064a5f69d8b4866778cc8d2425120893445dd3cb5461410ad46f16f3e81dd1c616e86e0162d7c833ff8954f97146de83a8d12824ff149653cd713d30ce1a13b3906b7c24516e1be5326787fba6ff3290c205ffc3574429bef57e95fac7865b2e5d9f87b995670b68ae978c6938769d3b1cfd0f923d9a5ced7fa13728ae5950cb43b985f5362f397758b0b70e58ddbdbfa4c6e9d35aebf905f9d2ae4816314f9818d215a71f8406ee05d0d3e6c6d79118ef076ebdee5d8a288e1b6fdb0bac5d458037273de6d473c9828647199cd5cad72d69a8d91cdc63c98cc3bbe894a95c3fc7109ae0197da32a9818eef838930ced837da913f6baa99b288c94537d88fe4503710d8e4dd8e32bf637966d1ed6081b0f5c2627724be012dea3f9753a3288b83b1eb420959e393017b719f68378c1dff2ba73b1d4f5bee3a27ba11034bd058d93bcb6f1237414e49332d0e812eb73996d9b6ea1a6edc787be76cca58d2fbc048126d7ea8d815483788a18775e0487ce38359012fabb566545d2ba2d1e632422889d65caa78dfc585a6e9f3b2aa32839a7a89681d9a37f6101fbf85b4d26b32a2cce7816c3f1f69cb65e965c9131ccbcff99318d1a7f5c0274d08c23e15b088818165012aa273043e3e4e127d16d3b237b7237b4fc344a616eb7c7361c8a9407286c2849c487ade8de4d18610449f430216fcf55b242d555903e9ed0f6c7f0f94e87b1e78d4a7c8f41c80b6f9b81fbb5752d798e20114ed614b9732cf98cb954d67636f87259e4ec6641caf1eaa670d6bdb70f3c77c44fa2968f4df69c3f2d407d016feec027b2127db8e1154b0401dcae67a062aa33b2cb53bc25f1c8f3edc329e73186b299853389b57b4615b8623ef4fe1a051b501ce40d0e84bf2a92698cd5cb2f29c22be0fa96af184261224227131c9823d6920e9fe5679ed8e3e6d260dac53e4bd95a619c1b00c4b0a17148d8345cabaa23a9c2ca02439e2e7e71f14a217dd887046d979181c09f636df40365a7595aa3ad0ea2874886b215f694a329ce6cdc6e5caf8211d9e5abc29a0623ae688ebcc9d140a2c344e3785a9c61a47f1674930793534718a694828c1784de8539f68c73323ed3987e33517b235039c634e3ca97b129b3fbbf65f47403a8a046027e80fb1e5ce5d517a4e58498e93a9227cc17e26863c7e39760b24514dbada10a409a134693124f9c0616f3205ff9ffd7b98578438128bef149d65dc525c4d0948bfe1f7f92468b4463806955c52e513bcc904e8754c3387170c62e0acad30dbd355c2be1b0fd071e6f5fbfc88a42ed937ba8b67b9e5608987706900b07cf0978999471b4a8fa3e82e823bacf3c0c4a4363d2b19b371cfc92a79495f7c6996d6007dac88a47325265384bf8fda4f5c0f7fe07f10622dd3427230d74f659f31db2f4e71a0c040ff6fd90d7b605da20d66321b4ca70c48c2757452cabd838453ec3779a311e5b8df5d015ca9e667d9f9e03cc969bd4bc2e2b5d83d9db6dc4a5024795bdd905e61c39b6ef2026024ef05af132609a04063d4dd37188abff3614e086c0e219eb1c5b920c3242582c8212624dfaa940a1c0823acea250929559dc4667e6164603b050eb42cdde0de519724a1f153a3b1840d56cb51312bc713ae247351aafd4ba94a6d6e90412bb2c565b090acdb1e9b74c8a9acf5d01594ba9fdc29d9531f4e984a7d38c6a09bcfbcc1ba01bc0168c862c38ada62a2ac57500668457e432d48bcedf5d2dc636dc8f8b48e1f74dfa29c3c2d7cbc41149ff765455a790816ae7fbed98711c0f60bf8894e45b730f81f7d2a05eb270b218e622ab3e1200ae4154e4ce637bcfaa0d39c2b15bd82bb2d73c36e97b52178bee9a08c41df21f542859b255ea3c176df4ac7ee7e0a86ccdee12dad64a9c734f93a5245078e9de14a67be22e6cdd0364624ecb2f350c9ed87c2de128dbbb2e3e2ec4a3e77b2b6c4a8014c9330dad0b38107bdda577a6b35b464d88f55f42b7870e05b560c241677f58cb8488fa4050fae6e7a78de39a137421ce69c96853dc33a0a18308e2346af9758a2e0f896c44a6bbc293e72b7ecc64c2122452e600677ffdaf03efd46545da2ebddbe12601e589d3a08eecde0dd2650cbfd4e0263705ddad03df23bf3ae2b5e7a14ff349046f979f65a370ddfe80d9e5b3ed459862d0d67e7100c58c5ced3713c5c1c333b520ba91f4cd29577bb985893182afdc56057bfb62bacf454c5b1e1c1465de68228639d3b00feebfd87e8524e25feb38cfd2ea0d011602b8e06bc141d1897e5bdf82434251f40f25b73decee79420d61ca885de5017392b511f72399f7dc4bfbd6e38be1ccd33cf65043ca76cc2bc329ac0de9859ac3fe2c5f69210e4de90bf24b884f173428e9da9ce0ef623cceb0cdfeff5d87b6a52890664972715cd03e0d565659e26cd49ef0821e1d1a9deacfe9155a9285ef5633e0446e2c9e9ae0c17fc84689871d0521d6f96049d0025fb4e481fae040e035318963c2a5fd3a775ab7d40ab8b59f0eab06085ff51e2beaafcdbd72ce14ff452c2685ae13105c8c37757f804a06087e315fad5550d6f3094ba01be9aa312f415da415414128bb3571e752e7fb337a4fa81c796b523ec138207e5938111a5a666a6db3c2ceafecbc113b8e3f83b1ef2ceba88ff77fd958d16f144e236b9e67dc6e0b0245f73c306689efd2e13b11ba35e761d9e166afcb7860086563408f9572badac8ad34ef8297727b41a9e6b66933b2e91974fe25885099a14d1904729a76010505f1b574a90a019f76932e0ce4cdff19561bf23cb92939105ee56f36f96261e2810703a1841a7428529b51d59322eeaa6318cef465f3098a55884252597a3750fd1d09249f1fc6510cc1bb685fe9040a7126ffa376c11a19095440ff73c930c3870289abc183904e71121262425578cf3146ebfebd95fbba6dbd8c8ae77940701718560637988ba2578f348d50509f73123f16b71baa904149a1b798a4aa0f42e97389d5d32fa9bb495e41b7f4c70939dcab26a46f157976fc1c5cdb6e7b73bf336032462ce87e2833477e694a1ee6ee0a7349fcb400788200e69db49f3eeb8cc8ba2fbe8bd6c75fb746f4665276483cc03e4c4eb6f651e6f4c1ee31228f442a174c73e70673b99b5d47a66c69544ac032375ec73bf81b981a2e4e4a240e215812634af6a3a80590cc08f0742614779565a13b21869768277f6ca0d44268cdd8aeb85d97906f5f2a3756ac6ed3ab258e4a458d597340873b5d936fb2c2a0c74b415e209d0e26497229e696f36b2987f4141aadf98e3b422dd46e394e776edcda4ff288bf854172271d77b2512703657e0206de62b2fc12e7e74872b80d654f4db79a8f0ab9841a6730c25a3c0d49b4b6530497a546c05a26facd8ebf22bbdc72cce9b3d3d3bdec3bc5f933ceb02f0ce9f6e1a845972a0a77b09760d32a94dea9f9742bf72c9239ddbeac538a84075d1c2cc4ad22e67e1253ad59be4f871e1e73bc0dcaa7a972612362fed25a4bcc50c1e95fc1e3e2469e60ca9c18a8cd366f2e8659aacc5906a47ee6ff68b4d031cb848f042ec67334190138a493389e7b3e1ac337a89ce5e0dd118f6556207196f7fc2e8b7c85db7ba3481eda712110028ced3fcc0d519e8386d07c3557dd7f36f5666cb50f22e794ddf337f9e4781c397ed4c85b70a2816117b6e10ef0c6ad711e5661fb5508a12a025fc618cd7497ced0f4637520203f38e7c2477d26685741d80ed1d20413fdd12f3aac0a69af2dfbf0042b1ec8c4d93275c979ad5c3699b1d161da42679cca23fe96a37c073a5495dc3cd1e30605af86c0c461adbe7655984951ef78312390c371b0f8018378a102dfdcdddb9f9a170c945aa52f04166f15976a3df24cb7946a4bbb06534cdd0e25f7f701e38bd9ca7f6c0df8d681acfc4e6dc9bf3eed1c8aa63f4bd435583d2483c2e162b6dcd533c2a573c4154e855641a9c1d44487691564e5745f8e422e936e0750c5b068c6aaa9bf8c706220528ecff00c9ff348b5128c38fd26f68ff7dd44ced1856b15993b0c580fdb9337f43098b8c00a95c48ca886a7652ffa92f4ec3f8e9cfb876ae12309f22cbc134cd6b4be26ff111882e1dfd94c2d0a5a5343a869aac6fac3e71ecd8377c508f0c4f59a9c868ba91207d806506652a1571e702582e6cad001d5860189e47a281dda4f644ce39ba7fb5acfb1578e3bfb51513999ad7e340f71d1981477c293b74e545ca50f8af848a750cb72505e6c895e628635553c6969755d6b4c5f20f561e04e847e544d4ef7108085989cdbc89c98e915988fa2945bea622f1d4d2927f05eecd721ed142a3573adef553dca851432fa827ebc83ec684135573b1354a71f590fe63805f244e637b4ff4311f7a4057976f32ff11cf8d41c632b907b6244357f7cd7df63eaf89651bee178afdb60cb1d1554bd0158517f22457e8603388a2a6ed5c941a8594a8546e91435f1267ba1311fe8b52bb5fb7688c3bdf0975d94328c54f2b0b024b319b918af9b09614ff80dd3499300a280dea9bf4a2ad1845f15a293ae86cecaf7ac3c46843d690fa0fb00e6ce3f38320257703c9f3eb1456e92dc1dfb3d73d874d5060f3e1e25482bccd50303393fc2e9265bf24e0bc45434fe706f7b2e10bcbb61ffb99de939adcbcd67d90ccdb5ad7705d5c615623eca11a9cae3c9001f02b8191887d41d7d21f28621225668364ac811a6938d4218c1f819c9598aad4af4ea44e158471a80d375dd3861aa4f20f5fce043da6392bf817540195aed66a0f234c7dcb847784104dad73c67c6b3230f2ea5972bf86ee16260cbb220f115efb5bceed396bc663b","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"07c5b14ebde706c56788d0b61561bf35"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
