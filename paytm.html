<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #1E242A;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #1E242A;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #F9FAFB;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"60134a0bbb4aae83aec12f97e3f89fc8605cd4ec10484b804534c72d47e7b02784d357eb8670f3171278799c3c10ba763c926ce75eeed0efcb58c3625c5aed74fb573b0ffd24dabe254e9ac517dbafbb1460d294dc7da80cabd091f8df20501f9dee8807b1b34ac40eaae95c1904c591223835fbe0c87c5e39845a6912806dfd83267c98bed21e0910aed16ff1383b94c2f75df946c91f481ca1baf944e09e50847fbf3671a0beb23a4f63a0fe9f44e3d90ff1c3b9c92cc8831eeecac579e30de27ae6b8922816c0fa2f074933689f1ff6a4f1ed456b1e414edfefebae911fd893598110c0a35ace2a8a6275f6a89c969d6a49d0b24d37833bce637954285abd3f174ca0b9a7dc65749061e192612233784810514c3a798f5635f806d7c15416477fe4fe22fcc092377c7e432ee5d434c1486c8e4388fcac1145dad1f8175a06b8d210ef2e70229948708266a9824c1b235c86800a4f6276a51e963e50dff9e1a9f3c7a9b4311586fdb1429424e577c4e1d9d1540045ae08b71ba2d1329f72eaee40d795c40dfcbe6e9f34a1298590007edf4539d7c762972cf125ef7400eaf39f88271e14a593c4b5fb2659b677e57ab83646f8fe529b5b896a58b13a38e06ba33a935bf887930a70f704f1580fa57468bfd46c33f2af3d15485a6cb5b1e01d8624b914cb5bf13cc057f6d1e751b02149a3172afcc1197a502ac59ec1132c96e269fc496ec1b78a29bd2994a4e849620c31b5ba6a2f7eb3d0604dd43a575b3fe1750ac5a4197bbd70aa47c25c83ecc2314945c4743028c0c1bbac91e3ee35cda8a54284ab358cc73f876aa2d7623cf5d1d9026ca00a1b5c8d13d6545699b75af5507cfbe34bf8005f73736fd64312ce0b1e14918d3f37e75830f1f5c80ec23d2322eeb0cc538a5b4ba3285f5dbd6d92f22922f3cc516478f374fe486b5c3f572474893c1918c241801ba6e1babb745270b96c49bfea76934e6468e17cb19bf0847e0c69a23c6b54eb9d27b6acba46e2cc9398bf3267a7a13767a73e935e2297a605f189b9c6b7ae03ecd60d231f7eed42a2cdd25cffc39f70de3c655e1c77c0e96595a060de0f920f3661cce03b6aead2f83d65a80dd581b1ce56150a0c31c66e1ccca6b55d1bde4a3e9ecdf152c2efe42920437b612e1d36d143299bb64767c106fc500e624b39adbb68797d16230f6cf084be16bd1fc2b7a838ca6d4fa96dfc60c4a5a3998bac0d28a1af7417215d95cdd5482e8317b358d91f95b9ddd7e2edb57312a50640a5b87ac180c1ea5da3d51107010342eab0c12fe2217c8d3264f6a8492877b7b771661a2589f99f29d24169b40615aef84f8ddbc2e030a413f2cb77394d1c31cbf38baf5d3d98b307a86c02d867b2a56f0da18c4e04fd6c3512340dffd7a224444862491f3c2ef8388f741f49be6e3cf2870170c58da9a205264497033c8970fb04f2452a17dfdf0f450ebdda601dd7f317506a082504c14709e9dac1f467181beff8961452e4f8de67dab599639aeb6d456e9891dc8c0e1b9cb448f5f341e9a285e22339991ae494bc87f97a245de22d511116a1b62bdf44cf632041bc52fe8117d017145736126918900cdf855f1c11961163b724d85f7b03f0b7f273a2f9e76c688e832ccbbd8d57f0ff8d1b6b8f6a91fa43483a058d0b20e71a33bdd6c73f3ab04bf4ad212ceffdba0c06ebf4adb0a6a99fb46c60590373e78d2db42c9cb09904dc58d396797f55e316aee307da0f153544e3338db976236c30355bc0981ff9dff054bdadc889c66252c96810e8702cfbfe2020a16a73999ebcb316fa8b245703f15c092c620baa9b2bdf2e98434624001854e4d6d9cdf48c36b313d9a6b5893935bdf3b992127012f2c003bf3216080061a5998323b2e37e0a5796f87fe27d92706ea4928c92020ca487b12b3c6e8e61823c222baec5ccefba6b0ef0efc2fc988fe45e11b35a731e876159bf6c60b25440ef332b0cd4fbd9cd4754e1fb495f71da59b272fed5461b565bc1f70f9319feee62b25c66bd2181a4f086631479ca99977d4e9e2f57acd720125f3e7fffcef120521d29bd4fb05253291579348a6126d92976074c9f0cf53812b16e94a55900e9f005bbc295fbcd31df9fb113a0b0869f7953283b5214e3c7349a06c25ed5e728b1ce8ae3f0d976f06af87470961c65635db2d3cd71452dd2190a4c67c1707c7ce577c3279ff62cfd845b8d5658acac2c1f3e6acc3b390328dab7acdcaa0b67e4c14d735ac224314fbb920c5ffce5c0f2d3f3ecfad49b9649ea94054a2ef2ceacb15e7237f296b283c613dac03922559b69b0beb63eb3acdb938e082e21ea54d1911395a2d56168480c7ae0c1ffe9ea5da2ab95a61278f9af3d5eb96cd0d0b6c93e6911a92e75f2fa070fd657adaa090ece7bd54c7d1899c693df297b8b597d92a90847fd74f3c741ec73f4f8ef2a9197d11defcd1a0ab2d684ee934897381bca5113589cbe11774c26755d41c4114902de908fd3b618ec69c19d9e3cf3ca08d92dca1c8a82cf01e1a7d4ff1cdc8beef40d0f93d404c0d20b0daa0c60c2bfb52ccac943e0ef5039eae8b935d886dbcbe550c4c1de2961bb757017b734ea327b855ab6353b4e32bf9194a953ac4b0a125354213a6c05dd20b5ae2d0e05f3d744757568e7263a06e0eb9c6d4151769f1eb247086713a0d6f9b66651752b8ac12f455582a485816827563b8247e960f0debce2b398a3d327e128f35ebdda46c5896f094881b33ba069c61a7a7c0f742eb50a9299c13133f4715727f4a73b7e93457ec230ea250f3f441a5257a1a6af8720079910c13879aa48697ef7f0e3b716ee6ee11e9f17a58e8a9b7a452532354b1fd2bd0427776f8cb9e60471f62fadb69f2d3a5ed18539b26b9af16590ab628d028ffcfc6328a73a17c82e0c35383ca7117daaefc37d79660dc21e74f79e5c950a62938b7d27dc1b7ee961caece72980c1fb99978c8b95a99cf9d2bf9a0edea31b2ade347b1287bb2c4f0f3d2b158f054797b859a3d97b680a0fcfc74651574dd8b5948c8011e8a48b7ad3ce01522c5a934f71bd72919f037b05b382f0619f6ecfe69b0b6be094f26477ddc54868908f96b4273a701351857e11bba4c380d4a8401a20ae06c157bb25bde55389757555e21bffc75ff3f75f5dd5c138e5ee8e39a98b4739e238bd19a1ebc4f50ec3b56f417cd7a8bb91eb6eacf7fd7a49b7a6d052b3a2fe062607dde9822c41a788e8caebf65371a4d43f1f628d422d07064572bcb0099558d0da1f35f32c29bac928511778c3b0be3aca41176e9073f6571004e41c152f55c5c113adb9306a630319b4b139f9b103302a6306122480cf6698c0c600715d5686ae05d4f1bea30751c6a3461946d811734e2e9546292d02e4fab751104b164a8dabb1ac6cd5c06f3337d96154762a172627a24b750d0a1121eb67a0aaa05fddb0a5da4c21111dad447ba9b8af82d200ea8ee4698a984387f7aa618efb1674ff47fef3aa297cfea6229a1098777e8a2aa19d5ef6be64cd78405aa4ee355645541a70e6118a4724244569f9ff1513274e138d79cc19377126bc2f70a097a26fe4dde58e6b00bc600c5aa2d23edc6533f8b66f4dad3c45673aff3830743c2473b4e13a0b59ca9fa8da74a2935f2b4af8fdf9e764e1186cb61abab8244d6f8320cc84775e68af876536e3301b0da49a5bb4dca2d4cb6cee625109272e47b66f2a9ab21b415eafdfbf94593b001f39d2f8a2357244ca72ff1bf57894a76e4fe71e62736c9054b5a461234feb4c8063654daf1f06f1db95434f5936e39a7b2976f82e68806dec0b7fec144aad0edeab4ed42be7c7e82bfc6b8dabd6c1c561efd268ec7ebeba3ef83bae49ce62ae865df6dc51eb6e8905b1d9e68fb38a8a38cf21d04b66cdaa2543f5f9e1231f8ea5ae276890204ae1c1f390cad7c3aa18ea4738300b8b6bcb8ee78ed491cc41f8ed8116a005db0759bce70ec5ef6835544a573c3e3e91e8ba305cebf8e2e1ca0df0e77c656be18459fce66b976bb17fd80f518e37be723d0169900374c6d5c9c8c52f0d05d8fc5bc47981c9f14a041c59be553b30c58a5d44525a3323ba1840be359509cc61ebe3274482c4b64eea22e7d59a35b722285d7057bdce1ad5fac0097fcc906a565ed37793db2bee5ebab1309c43229d37e31c8dec9be6fe10bdb28e00f87d4ef535bf50ac20bc1fbb1a1eef195605894ecd68f404b8a7ec3e1c671f45a213eed4197bdbd3a25019a9c41eba2ce6a268ff1a7c45be17a64eee011f6bea8fbcb4275af5ec8bbeec135aec4e09bca0ce75a3dd26d22216d8d674444accb0558d5bcb43a8f58a9979215b1a1d5eaf36771e1366195bcc3f0ecd8853b5763f7624a1c8a9f30d9d193b13944327c58966b2e0d20cc11c7061a1d0bcf4c55e943ab60603c1ee3cf6ba9296dc0b7a1aa2c7cebbbf56c888f2849bb4a80ee3e15ec001ac0382ab83c40a04ab32cb706294e045de8c897b36d8b1402c5ce89402a5648d1f9e3f5645a6246402502cca4ae7677e5a8a0eead1597f09be11132afb4eef24c12f70b2dcde1ed6b9cb63b473839eeb6fdf7e6f33ae7ea866a527703ed434d458117f0eb71e08c3cf1dd768cca55edf87168777a70064cf0b356cc1c32126cf0cf355a25fee364e2a4720f0fd7486ba26a0d9b88203ef225e502d8a67a7a7fa728389f8ef4698d52fef70f940cbcbca71b480f4f0af1578b36077833408278976fd10b7ade0d5c7a4f29942668924757f14e6b91f05a59351d9d5ecf7cc6c211adff7d4c630eb95a7c9cf15181532a9ac674be4e4d0c675c2dd62929e8beade712b1983e5a9c164566e0a915f35e921b93433f84f68c691d9378b5a1b380075600aa23458135a3caa69e1e6450d8a8de7e4fb70747289f16666e1b1ae58fee5cdeaeacffd7c7ade250db2a82607360c4938338dde3d2da323b6d78a3b17cb01e955aeec7bde2a255f8326dd159ec0ed4eabca012c871dbf01caa29414d2a5f4458f93f2d8d6d03acf5232c0af537267bd42f2ed45a05a33a1faca892bb7673c2cac270898683515a34f174a75b9f2b8bb51f979c7a4523247d82a15ca90c0bde3fe293000ec8ea893d4d4a1d0d7bec9266993bec748d71b9a8d26522e7b3b9e90a814658dfa20975aac84b2b1271449719c7e17906bb4cb7c74b58118530bfd81b83981cb5d4e72395f22b284f7cb41c7761ea75339c9621092163f95fe7bab3a525802051b5b8663444cb1c420bd1aeafe58294b6129c803cd24fac6a811e40a96451df73e3dff2b69ee5d6c4007b11ffe10684dc6191752851f2732da7f45d661c38bc4a0e7af3bf2bab95183dd404674e3b68e333553761add532dfa5860a278cc099f423a790a1a0c053e77baaed826ccc8f380f2707e9ce66aa5216d886fa13394001e7624b6aed876c176f58822435ba70bbd0de99c0e5dbdc4375094f7a13ad10c6bb31903ffad667c0716f5809d7f6c77a0f9c404181f1580be64301d1e005ca5ffe025d172faace38b66d78bec2f928b20fc1e21e206aace51d0a4a502e9f550ac4c0b470871a6580074b4c12308709830224f88ecf18f7fec6070716a7c051f84f64b21b8708d4a55ca5ce09b32e073bafaf9404f124fd9222599d82360b053374ed844e56e414d570f5254f78fe1dd4ddee89c6c5270ce28662563909d2765dc768918d9e8f48762637f23294a0e115536f8633b62e61b93355e3f69c575734a5a3c1705ebe9c8cf649c2b2c5628080179d22e84456201d36d3a9d76f0073897391dd08ba7a3ae6c4916f65a5aac730a85e8cb36e4c35a4d49da54579a741a2264fcdc74e5633649b9f68807b07bcd62ce64aa62523c038da91738c8095a9ac86e5855e10d34ab34a7c77355fb4b25b1ef105ab5c68c729620e4ca750eb5bc0418ebeaa01a13df9c5d21b7345de31fcdbb72735bd229d0776e7419c8a789b3bdacf730ec41f160e6eb30392eb995d3e9791bca85d1c4bcb716ff315f7f520c2c86c2d0d5e151864b0e8bf7ae871e627044f7181ecb7713bfcd41fd26cef1d79bf066d7522e01af5039fcbf8dac50d27f8f13d8d963e41eb9fbdd4d79612f61cec6b788c68c437964367810601f80f11c187f9bc84bd80c0475a59f03fbfe4c3a947f13c4af630732608bdb703fdf8fb4590c6313ef8a97b1fe59247271f8ab5005ff05451180837a84a02356c9d2112b2856355865c9f9eb774c50e3887a5d651d7c723363ee6f6990b08fa5d79ff4d44d7b3c8138ccbde307ddacaca5e62e9f6670cee13e077c2aeaae482f6401a1c1b046242b4c5daae0a66ac62d6eb1a8d1bd088252825db73c55ed0b55456053e8ee27aa732ec74566583d0c5e3785629d03338ed27bb375fc1f9e58b40e7e18e88b323a0c24656fca34480248f847b81f3dc1f3913481932f5be710bde8103a1e42369a0bdbf932098c7851995f12f2953fed95b992d00fc16bd372bff676bf03d9af967f276b63f2887fe70739f38e3b36fd2e0e340714233c9b4c8aba7aa82852382e133ddc4dd022a543fb46720ade12d887f551e5937403b443a9b0cbfd4ed97f424e2e93501f44312a6298599e4f276399e0e868b281f588190a3ef192e39cf51bc785e9958eebddd5bc151206f5b6156286a2c973b6b48a1814e7988a3adf11f75436435566244e73fa338cdba1d5664dd58836ed78507e756d20e721344404eb071b768906ea5e3eb97c4c0f703405121f0e872e7a3542f8a9cf7d09d5e3cad351c52dc970443d24d64805b9e4f132693d9bb327858286a4b4913ac99b284e74b1b767a25a82ede952d98d05f2b8c096a8fb682e80163af86c09a36d860f5b4644393d78d587ee87cd967015c22ed718be5a8c4debbc915baba137746dc83492b41351046e6c11a8280bacf16e56d3e496fbf3fe7b9d1ec23167d2e46a9afac1828d7186e81c20f615b4123db6bab054fdd9d7b753e895300da6ed4b3c3614241ffe74c27cfa06d4272ea551d46157fe8e1a32edddaca790889e0b092d20ecf7caaa8734f9fd74db4fb56395548a01b7401b97b7e864e4b78971f4afbf700ddfcc025858bd84c0616dbf632ca8d000faa5b0cef4327077c483aeb870033b2e954b126898c2bf642d108bc959199ce9360964d3c29fa7952ee1f86696c1e438a8394215ee76f4d027930cd93efd5d1797cd20e0f1541723c169de1623e36ffb1aee28cf48f2084752c7685f20fc81389693fd91742a6967ac1e7cf333e01df0a2326d99c1fa417180ff550b24d50caa319e3a98abf2efa68530ef2a465eebe420ad674cfe7aea1056fd50ce06826cb6d872a925783a13ce2e25242878ff7cf4747fbde173a7c722ffb69408f26452b8bd0917c1911ef38d3e4205c3eb3daf49d9cf80676b60434a33ee94cf92e61f8346c89cd2b9cd03193942c0d32250031affd75c902681c73af6af1e3ad4e6a18dd8da8deafa866806622dc5b7d26def8afd9291b2b00315ea3f71be65a6409ac3fb4bed475da0c7559dcd69ab25082772f3f2185f7e15c9989d52c7905db27cabc5bd6978f89503c2541476d137a1a74b5798156a21f4cf4360fa398706f0fcf6d1f9b82036f1ae60dbd673ca0ce057673915204a63c81ca9f0f440a2aceba71e1de7e271ad06229efabbb633833bb0e27fa5d78804b9a48a0d3373ce39da62e4ddc9acb1e51d9ee499f61d09a6cd119b49db3ef39179046f90d60d347a8ed15e65bafc8b6fd22493d1f01c88a49b2ee6425bdf943a8ecfa8d1275742179a1a48687bcbf95857c5f1e244224049348d91bac0551c1f1f34ca24e07f07d2066075543a765c0ad8efd3726110e93f4fdaa7846c49b1e2a74af9bcb8779b6987546c295fc8a28caffdd0620fb0461c42f205852de0aef3292062245d54d6a98174829ce3036dcb16398253f04e12a750a4ab8059a2e6fa9113154988cdd499c77e7bf7e730edaedf2872a65c77d231908be41ec158c0d848527ca4890201e57ed06e24f70cc8f6b447aefa39222f77c3a509b10eb4a7e2276cf52aee942497ec525ac3f2a05d8366af2ea7dcb06202e25f6512e09f9f519ec702dba9e0fc431a802196f359e9f8d694cc2156eb12b2e689cbad6145de681dcb189acd0bc86cc7fb4ebd36e2fa21d064b6cd464e1de062cada6b70bd1e51de7cd0a7e3f9e25931e70427b5141e51eeb4d9a7310b21db92cb8ef3d3c55b2b2354868666593ddf4ab664111ea4717f18116df421666c76bc489af67517910accb127d6e5f8b6aa2a6aa41dd7ae06da21471fd90a048302577ebb318861af6a9899dfbee99ca74ca26dc15bfaaf9547f83328bfac40b9347f4d8a135178c51222f84c273f1d77f9dcf55d7e7c39339ee7cd231c311edabb2c854c3ffd67e0e9fa5a5c0052186967a64ac44eaf7d358311a4b05d93e82138bafa71d35c5118578f130917b43b575070748e993e8b13b6292f6b76ae8b0dd64a4c96d836c6b54fee0bcd6956c0d81634a50ef090941820878a444757208bbc1df30755cf81c0b6763bb30e864a963083f6c31d7b82dd0a45c56da94936c05191a997e30b831f376730e729307a94f299fec874bc9403b572944abb8697c47464a97f7ae66a3fe7ef29d5031125813484106e9a47e27f1501f5caadbd536cd1ecbffb48bfd47b5a3c7ad1cd69a9e46effdafd6e66e168ba0aa61d9b238e1bb912058d41daed529965fcb0caac355da465e0530b565c92520ba8d3d483976f2132819f9c34fec8d129c4fe562b8be0aa1381cfb2e7684c6ac07a637efd974def067c8a2c3c00817ca00d9139a1855ace7ae248e787d52b31629a1f5c151560add82e0d18f4c2141ab35265de556dc9fc2549f4e7f1a3accc638098e0f1139e29a3470fadc1dc05d6240eed56abe85bef0870492312d752d27a13644b8955829b53959d41b92d3311f841fe329e4fdd0f3ea440ee6f3c8c26556239ecb06dcf32382f31ae6878619f1e22572f3631b4e20fec649b9b584609bbfacd8ed0dba324c16e4c9255be6f73f2d056b0e49ee29d114589f93244213e68f097f4bbd243f4f17ebe6721aa5c1061a03d0f1d2ccda4c999dabf10d889cbaa3d5851a836611e75e49e3743faefe9766b26a9223b928e7a6e15f6640d89ee137755032dc4ebeed1e63b8fef2a2d51f8de8874b45ccaac96576fbc95d07a76abb7d53eb2bf7d8c433f1b333895756fa12ccd570b2f90bbd91ca9fc2edad800860640e512a04f641d96f3251993d6d67b44a9e2870750d231f3d641b1751d222793a38dd1c570eb4883d9a6ddb3e68e9f7e3c3dccbc80cc406587b37f7571251c5818a84ad80b673a7c05a5041f3c42ca18db9489c881dcbdfcd775ed90f4ff8d7c8a24f1bbf07d41699ce46ad89d60540a622d9719396d845fbe2c61d3187e94068c3b4c9676a1fbcd64c609270603d3a2bc4bf9c71e47ddae8ecd38abf2ab785fa25fc7f66474eaae52ae6b2b79cfc6223e2a052232371f7fdcaa7142da3e03832f9364ceda0b72d9947e9eec0829499bea75f634860a5d0690182c8bb773de885eb13858144067a6919a99acbb90667672c166c0311b3dbd0cf6aaa623ee70f603893fc3424712238dbb0a60c13f4c52e5f7d69de4596a3760a5524465c96f93cc11de3ed3bcd6c69ea932d6f24f55559bf65f15a234378c26e4a2d2ccde6a26662c538e6e65a1b9b2f0db6420dc9e5a2bdd7c4ad2ea46f6091ad11c2ff6f80a7a530d0fa8a76b440ae99e4b12456e46323eb71534a1b8f0c6b2bea7f8b61e414417cfa85c87d5bcf12fadb04733509378455620edcc6a01bd351c048342bbfaa51cb4d9ecf7d29686f95af12a895f82ac94d0aaa17e3e6a418a932f76252624d8cbb884fff10ffebeeb387ddfcb54beb34cab660cf55026a95475939cc1761ea7b875791877d4cab78402bfb9b4c264d5bbaaff8b2564581c105a9dd889818e6fb0a252a35f5f4c750a4e8d2f1abc6a46d761f503652fe4f8646f363a4332ee08e667be9c7c522cbbeffd7554ed39f5f927f4546d08f603a20a403000931f3caa8d844a1fc9cfb6c907617d528247f632ca0bb7a09266e41eb76654812188ba40684c164d9f57c52c2e276362bec1b64fdbfad9ad239abc5f8344a06e972b9aa5aebd5045d716ecdc7b0500f13204dcff6356015e4048b2f83900371ed2c451666ec79bc2544635e8643811a4ecdd92cdaa348ae6cb830001f393ee79892e856def7ec5144309c427bf3b1c25c4a68b19c8bf146ec5786447d7540ff3b2227244bace78fc2b93af96c4afdaabe85356c7f1bdf3fa7ba6596a0ec0d6188f71899a3eeb75b06daf9216ed0cf736c8a4079e0eadb8fd3e3ebded38ca3d147f9411ec2c1318da77fbbcaaf53666b1c6afe6585810fef549b4b7ca352335d7956e7a70b4db4ca4ade53e9d30a11a5d88e4cfee3d82a85de2a07138f35e8905c33ee2f59d07cceb6a839e90eebb3dd71b0519e2880bd215595925d4073b64746610b4d4ec4dbea8bcf44029b506c7cce037abdd6bc4b30922d589ac1af9a96f03f7dd2dd957f8a4b9fcb6cac1c7534040a6281f32d545590b88dbbce6601932c98b0c40db0242487595e00b0a2b2240b5c54b306e026955a40bc2c1b843541aadc1382f383881aeef357f0de25d20901b28ea9158463d600379ed174d3217f537592f907e689ab19fa8ebec0a3539c12b29fe1b1e0158c685d10f26d43f0e40d19a3390dc4a9ffa9d49a5460bd983f0586e4e6b507b02c3bf4b27e0849c01c5626b82db1a16b442b56349fef7bed7239c6211ab7d66de8046b4a1c37b9d409cef74fa9d1ac193de7c01b378f3676717818f4ab1f3805f17bc503afa740417863f60d2536fd0ee93b75af043b0425b2c41c55c7e3345c5dbf8a64b361fd8b7ed4f82b0ee19b76d77f041b663d47acd4dfe5d4ea6b2088c1a766be6946f60028eff64361ee402ddf1fab2d68303a31bfd73652f4470f94acf80acd4d0a0f429781ef13518823c981ac1ddd1564d4f8655073e366a88b71ecffc0f956417399189fb0c9b1c1532b02dd21f0bcb2aa0444361adf8e804d31ef263a6d26ac913a2e55510b97e3de3c59d8649149645f0fefdf7d1919bff7c4d9c5ab5216e81c4c2b34645423a714ae8cf158550172d55899986be8e6d4276d16df41f19ec6cec2862d5575cf8cae4344ab903adfa2c77b4b8a9cd235d3d4fa4f2dd4a53f6ee21a55c617c26ef3faa208a7be5941866d3657302dd99b2a19f5cbd03a0c8286aeaeebb37c1129a26e5e0f6bec99fc3349c1cfe5392495c31df1bd166699a86a5d11120c3d177b87d2f7c6464d81cfdd152ac6bc18314e459cdfba5db0b2f397236c16c6b079d79c28efb79e989705681b44855afb8f55940e925a52d0d86894e6d7b237f6f8b7aad2b89a749e3c56b24c0fd16f87a8071443516697f9b0538f5678d1aaaba3dd62ba811663f9a9c195f92b797d72dd6201db0f779e53f328087b43243772f8bae42c0a442c5248eea6526b8ac3504a3fe9bca77b9dca6d6a10fd38b70a1958f59829231097ad231e013740e6b468cfba50147151fba2dee80d0d9dd7c0893caddaa34a650227eff0040768267be64838e3e35e0dbeeeaa1369a5f588acaee076595258eec4eaa1ffa8c4cc7421076b8a2828acb26c187bcf9881702c5ff72a1be448bd819581e44fd8de4abbff3b11d299ffb5af7d01a8e54ca664ef8b78e55d138a4d0e3eea3b6152786c496e6ed1262ce09152e572a6e883fd20db33459be92fb936d350b39c9216e8764b647d8aa811c6cee6c1f344ee034e01acac7101eb890cb89598157640c00cdefcdbb4b93a76bff2872bd18f4d66d54fc04d42b79c7a7f46e5427d021bf0a71cbb008be9a072cd462d48b1561ccbb8f73805c059ece1bca7d73fc220abb0f9dc3050eea578406226c04f256feb0082aa00cc97bbd954f1abc6cd896f6622231cbd6cdca7c9c55e8437de60cab702d8402a71523a693a9a275549976d8d919fc5d080b01697ac52b352256cca67c18c34de113d98b3ffb46cc8ef80cdbfd5ec39aa7676ddd1cd82ef4e299868b71c672d984452ca41608c340d8933ec27f640863262a01a3e3b725fdbf808bd61f6d2716e0e263269696e92c883ce9210ded331607f8b49886715a290d3870d92cb5412076c7edba180ab922f7782e738ef4c4d93f2145cbbdc6b0a866aa24a5ab1208ef655f849fd0541d02cdce3c2fd6e6ef96a379e270c0f4ecd5a6d2931204b9a05998af49544224b45038ec8489c9602781bdf430afbfd774a4dd0fae21e47c55b1154ca0fbaf1a9fa6857dfdb1729ff61308855b9932d7f59b70fb5161f053c8f0796b113c8167a9487af2fb140f02719bb56331a4b29762b6a5c5382ea75861630d3fa9165380628e7b006faa3f78c85e60e67748e21fc5d4d245fd967170185e0439055a3635707644560bc3dd3658cfa8133ec04f26f285412e97fa93789204010a316f8f41316bb44c1ae31339604a4d85dcd25a9f85bd580000865af8439af935dc385d77b732606eb04edcd0ed2b0562f62737d55aa27ac5ed3fb5ad91f2a12fa906d381e9a02c1d98f28e821840c45df3f09e3e894f7fcaced300653bd4cd8b0a03e8c8612eac32f7f4cf29a5b3e8881f6c11d1031168d6b39d30e23cb06fd91cc928561b3d869dcde3532eb0e9fc099d831de7c61235a2bb3dd3fd9c5a29d17ef9acbb7f03f614f710483235bad947b199ded3d08f312352c6de72c93200e51e1686524700b4f0c718e3788c93d168186cc06b4bbfa5e865278a2274e93685c6b47bf4875bb1a9109d6852e851a6639a68f8a3cc708c7a644315f016dfc56f455262ca93cbc420b2ed03d8826d81f7b9f74bef3812c70c85e6aff408bb1b251bca2efba8edec292901ac5a1e8f35157b93212ca0a227fde1652113c07ab2f1b0dc793db9428f0ef1b8e55cdfe33252f5318732d8119b5d5d6a1e988fc25702af45f6e842efa155c53561494a165a41d17e4cd71fad39cbf90e4f095f92580553bcc8a20ddc1fb770fa87cbf3f1d4f545f76d0537da2dc923b0249443d3e880d99a1e3108d3894b6d9399117f1d98e533b35393c1f1fbcbd2fb2eacf71c23a1f06189fb3f3e9e99098fdd707fbd3d7fdbcaac7172e36dff524d8340b3abc922d094867f845ed8ef5da1617404a78986a0935cf12faaffdb2473969c0641f76b08d128c08bfadf7d9a81b52b25fc0f579874a2895387cdcbd081ef8db7810524ea5c3389cc24206c2cea6b32906c863f9c72251369cab0997ecd556bf00ce8009f9b5b010a9b43a09eba53889a64d13281fca647ac5d6ea2ef07ef8ef1a5b9dab23bb4113d49f2141d71f3501787e89cb63487aa7d2df44889ae9735547a860ee8e76731de38c91221337bceaf70a1d6abb0e99c75c93c27f688cb90affef506cee55ce6e21d345d443edf1cdea264494906134891dc4860b80790369d0a8ad1683a41d03d5f997fc28ab777ebe44af6104c7ddef460858f276579e801d568d4da9ecf2cb961f11c29ef30a9bc8af7aa82c19904a33881bf61921e2817820c131ebb18c9f22df27903143274436102c50290b853b4f673a22e8505d391985e634283169a8f56e7d84a107c6d1b47147a37b74f670dbb38a879f556d5c3f034397a59b6e9610fcd0f3caad51afe5f625283e3098da335db94665d11e180d923aa9846ee4dd2b3e6880a0c37acaa2957bf5cc36f668b25cea11690b5bfa71f069c7fcdb94f69ac9feb8807e7a6bd59394b2ca4ae15b4d8c5669b406c1a45c6b047a99d7fa5bb8cebbc00bb3f5469def055be6a522d327d47fdd4124954cd9cecf30ca410bdd6a62c1ad7183d88099c2216646341d911578aeb8fcd2662d97125575994d19b43e7a1a657a9b60a43c8495bb3f1061d8e013f4890ce36d537f88831f7982194013d4d4f80175ad36f63ea28a1faa56bf5813c87aec797798936b25697aa662758f5931f336e4532ce08c508b7413a55954ac5e316c25ea3d6ea24b1eb959296eedff4652e703fb2cf86da6a70b0017321a09af844cd128541f0db779b7a65b6e960e2706e41188a4dbdb4c4b11536b3d540ffe2a2dc898ab7e309bfe4970e763a76555a4aec99224764f9dc40940092b94457f9f236d5c8c1883d57d53ef567d36a38db2d8748b69f6c721e1651e4eb95243dc5d23ebc495b31b6fca832cdd687608585ed1481e0c8fc500c9a1e5b156fb348aa67421b104fc7937cc4215e4e8609d928a7d68ffef9a5d63de6bc4198ae392d292abedf58123df638d5a2a691e6a9b19d5c2e96deaf7efd29748092e93af403f0690b19ce2f3a466e1bf848661a2ea2340517e48f597ed3555a59ed371a83b441feb62f621db7f66506d37975994425e867a156ed003311b7e56db6bdf3d9e2ee5602f6755f36f866d52768b43af2225a07f7099b9a955381ce1228a12694a54707f5419587a4b27aa323d1910a2f9f807c74899f56d585f4102ee0bb872ba29597b865ab0b48900eb41df8954f229b8a6eb18d90dd9d6157010a6d34e11b5c4a8734003ee86fac81a0a5a71b968b5fccc41b96d57ebce76ff58bbebef73f63d691155036012ead604f671b341d8a35ef758fddac5722c739c320e3324268b9aa0e3cad43116ec21b3b291cfe06cdb322559486ade5e45da2eef5d7e774def4a8b44e554b2117802eaecc2ac6202d3f5df83f8a3ce035504f2d8d5fb7202d8e17d2282296ff96ee04398001920dd8f5adaaf19e013b7f6a14244560f2f0f506786881c0d35e3e8e7dc2783accf208afc736d1e576d6a76b2d84fe7d0098240e26ce8635b0923dea09f2f2555952b16618b4012117dbdc7eb29263487a3236a9dbc7acef41b0e021ecec083aa95c200d5790aa573c6a0b7d9b1eedcc21e9a07f3fd035b70645b02a392a114ec720034c89e7344c114f4571dec85cd785d4a9ab10bf273f8bebe8830e8a0c1f58447b5436d57e0ce2c43a65d323e1a43f49fec4ec0ce09465ca9ed34629eb074b90d3e053f6fd1c863cf8c6f6f1d88d9617f494bf78f81122b3ef52c513bd32f56ec670c97df672794c5765e94b7368b9de91e2d338025ff2433d7b68e2f218cc1a93df65cc6b73c047be03640737ac77c2c7d50703299647f4d28439e9abf6cf5b93e0024d2701568810092767160e32d50eb1b5fa3f8ac166ad378a235fd78d65c130e044d6dc12f9e38b2386b613b00b90702d8fa6098741564b0049de3ad09fa48c9b0f0ca0a2d179bcc94246793682d44cd420a8858ae302206f573e87d56afe71f8f0e1eeb4a5cf6963506e979d96d7e074cc8093f93a47bcb1241c1865613eafc43bccac9781024e2ab88bf3ff2a8f669ac79a3a00c89cef38583b85ac2766a923fc5f670900bd37399e7c36d517a26fa812c9432f8a11f40a06bc9fc89e3497c8e37a3f350a059e39b51cd2731d4d85367720e1c61dc58040ad588851c96de65aecb526c39b8429f60048b518f98918b7a1a994d1ea3e20ace6e733edf560493defa113e23b7811e1b5172d202f5f705c060f1fb6386d319278dd4a8b56a3fc0b5dba0660dfe63a15ef363b4b3d64b58cd335c3f689d282695034f31bdc812cd4a2cb0a4e2ab9666edc2e6e3ad99448c8f75c73b9b3259e591eaf8325c3e93981c08e846d4ac3c0cb3683256f4256142cd524c1b9c412e488dbb2012d7f29166940735f98a72620fbdfca3465405e4b7566f189efe780315517071ed6d00a0f123c66f5eab390a2b9640b757f11d55e549eb86e2eb236b7c6aff5e810b4e9dc7b28130b6b5cc3462b02cecc89191cf59dc3054721ed60fa1e3da48f3c2a02721bfcf7d74511e24a9ee6ea51662f09e5f71cd23f4ba8bcd3a674b4c355cec3da41aafa2b6aba545e2719dc871e842d0af0be258c13933063cdab390721c56e1c131b81eb61c3f669e86b514a07e4674c5753bfc3d56e373150e0175d9fd27cb26acea39f339b850383af5ae0c488f4f35c336e36691d1b96cf7c85ce93b5a982c856df3c04d6955d6168254b57918836605bb467358cf0cfb062069789de14352c1ab390353bb90a60a1ecae192a72ddbad702f1b1cd988b9b9de60f5a2d6c3f071102f1fed5a072108a41fb3232923c6bd2aba08ad1800b7d7a573145cfff1708574d7eb927dabde975eba19d085f4ae4e80cf0481bacf17092c9b47cc51a4b21f9917b8f58ce77dd03880ac5476c17adb34d1d1562ca57eef3b8ba92d08e92505a9e3757a6e4c299d55e013470315e15a4787d44f089f6e6597d5dcd1e0b7be886ad2ee02d8dea23e31bbabce6824346ef0d81526d07aefffcb51f46897ff64cf7dd1e82d89bc51f6f05466cb7a83688c4c3e32ecde3cd46099b827e8e7770833afd240351cea989e5f2f6a479d19235d47a0dbd82feefaa7c7470281ac6c0248caad8a96d04a1700646df3f507ab2c5dfb4c215705ec0b8f2165305452676d92d504849938dc5c0b49a4d30bc4018f7d16bb0d3bb5c509e14f468661b115dff0b46a61b662ec87f20798792d16e4c2c003a6c90008a1fe692739a2559e77df49c2699c803fff890bc88c860269779d46deab1db2edb3127466061be2c8bd9bc2a02892fb7c4f8c5db882a343569aee50d6fd19815ce2f48f1956b105408416182ca95b17e93910b5c6f5a75610326a763c6a1eced2226d64551d8367eb3f1b618aacd8223ade5bcfb082da8709da10a559232562286595743a276845966bf82198c60bf0dcf658aba772bd3fb38c09a64e6f8961d99f44b52f1a61c1cd3d3c5031b3d36b251b6115b33597cadeec6b1548f50fc4719e78657ec22f4919981c9b26a09053af77d4e84f0dea5ddb11c3520e811c2b4585d43c56a0925740cb652b9776e423b1aac8b5cc0b595500f7ccd369a6ecfb467c5404d5c44feeceb1b0de4b28c2ac12d641bfce1f788ac8545070145b775c5631c1f4e7660230b2a7fcd4e1819ff308162a89e7adc09e0461ff4f0668fe20f02a43953c2f09bf797f126c3a631f0889eec5e73afed4219b71bf61a46f26abeb58fe2f5fa73a9f44d2a1bec67cbecbd2d435cd654bf43960f066ae4bda896c3e2b560958975f63f723ad5d73adf26571e322cbdd1571dd91c56df49b8e64237c9c4448debdb102d46ef1c9ba22dfc4a7ea4de1c161c260ecd5b867a69b74ff5db69a890e8e1bc984c5b588372ce701bdb7b3584a60b3f6531f00c79dd75281e8f41d89dd5a8a00c254d331d1aa9ee706ca32950f89aafc9eca672834c043aeb790f9050b7bc0eca689820e11d023468127b08a431052470e4c989638f77e03339bc339f127a1b6557856b8820ac943e9f405880eff0d3ca2937b21cfc3f3eac2cb79aed7ce770b769c5b0e2b9c90a78851352bf8fbb0b1395278b162571c1f886dec8c841e6b35b3d1badb3eea72f330539837c83c1c4e521312482d49a25fc76c7d0dda71a82eb3acaee472ea7f5f9fb306fb3df5abe135f66d090cc2f81dcbc2413e655076dfad8cb52fe30da904a906fbc820a4e862b145dcfb07e97aefc6b5e1360e1c1208209a3c9592d1af720a7024873d569337d7b211e3df55d12ed98f76459b723d51799a146a3a094db8900ba3a4e32f7c43ad26efac27e8e0351f688985583013e5a11862454cbcb0880f92484f06978c6230ab0bd8e5b975ddbdbf569dc4a78b5c8d56b4dcaaa525fce6c1ee5390534007225a62ef8073e3856b72fde34e17f19af93103e36c6107c30930c8ee383ca58c322d8795eedf712af6ee535ac3cbc24ab1853b2a036eff83c8202a4c507282a08b46e993c12343a5098e9405bdd832306e46dc76832187f65f1037b83f2fa31fd7e6c0db7c7fe234eee023e67b3760813a20c0951ee2ab91c868e9e5f04227bbb15267e4d2fbfced2f3d1472ea63708469ac4e599830823c761cac59a8f3c0cb536ebab2d035278d5f482e9da50d7b0f2a496c5c44c3b9d7fa5809059fee0346fd0e1841faca9419663f85ec78937527f9bb6780aa7e1cdfc2098c1031f254a9e45214fde7a2334b07eabc1865999433b6e284ffc5bb42b31e942a7da1f71b5b7302f91c721f5288acd03513e5e0b22da0464e8869c1e09a0e33ddea70a41856cdc1445feff87fee2ba2226b015f5b25d2a5dc81b152b3084cc7d02fd1b81381e154350e5b37cc2d45b795e788c4739ee0bad49008e11d2f0a6d9a7824a9fe3de5fd5a019f68ee4314d595df46117e6b6b22c58af728ef0bd90a1653187deb003edc7928af556dc9df9c8baaaec25fc7f0b654a7c57429d615509f08906dc38c72675667b232c04fce5ee72fceb507bf7471e4a830e9f75f18e60d849bdbd94a198811186446024586ba13e2a0093bb3c6b37bb4359f12d6f8bcd07deec02bf9042186c782612bf387dc43ed7463e76721351f6f413478efdf2bebd8e43940bfde3dee18d24ede25ec84a7ae631c95b6d548ad587463e596f2bd817c551162dfa031b9aa0b614b23941a4d16dbde28c80bd7460504020b967e654e619111f7606d64ee7fbb9a3f56af15657d8a845f663299a66583ebdf47cbeec924a923c8521a350042b0116a33fc559f5b6ab4e618224ff5113800c6e5c5f8d2b297e495917e1f50657694c6c9554e7da9afbe13c82de2c7bda9196fc0a462226e87cfe6fe1f3c8969ac88ff07e79abe86c7f98d746713e6bca95cce0859256447e837eda35b0a9e719a3c22b6bd9347c0e5bffd1a0c96cf2301505efc982239641a143d3e45c77386346a67af5c21f44c102dfc8863160ecc6660d02d371c4d45b25af6dbdc72f599f7c471f614a76f44e379da683c00830421b1d8cf073ad096545d3d6bf74bbd738eae1ec545b87c26cfc3e7b9a20cedc","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d3fbbb18556a7165ac906c4881d771fd"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
