<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #1E242A;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #1E242A;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #F9FAFB;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"81063af29c6b69673aefbd8f0615a677e45bd539beca793e38e9f1c4a319a1b25ea5eeb7b10ca0ace44ce5b191a96c6dd19cc6ccc4b7af467935d905bc7c2b65917c66ac12770d52681ca164cb5b52777f8af0a383f264323f3ea65254b27cca1579e8c2d0530c10da972ae2ec1676f37cdd0d43ea419f606766019614651ff3c7c8eef3e600d8f4fce2ae0bd3ed1a640629afc31cb2255c047447f9a0cbb5717a6f787f4c4232a7f3d6e7d3f76e2395b84d71321300171b3d56842736446dc3abfebe1b519adc00a80e34c2bd74daaba8f604dbc05cbaccde56aca9c01a26b5269b2c5fb8975ac7e3d6296d761c0ac2b2b84e118ad6845557af60e79ab246b82b0d32197673739a4f81442645216dffb328786d9697224c953bf6e4c0f3f41493e8fb66373358f680684854578438e7e067e1b6437d1cd701d0bc0e69ff55186bd1c78351b19ec523b30435dd2eb11674e2c52cd355ead357d46415a583a28dc3c96eb0e9db46797bf5e7e59902f6eb56c74322f2c96e8f66d279e6a90fe8a747d12eef8850b7ca425c209f253af9e7e99d70cd54a4845a5da0e95111814dc98bae8b1f787475dcf14772ce7158b65dc0c0f42e6a1da14bfb87a2b10672172f9c9f29fcd01a3b0ccd55e37ac4065660522f3b37ced5a0a6784558e2d9c7ef7c672f1aff57b4ec304373b2f25edd03df341007f52a960915fffff7fc68ace9c4d07c09ebced3e09b602460f985fa80634a7349b839476ccc0c7e34d1aecf5dc74ce4de78ea9bed0b503f03fd557a77b768408d17977f11638fb35e12e15eb9e4c271854f995993f9b169b9c9d3575863187cd2b23388fe2e34f436759f888794dbd960c201390b807593d6588931f4483a2ae3925389cd366da8ea61b12305614e2b6cdb378401de6daaa24fbc15b11264a0f50d22fbdf0b36d5029144eb70fa3b8789d8fb2f1d11aab743f4a212e48b515a457e0b122096b08d925fbb5d0dc9d0466bf3d798378d1f8ebcb68339152ad22ab06b51ff1eca4d791dbaf09b0fc8a78d2b23467ae3faa2d42eb2f471e279ee02b5b449f1b56bfe67e34f445ba24b0b1321d7951341bb8a2ad5cddc19b62b071731d4e12c78687a1f128d00f8fd5bab683eb3fba8eef2a926e18f36227a0ef3e5dcee44a6e7aaf0703267a7ff31d3c73e523201fc6ead3b8344cf03d542afc08ac2fd31b8010ecf15d4adeafcc9c22fbfb943231b0985dd3053350a423e802c36484b39b88fdcf1d03bf95642f90e9dbf1a0c112eb77b084e2350228afd62a416735831cf60bf4c4cd7e535ea287a279a650b307de9ecec44bd94cbc2f9564c8ecf884ad8d348d0ec0c79c4421edaf3430d107421532f2f12f1be030be51af919820e13736ed9920b7c99cf2fc2ce368fd3db2416a39e3edc0ebe514e882ee694f43dcf04dc7ece097838f1299c8391501d8e30e343804762a92b20b600d2883d6afa3f599ca0ca88643f2a5d5978ac76b725788fafc3d61aaab2ce2cb9dee9ec37fbf2972bcc1fe0f0e5d705a4fd60e1498c6ad4983d2bbf93dd1ab198e7729fab9a309369d1749a14a3d2e895d11daf8bca829a8cbfb4915126c06d37ef0a2287acd5a1cbebf33b5d441a7e43dae82395dd70644c612b14afee2cc36fa28dbbb75de9b6590cfc7cd3366ea4d2c3747c5aa1df8e47b59bdbea78847247f82c5f16d46d9dd310a22b97f4cf5819e1c7a5afd8612fe98c44e7f84a0f843f1ff44e2c424109c2d1711571da43097edf0f8ecfb8ad2166e924b2eb5b5c8343450cb87b8b21c0b3e5c5fe2d2730375d7f405d7de4f48cf757fe971f4c7b33a1566447b00b2faba46f79389a8861068ec8ef7b96fd65ee26d3a1defcec6372e213459b4bf8298d657c6dfc3ea7e11b5d3bc4f8c0acd4513aa34b641da65924207bb4ef0fb4395b4c2ec06890a6230991d4a8e522adceedf8498f0c96e8162c8aa59e4c520fd2996e77f41d9638ecf6273e32e21fa90929afffcdac1a281ab0efa041211ce0ac394b62a687763da8d75512c1ac43f7f83e44ed2925512d6bbcae0ffbe66f789a957a7edc1ea00af1eb239ff256732a325b8c38a0f7b8a7dc06ff53a838f61a21df92f87bb8108d112cdc2f01fe298493602bf6ff1f7b02a20dfeef284879ae783bac145efa52f68c3f49217598884de8eff34eb9085b59e7ac98b36c5f7c73fc19ec5608eef57fc5f69120fa8fd66345cc677db18ce61ba42db996f2f5000b6c711b06d2de37f4d4eae68162adf90365c884f77e7145248389f3b8df06e49b32a3a0e425f1ed0c319fbc30f1cd3e7d60c6051469f578041db0e62c78c059a46571c53a15579f2dde3e35eaf14651c2b0df224a6bac4cb7c655750162a7a3cadd12cd4f37d1afa075189112f24a2b8cf1ff5893a9cf7cd84bc05261645475fd09731c4554ea2eb12dd73f5bdf0bbfcc9c7d25ad243e113b75fdbeca9354cdb4abf738df120a5c25fb2b8ba7f2abef122fcd182f319c826fa84238cf86eb2d565b21623ea57442177b16ec6da50f734d9285c757b1d88e539b6abaab4db87775f247379291ab91a97d1e1e956ce354ec8ca979f065a2187f2e836347f537f450a0485d3c4a9262bffa4fc5a77a3b4ee9a358a5d8d25da43df2dd970cc857623c6f324c9ec70d62d0a8e124222c50d69572b3851a73dfb7279e16292aa1cb8e63a1dddfc6e26f91bc846d908e7769463b52c1116c9320f29822b8e5bba76572c04a5912c4247ebbe6f14cc78a70088102c4d1acc9056d78d39f0cb06d75a8b7f0e0e26df68d3ae2df14c1bbbbc7307223b2bcd863e6d58adb6d6501ecb0d015d3f13d8db912829adc18ea2794b2533d936a3e4eb9bcc716b09d7dc865a61693201a25b3edfe7120cf40b2b227d478c367020093ffd74a7fac0571b50fa8164bb231310d29aac5c3a44697ff330adca728e7e3c8f815bdde743e8f0aaa04e37d403c7622f90de060d34dbdcb0153626a380cfabc5a5fea1dac8987c8de10e039fb5888ae607504a56dddcef57e597ccc6d78b7ade57b54e9d266386de05e2da67d854dce6aeb1625784c0cc1e956e2419b57c3df57ceb7b8a32b6b0d35573ed784b076fae56fc0ab3fe446219fdea6814fe476746c966cdaaec35cc6ade839e39f10fe9e4027b00df625fd0014290bb4937d56ab49d07a7ffe7beb7476ae39d806d43582538ccef88ae9b62583eeb8771e90d46163a14031c656486e27ff00b1ad6472ad51d836a639b8d9cd676d6ae08b00184636d5e1b20dca3c6bc61c669aeaca3eeec04e514e4d33694b36aa1fa503a8537d656d55059087410798c41dbcdaf79d25ddf835ffdfad49ed5e510bfd20c0f1877a781ef6601798bb290c2324a755d28fbacf82d2757b91aa399239525d2bc22a5a0ad85f9005816770a97e158634652dfd4a2340b1ddf27b659221cbeada3c9e040b9a32055ee1529e6bca863f888ccdedcfa983fb6576d3cf6c591a67abdd4d4f9195e68ed6197953fa93c8118b8796df7be54ca5814ce9ea14a8203fdca4671ac44d0765fbf955d05b8891c69771433fbd9b2b6d60060832983d46fe0da950517a0533c439d9713d375466f83db7400b603b046b3317a96c885f1f8814ea13bf6d5b474f9e853bf099c0a8abe7ec4ec73e41505c943be4fde0869bcfd91fd040ead3044a416fdee6b39fe532f28ab12e7aaac1999b8f0d5564905c33dccea465606696d318722d3bfdb74ec7f11c9e295a3a2807733fe05d62f9f72d67eed3506ef79732adfaa8b64ddff41012d11f8cd9427e123e472d783e914a63ea820690df9d5c7985a1e77351f98464513cd1196030fe72bdd1fd325387afc3ebf0835dac7e54cebed936afc75bfa33108e7404f79a0606f388d0b627d7c770700000c560c8d387c6e6bd4d01e33cad8bd09e199cc740a8f4b96b96a96e9393c6bda54b67b15484a5dfd012769a68ba0a7554260d67423145b636f7765cfe71697b1372277ef7782f6e1e55e1233396c217854bf8c7413fe5e82cbdb7cc7e11890676fc3fd4fb669b26c29220fb2f0fc3bbd6a08b914152086c58f3406bb31e34bda85eacdb8ea96c5b0fc4a1cc4d58d10cd0816ff17879850ed287fb25a6c3baf5fba229a08f38df0cd17be8e85d558a126d8f862d904ec6b234ffc85edd65f280fad7fc09c43426f252268eca576125d4b704c1c908456b952ddcc2ba2bc10c45ab927bd17907971561458a85f47763efe59253b8af1ef28bd0aa0c53ae41cb0ed3f95d1416b6644062551db1edc3843ced1ab6327a61a34b34b86c80e0e5cef4a24570b74a9a460ff0902f0e19fb966693b24616a3a281219ad2fe342d92018dc1669458b463f20a7bfa4ecffe772a9333078a969352845e2d95da23a1757645cd69e5800757dca40f32df480592d8154ab1a8456f38341e1f89c95e6dd9a7c41f7e41fa1f935980bfe80bd6b299e634259a28fc77fdf921f0c3bc43c7c6fc5b6862e1347a0fbfae07dfa2cc6c65dad45c9b98b1b6f956814c46669b696656fdc10f8d5c48c94ec1b1adbb4c68f46e3e6079f8b9332692e7b693cc2c7de58ff5e0f9db929c94178f3c4817ecf2bba27ebc4ceaae3987e5aefd2a8ecf165cff0460f36571449fa1ec09771ef029c9658f9b51bec1fbc185f024faf75a383d96c78c91e3bdff04939fe1185a77fcd6df36e887923b4e745eace4c8446b8e70b45d65a3470e6e291ac35bb327ee926af0a37d7ecb6f02e147992b1237472717c754130e1845bdc86f6a45ac33e1a82d8d7a26641486c0c07e6d0f08cde0191b68de8b8c9c2863ab0454038ab96641de0c60f840fe9cda7cfa7c69988774d3895887d4b112405946337972f03576922f41f9030ce37ddb8576e26fdf12994301715601c8f3fa2e09dd9c91601a1f9d5a080d0cdd675fc9e5f7c8ddae6102cd4c6282431dda49dd95b14e36715d98e7a88cf252a0510f1cc4030fcc1da58c5c15715405bdefe2a8e46d2786a98d7d1b2bfd66d4b77ae3656ee15225e4cd9d4c0adc694d9547ea37e57be66c9a0021bd3d44b98434cc05724373f8b897007ce3ea96e706cc7b487155b9780a571c88feb7852727d313ba328aa12666cc4a87d356e3510ada33bdb10124c06e37ef542ac44ff34afe06864212cb7b1648f51f1531f420a1f4d41cc6502696249cedd04679440bd4aba390e96e876ad15c930e651e88b02f8d812f5cc1e9d9ed413d526eaee06b904e05949464b6e831f7b8b787b9464cc45e84b3e5b11cb2b79deb61f7840d8663d4ca2f5fa3d09e5130e96818f8b7192178f003d4dbf23ae25e2efcad10804a1bddc8d574304d6a6394ddad15cdd65e464e366b9bc0154aa8d23d9b20bf5f4aeb34d13ea60ba4f8231d4bbdcb99f8c72d75a2e3237d688ed3b227420d86c4fe5d0a60037b1a0bebf04aca4c844e411f462f8a17eaf68a10edd4b82864358184b086e3e223f4d37fcfa3773b040908c6f50d3f2f7a181a5b44f6e5ac9a235c841bfafac38cf162844291ff012fc41478566564728b6434d1ed87596b4f1f3890ec16f69d582144041a1a45aca7d70188600cd29b96c751e958b4756303282b1361655e348da03d420a345b3868023a5a91c5151d5552b36d502810bbd21a6ff26c12b3103730725220fa6b74d4c07ed0e4e5bd101850630454719b70c4239cea8c97312c2a440ef49c2c1c134aab7d5279dbdcc4580bdef7ad0456ba40d8a8ab41558e81c41823361004a149f56451f7f43f6aed1c79b774f723c8e36e635bd2e8b4dc39d291e00916d35979437e1bd57a5f709c050993ac61687eda409b733db15a2ddb538180b7c2cb29779c366592e8f7d77d7df31c14dc8cf93346d4ff7445a59180415e504ea2ac27e31d3bb147fe2d522e6397298b726769646fda66bd1cef324d9cbedb3340dcf1699a6c91b8167bc12cade5aca5a96349534a89b053f3dc663d44edca464bd4188d709605ed67e7e9a3d36bd54a0536bddae15785bc473f0c93c9847b730dfd1cbd452cfd0c702527fcfd2d108c75e06ccb8a9c4507a7ee4f03dc4c85baeb1dbe91f4cc7f70dcb3abdda618d928cd183a375071477ffd890c953b0bd29b139a7d12d4339a798886e9bb04f06bae06d42e5c64b0cc6dec82303179133228a942a296dbfa062fd91902368eec30c837b0437c3b03a8ac83de2de891736f8cab2dc1461b92af48eac051e92aecb75491649a0e31efbe970a6a785f06c4073c2160be7be59cca292b7c5a7714a78420eca15e74d99f8b6f14bf56254baafc64c999da08fee93348719c9034ed200f67997be447522ddf2d9ce4ae31dfe0aaa01801b5cfbdf03e7d993cf2385fb2d35bc9f7b7426755b1ae06c5a98ef72600bbf4e66c7ab07731876cac745047b2f4a3f605348ad5d55f39f71f7b9593581919689c23129f41fa81cad091be35d3607211ae927b233018425282a5479e8d1fbd8c2348259d6def5d6a376342ef0287242882f5e338cdb4633729ed1b2cbb4ef84c8247f60b04dabc09265fb752f65eb089766f4d1d566502a204807634d3369acf02c5f80fa1e147ccb3983a6ff3b6a23ff66de782d3aa153c934d03d8545ded5bbbf1c75b1507ec133f3d895c091795fc37c463816af48c0f6f129024dc770eb4eafdbbab9245714d40f3684da27c9467aeef2788103ae1275b763bc38e526ed0ebd6ab5d22a0b9ffe0045d04f96f29ee4477649c7facda1093c1b4364d5dc5aa4d005510f0fc314d1e0e1b1265019479c8b5ed7849ea933768d78b52663bcbd805aee5d029d2498bd8e12dc43467a97ffae7217b15bd7e6a1e47c663ebc08d64b29c27ae535ca380e4f7819995ae2c149941db57390c4cb15b204fa8a6a4e3e06e50fd114a159f2e1d007f4d2415fe733d03eae97c26da4f258adca697c3ec12d341cb18490df1f52d92f82a6f6f9240121f78da1b1ac58d85da1f6241b514aa8ee82e0c186451c3af41b9227c7a44cae1c4b9ef46bf8bbf5db22b08bd690edad16b8f574dad4189b611dd811663741b81cd460526f64b6a98c3336067714ddcfaa34a46c8a4b6053fdc1069f8056790c3ff267baf3f6d2910b790f8f465e5c0e65feab8dd8d37956815f8ff465e8dc5f763138cd165b5c8502ff8cd65edd6797623acf40c9abaafde668b69a72390a392fa4c6b0bf3613baa7399295a6e44f4e92686b391f57528ed330ae2292f94240acfe32763ac9b96161849d6656ec0211951b694c54d6e396da8ba001782629d9b7d1ac2e5f04a4f8cd781d3adda24405583ad5a9d0ebd93019bed014f90576185e154f591abc599421baf2115b3e90cb53e5cdf2f052c688e2fdce6414c74ed8d309231713a67ead9e11373354777838b5c1e40d30e5711d9fecc7c190b592b1e3bfd45b9414efcb9f1c0b9328aaa1f7ef0885670926b3cc2cca630a3e2d66d52aed0e335ccec84e90d4b317dd6befcd4814bf7bf6458fdd72af1e599a8171efa40bd67844bb959d480be3bca84162aa1e5017971c70ca768eeaa993b5fd3b2c502cdfd863f0315232c3fdce0dd2950d96b697a199cfce13362923280c684e4dde09778f2dde926254de6c17c49310ecb9dd69f4bf1e2a4fce74a43473929da5c53fd384b85442ff531e05760849d7e664460154ab6459d129667f118b5b928f44d96783224f500b498524edcad89319c2ddb0f280cd8a7e75099d4119f3360edce615c730cde1ef4c38e5a407fcc51dd2ee29e88c5012eeba9a7eedc45f350ec67501506cfb0a33a7ad7064038bacaca73b2e06cb1254be8733959a385a3b46a1b9cf24e5527d90272eeebb4b57749a3bdd2c07c35c94445e447806ff85205e51bffc9db1acd81106c6451448cb795393f7fc901be948cd83d755e131c6fafd267256e10c393c967342faacf15eb63f6b7d777d74cab5767df243b3976a925e3628169ff9f21f3dd97a150fc63a14d2910ee0eaf268d4ff8a931339e374de7bca7984d572989e7e24609064ab705ceebda1a3d8cd876e5a9ce8fcf663e89a5f35d83b428d17df4704938d9edb627c51ae1320bc175e4263600c4f41c85602b00f774b136d073d3aac27e6ed57e2d8c29b5fcad518d772ce36d431088a51b7e8d7dafe1630fa23f5026aea85ce5eb1014d5b502f6ee899e5eb4ba82581fda4e4d7fc5601269f39e63a9a9cce1d9c9a153d4190d7c518803006304ae19e99fb3264e0fd4acb47cabbfb10e50be538ecda6cd788fb50ff697f564b0889c7e3fc9d2deaaa02ee753824fc4d04db043b2c79f927eb4ab63e3a8017a6206559b11cd325a897d39ce4da463f45661e885932aaaf900b3813d252f4e1488ee8d190adb9cb5d21009a936c2145afafba599eb0e31d542f284faaaafd083cb9aa714a823a6d29e52da055f84a8e06958668f721bcac3d6ddc41b5b3042a7d446bb21472e7dacdb3cab49c3156dd9327441391bf52176c73263f43d9b7ef6b74c834d22e76b39c960c76efad079ce170d196ce2b6d9b5d5a3995265a79c36dff8aff95a788d3546163bd5c3507f95fc5114da3ac5685ad72eada0bfaee116a2d6a66d7b77d166820aebb2f29d523425e5270bee0dff20de8d7c56f78172ca449f20baac364d9de647080cc3381e53b753f2cb5f035497368d4b3bb9a9a1a7b46a7db1c057e402522ad707b5ed1e6a67241c7500b907952fdf8303bd4e83f01f770abc625063a36faf72cf7cf2fd33592d505296e9ceaa63190cdd8198fff559d291d9f2b03f9fc08f097c892b9a4d4c988221aabefbb7e3d8505d623af7a94754e29f4bff74580ac3dd6c585f33757df3337c1644700e54056d15208740dab53f8f3b70d01307758a911350215d8e49d0dc1ba6429a41432783234ceef70a0289d2425a3fc03f27283db5c51446d57797232906a2fe0bc100ada90d8e3a724da7746280286d2612ecf66783d9ef4a1d936529825efb086ca7373d8cfa29035472935fc08f60d7f8d7f8fe37d67bcfbfdba6157a70149ebfbaa6f1356994ffa22f6d81ac389fce4c27d8c1090cc8fb9b2a16c8edc8a48d26854eda3d82551f54b9cccce565bea24205bf4427a95bcee6efb6a83c4ed2d16658e2ae899d26a91941dca33d4c1eee05e17631e46b57e600c5755e98784f8ac2a9753ace44de4ea8bce7414f27632c9c30a347ac8adbf1c78d7fe94094e061c6957f4249ad113fe432821b0a172a5fca604035fe81043bc5aa65d59990f1857676778248b0507470e28333e77895a7500ed0ca1cae9e97bcf613b07de3f69e9985750990c4db80719e034b165409446432bceb72cfe35df4513c2370dce43f4c3a15d69c5c131eb58445e961579d4cf12e578b8c747e3d9820c2c76b6c6b60ec8a4ae0dea6d91b39e21fb22ab5efd9c65c0f24bb5933795219f2cd001f3d5695e3b612c997dab2a4c1c79b876280d37cff75cc3376a43264f14e041a3debf06341e3184c747d4f79a39b08d609700adba8b20551acd8e090ad0177ce964551c8253005955f53c65b8ae8bb8ae37e59341b4fe5ec7467581d9bcddf7bcc3b2b6db863295854fe9880cdf0dfe37e15f7f7e1b66dc0c7d8b010bbd117f6ea3ffb2563eecf90c06732bc7776d75066a008501c4b3ba431e69550bff1da834cccdf8cd7ac0b793184578927557e2aa6a6c0b7343f813200482afba3ff0923a73e0fb8caf0098c4230bd604f047708feb30e55655dd9b2ddf0ae9bd37daa7c3c3e97373c0604a8b0f7d060d49b56e9f2d5e30e9cbf8d04e42bdfc0e8e5e65297d400ea1b4b7d07103997ca4bc19d748aacea45932bc7ad8afb0c157c69862a59023d4b1889a13dd91f998a2798be7c4e9a9f14c18483899021548cfa030d7deb457350f1b0a3ec70102ad47f16eccd10265acc4f9c77d8ff72d141fe65eb2da093f71bcfa1580466332d6bdf43fd1e90513c1b0bc38f71483739420b60d5380586723da61e1001556829080e8beb1c84fc058d741cd4084ec9f0e47d61e66444d953a78cab4be3cd1141d872f0c3e601c9bfb90221dcdc237a0de874ce2a5c2137340df9a112ffd88f71e9085e8b16affd87039add9995eea54e1eddf6f51bf889c9b5902d73ee8ab37fe569259775549953f7a507f80b5b1533113ebb390210d44cc2c9fb58633ba71c77dc1e1d176b3f36b4d203c9f60d51a89009b1a079a3274efc30d040c4e968c9baa20f29e6263e2a8510eddbd215035683661318b6983b8180a9f1bd30668f2c5625497418b467fec52203d8a17d8269909e1d5f2cc8d62bdc432c3f27f85c3d52ff5f8d5f76a911a0d59b3fe0fe6843dee52fe9b5fd81b25f7959b633fcb2b18078fbd8cd051b3fc9a4bd8794760d504f1ef55708bcc53cf4dab9d996e4bc9a0be17335aae9da35f93326c17333e4f332e66795d98957973b4c65500bdaa9307a4170a153351ab9de7e03a67a7ddccf4717fb57c2b0422a59840101d9671823725eb7f6471b5a53a4790d6808a5c6b579731a2bc145cfaaa1040c0961b73e32a3705f3aff5b0ddd43def18a494338ca80dab76b340f074be3905bb2f7fbce61af80aa743c1429c1709675b5cdd8126ba6c0576f9e2c37cbb41559407c88d4923b82d42e84f90ac1abf2d3053d956104fc97008fa0dd4534a320b69fd566712328e19d60f3c9113347af8bbac8ada1e2e5e4d7d7e276ab198460c27f0872c05a8e0e71e63afb263c756b050167098f52c122710ca4fd1a4d3d5d6d368c004a7b433dae174bae3bc89575b1e7c999c08f5a2a043eb7108bcb22bb53692daa71db1ccb12d6f88afd2a6df9203d963a06d69764abce796d52e155dfc69dff660b334f56c78b991d8ddf5a1614059f1f3a7c418d202f7846238d3443dcaad5246e1d71219c9dc886dcde43afecbc20356e24f78b01872c0d3623582f94472100010b44bde8ac25913016b99fa05877a685527ff1de66a957042592e376b576234c702fd341aedd65f7cdb5456c8833084ac91c523e7332925c58cae2b1fae8346fc3bbd54a09c9e715ec94476e118a963c79fc17e270d6c23ea9e15efca34a11862d825a4d5f9b98176ca890b49e178842a58a544e5ac4f4acb83fcaa3329b7566432f2689fde3ad539af10c1f9115eefa7469e2a5bf52619de3e52101cccac1d806d871182b5a6e4f9a28aa1e9de569f60f0929c2e7bf6dbfc37490e0c3cf0dbc27674b38b90f332186fd740eb73fb38a5f60381ce1961e465a4e966e4001b67be071b66792b459acd94031e507e928dfc0057fcd9cf2493610c2b337f8bb0aec96549d5a572337f1ee309627beab73d8bcd934d18116d2e25033307da2077d2261598e6d5ba2675ecf3bfa84c40d0798abc5258f8aa23813703b7858406e7654955f5d2bff46b1c9bf1776f7576021798478f444c938480d4b9e339f9e5bd21d0f416da3dde6c37bb17488d8073371e3a51b5c6f10a47632f99ae9c2f3cb6225f436d734183e670c4621dfc72b426dda7868018a0e7360a191bf4cc676337610c92ac6bdca8ca5482fef07e19587a9c193291156d56fc799b15d406a1ca0262d0a8b4c852d467f9dd1396576f38f9f9281903b0bf5f41b97f48b4b16d3bd157ee32c0dcff10b3990d8b3324b30eefebfff2b9ee87a5bc0fefc10174e5670ec7553292f35928201b70b0461496b0581298118f251879d265d7554779cd5fdc7449027747ba6107316859f961efb69e27d2074bf875e92fbf9632bdcbe95e1d03af09cc03e7a85d01b6ddd4fc5c47d889609d134c26b4f5a3c0f8f3637f6d58c38d41a118b61920b696285a39ba9f6f01abd762ba50e0292ad7876d38f6702ff600ff8030a0c6fb5f05379809238bb5dd24b288bd77baff675443a597b60cc5f6d551a01372cd713e5dece897055a66fdbe3a0aed1cfe3e9d6e841616939ec1d878c197dc5112f44e5044648d7b6cbb73f2d067af2869bd9c5334fda8f1b797e2d5c314ca80037324536b227543b781b5585ccf1936316b17f4300ec12b0292b52293652805b1785585645fb66ee6335961202b82c0714e092195eea1955414b31ded038f18d39b815a82d02960eed390846c6bc4313f1d1e0bb046f666a00b8c6f6ce6ee4db56ebf63d20aafcb94ba3834b23f6539b42c06b48c77f19582feaedcc8eddf108ba56451a9d811fa8f3d31ae848653aefe81c524fe74d7b552227155d034b29ca6b9655f4659c9e11eff62c62464b97cbb89dcad54424a3f9fafe1c9b92790d9c369589b082e0d24a48831cebcd3d12dc5e41b89657a3a632b26da68fc1bdd65fa5f49d0c1c05854b51aaf65f412546439f589d5b88519622459ed7f407fe8f32866d7075f75393a4a6ee6b91cb00a370a3569612e6998098eeaf864bcf186d47c9d86099c9c7334ffa8cdcfe7533bdef94e6d0e46fb203733c16624c77323669577e7826b3ccf01ff6efff7e3ca91121be9ef18e9b1f3f146465b4d41aa8270f370c756d9668dc4fa8b185a3f53fd895d2d63cd91f83a4b03d00820d570139e3a5f67cf2517bc1316d2c38723099e5a341a3f47767b78ac605f89e88e2ba6890dee58c69b904d9c862ab8eaf23ab5387738b42382e34b6a6caf2e77287dfd43cd8a2678f18d6a21b5ba01bddc2255b503de2d7a1526a9d524c7c2651f4dd99ed18ef2445196a9267159c4895ca15e8661f96aacee60f8ec0f83af5024286c798e1dd9ae0f8dec498eaffb4ec6e8ab478926e6a9ea3e61095d07730474c45e8ddab288b0b7282fdc2251b7af01ca1c28e06cdacadb53c6dd7c177b6fb633da9f21eaaa4788b485d0ea5dfcb354e697182efa5f6e37bd27f0f8049161859e3c1d60206008621d7eb004981fe04ade173958c81cf967e22f92b10d36777aa39ab2781d6e62dcaaaf0f71bfe799b5e20594ae1720549904b135fa5465b49ef4eb9b519cc5466c83a06872f481de28bef4a09d61fd88cdca42dfd5152921952f79bb16105623d555397c6c67cfa6764a3e35b4b3c88301a6f46c455c42723b970e3704b9a6a45e5f5aaffcf66fd269190dc701ddb1ecc1f68ebeba7d3544b40b98e8cbf971c5c336f6e603915a9c3204bf88d1100c7fa024559f090e4e7c0af61f6d8687b6ce73d906ea17ed20229921c0768aa2a6c25164f122f1d121ea991d20107079c3b8b65a31179915f9554e6ae046b4adb282c2820d6d37419292c0937f620f812139b1a986db3a75e1f27572a4fb3275a8019a0cd8c6b6394322a3d89ebefbb8c788697b3f529d906faa6e80db418a99821fb4961ee42b61d647fb7ca1928f69bbea21f698b062eaccb40c17d80dae50780b6861dc5b42579aee81eec9e9fe3bdf8230249ff3f6e8f2ecfa4cec11d81190cb5341bca50a41ec8d318a288930a04d18b1305bb26b364bb7f758810b19e3705422a61d6afdba4914fc1e6b7113423e3f290c5704a485e01c2b095536a706dd4e5c492618f9d0688b956923cb6a326b30ccbcbf03b3fd9c79e74f9ee05e456182648dd22afc1b0d39e4d9799593e8b39dd91a1413e1343a43f3a011b218580e221264ae37977c7ebb01f9f32fa2f5f3ba1a10b0685293d28f032c60bbc001daaeff70e79297f6bd87c32f6514c051a0950e8b1cf2f6eba0eb8dd5c1d18cc1bb2916592b3506f7dbd154f392778ec23a7d6c02cff1d0434a72bb6a46241401f88d1fdc534b9d43d58f919b281f784a0868c0f5f0894c69015759a0af54835a9eee9fe2b6d03d3deac09786fa0a6e571d3105bc3409c763ab72cffff290f12b2e01e0f616ac916cdc380fbc12b348b7565491e88dceb9c77b06703a265d7ea37d8d1cc15c91140fa146278528966fb70834e027d31e4ae6da98242ed4ee0e4077c7f9d81dec14084c11e2351665618ca067908de4472c966cf42adcb21d1b70570615e23d9438e992d5d1a19664c5bb02176002a0444b19df4fd238c1f8c366c1be1be49134f47a10a404e8155952b0e76013c8206d0e56de54b32d39468620232b87db5eb05b059d6980ea459caee499b0040fca68d905a8c0fd6a89d47cd298d7fd353454db73eb57c92a4f5dc8b47c0890596d01ee82bb18a1464ceadbf4bab22e3d29ca223f166b8278f665ce4f08494af301b9d87f5c1e17c57cc4c06ffe63df001c7022099cf64bb2a82a099db9e3e450ed9ddb1e2952ad7b73cf9636aee448d167a4e6c010781c53dfedba8d505319287ce7a7c69251ec7f8e16ac6bddd4fa198420cc6eb9d218e01e8ad328fd7f293264000d557e61a3d0cf9e9d74576a314bc3639bafc11f3796a92f7b4a86207686a48af7f8500d4544be7c033d7e7a43475826aec5713fb3ff7d1624dd0bf11d7b8e33fcf3857300c6504984e500222574b3f8b242bf695de213f4e01e7cbe9e141304788e7a7de9791bec506e36c612ac51949d48de5aab038607e4883ee24ed6d5a28adc8fba7122e5b195d79d9f02ade2e52d2ca72a8ea6a0dab689c4470721561f88358bc0432ea2fb9c52f26bdf74fee8141da1908453a5676947938de6ecede4b4f5e7e3cfd4aaf6c8a507ef7e43eee4506b0ca71c91fc455779e387369cdf3b0d42836991a226006b96076e8b1a507308e2bb7072078fe27b8680ed09ac222e9d099757e91efc37e395d645e339bcd3cb3b7c68af51fd5e21ab35b805a2d6897379815895493475becb2cc48664f07f75f04fdff31a38bc113ce40beb1c7c83ee6ec721e0f4a06f3fe18c3b9a4e7788883d8dfe93cd289958582ddb503ccf4279be6dd3ad7e4fcd31e1341b859c388ab0dec08cece46a587dd771c1067d98493d49a059a06f3bdb20ea64dee0ccb68d8b8504cac7ec83a76d969000c6faef18167ff9f4938f6968c510cf4fd3a0ac06c1aaf5ee85de1672e4a6934e7844e799ede9374edbe730cbc7de50afb8900232a9cbd28b207f2b4797d2559541965cd167d1d99b743d4169654b25798b518b27d3f74a931e51dd2670a768601205842c6672e673ece3e825fe3ee96ba437f43391ba4261151c14db34e538c8e25dfe9c2d808b386286cc7e7a220928e8336e67a7e42eb46e4aff4ee5c2b525c62327d2ea9292c3108f6f70d44857539b97b56709fe01e496082dba98c51c0c39ce7a4da4ffe6343165eba96f013c56451246ae3500a40751378c3c69ad4f0e7cc3ce2eb4685549b7f1399bd91312693c0fca2e556cfc603f0a0356d45bc67bcd701b52fe6a16b7038b316d84424f24a7ee0d2953a77d69a0518eaa9914a52d8d7d028da8a76bffae27a7dd71d6e25511e0f2b1b63c3cb78e36f28259d1fe6893560f3b05a97276fb42383d98285a056db6a7003d7262449128452d6a25acdf3d442d5c81649159392a53ef5289826d3e7f7e826f5b9d635ddfecd88c3702b27c1a957844e60815091f75f9a9dc7e8473e7a3c5135f16ffeb6a5e5b651673ca15495fabb8af0b01dfd4ebc922bb8bb568f5fdfc91a67b9b2248408d462af2a5556efce65f4e6e1fd1e2ab46d496a9b5840d693743ff775b18cc7620d05e1340aec43491a09915744d6e4f171125b30d8b702dce7c9a8a643b589df8da532d49156856530b2b0ab09f91a8dfce294a7a25eba0c7113aded9ff478e541488279a0be65780e05c40d18a88cc07d498a4e030b2ef31d914a14f3a5890e10511fe240d187ab6ea6776671886526aafc65e136bba53ffc8b21c8585aeb7df04a3356499dc3ea0cb6d96e73b5705b8ec0d880df26df24bf90df1aac5dddc2153784e10d777c93f6448c3a14795612a5d10c05a29a785c20730c047f5c70d1d80a591fa828229db16a256e9fc415c7d2d6da167c1741ffbb397de2d99d4ebb3bbb363634945325b10025417c910ba2826793f5e56ad249c09f4b4110cab26840154003422720faea624c8106f0380b9f503b9726388d8f8f8231b28f85887caebf46615e89421d8c1365ba959d48e2614427118ce7b5c5efc6228944da7e482c31f1682b958a1c5db0466a396151cace5d161ec1efd4ad1249111ee16ff947bbff98cd4291d02dd5429eeeb611adb8910616d68b828d02bea9eb478249b07424ab2123b452b11df15148d15da7a9992ff9b9d046de60e1d41cc3096ce535b120672368ada0bde561fb9af91377bb4f3e966cf5dee6cff93e978abb18c57040a9ee46ce7b205f2e1cfe48d3caaadf569693e92704a033e5fee114ab27a1c99721c24ca7c06f2eb1a5f1c2ff5ec348d174f5c96cc6206b9e091592516e03999877103db2875b0e94453c51777096b32844aed0c6f88483c27119a486f47dff2dcef57cbb6900d58919e5124fac27130c7a2125be3ebcf5441af46e8b28a53328500ee83bf30b5ab78cd1f3c00e49fd3b904ea12f816045a42a1e582ec88deea92566cb49e8be26f810bbcf237303d2071408c21a084e69d7a11a91326db99bf2db2a52563bad4deb1b08530735b351d98375098f5d430dc72d722778f2e9950ac57b8b75596af7a6b181fd6b240abc98ab7801b2533b0e682a1408d0a12dd0619203c246399ffb4800eaf72033343f68daf9bc37ed45623a8609aa270ada86caf2e296208b7bf0da7975a2a4b32ccc2ed059cfac393208b9106a0b350c986956c8800b80d67f9bf57ee8c6b5d88c7af86342db3507765b302fb87b52269300359f2b74ea20023578739d55e486b0935386188665d8c805e50cc60399612e4f48d9056a204fe474c4f66b6a18eff15d34780d4d994057f3c2a13db176503adead74b7d21d6028eb21fb913096f6ecb2616b12187367ba1dce07c7e9014357c0d0d141fa48335297e809aecf6a3c9ad0eba207925fb95acee92c7bd7b2b4773d38552b974a8d0d909b2608341a560795ec707877cd395669d81e31d78adba93fadca47b2d1284a058fbbe20f5a48c4f5b33148646c2b6a969bec68dc581ed5332ef9779fa804ed28bf6446ca18ca8e72fbe312b5f2a3c43546b709341d02c2973eaa5d17feb22140f0c6d340eb46f7eb884f2d2939ec974045baa352513ed9872b8923e66c9948d9a625dac5c3eae042dd518858e364fecdaec8c410c8ea74224b5f427f5567ed61eb29ba9976a56d8f898e4120d7a460ec1946c25b505837b79091c5b03d98917b575b3cf5699bb2abde5506e95f487cd0c114f1ecdd5a6a906e1cf2bb4abda9c8733d163d951e847a454e86b34822cb6f8be4380f7bbdac8f8c8402d686e3ed5e80b684cd83aaa44313a4576ca4be763e3ef94bc1854c6a3040597f97e6cdc1dd95a48e3f5faa5610e5a3747bb3ca71b7ba5bd100ff4fe32cd8bc76fea3ac610215bf19b7acbb8df4b9fcf22855b8283de44e37490d084bdf37a3e60d84e58244d27cfc7953bc316eb25f304eed22e3665fb1c73bab672f912c1d0a176751a06bb2bd5b6f50a9235b5d0c6272c087658ce1906bec4a4d5a65e1f3e9dcb67a5f65cc0022dd436741a4a7278a04b8218d2b6822341e14845153207670a204df1d1d3bcc4b4de0bb7c3e6928a2a7dd4b32bcd2edbde7d4728a93a1cddc95af499d42c4aa59bff3f1a29776d76867491705d974ba33395923ce65b98d9462ef54c6420cd6d0f5e371dd5fd58b760d58e455ed6977ba3931261f0355a70c1cafa7ce8709bcf2e21885406f6400be5cb673fc1b978e33e7b5712f85a40e63410f37bb0a6894d1af5765b18bf0de47ae92e98ab8f5f4a81d64efe380ee14176009e0dc32b5da823ffbb836411a40d95ca1d877693e44c36500fc5f58b153bcd57ca7d6e21da3ccbb6877cd2b7dfe1b70c528b645abdf396b9f5e3b892bce6de0e94ae2118f2d237f49085e0e9bcb8146e8fd601066c1acd9022730ea54f908e7c5c0d2ecec13ee552934f5fe59204ca7c6be2389c287369212397a8bbf14ba2cbce17d6c621ba393976ae369190ba9c587c2e5bcabd3fd3693a851254df2e6453ffb5f149e4903913a10dc07ef2d319a7f9678d8326b35e73b37fcd272acd4f69399431f4582cc6d9dad092bcfe633ff3036aa670c2420185cf001a672ad91faf57d1a6d5750faa0a985d87c85538013c2c4c50498f02c268af4e979e0011179f3a7932f604e6f3d71a920824ef23578f3bba9282e6a2796eae4a2e7a8f3f82b465efe4a2003ee67029e8720ff4284e629643b6c6260b2d2a175805f1656278bf29ea71c82de2817c88133d91ee7d6359f122c6e50e105c55e14ea55bdca65d5656ec1426c04cba725702c3548b531b37ede8c430e8d6535de0583e15a273abf80bddb1bdeae67df3125dc8d76d7cd659e33259bf6489adb949bd47e240124ce26c4ff46d658acb9ef23603634180df780aab4b7dc0feb7fdc3eeea5fea7195d97e97ce97bdcd120decd9379dcc7bafe15b85d4b3c087b76ccafea535054d100e13d4af546d8fb82ce8d66f50acbabf6a13dfab02ef4924ce2105ad6aef0ccb9fd9ffe8a73a79622eb132bdfdd109e385ba26a418f67676a1c1884e708fa15a2cf727a6660f68dc449338f3b7ffe975c6aa9d31fd518c9b5377cbb0c5e359c4ef4e90839cc0ba5d92fb362a00fbb99629518398b56ed658124dcb8b8395c08e851ffe716a6baf0584eb91de2006a14730e991a70acb295930635ac9d0d37b24f930d37eb925f9252b9c6c7751108911907a8813d732f802c086bb7f2deda1f49d85ffb6c6114e5efdc358fa2f49896ae9d448ac33be1f98b92db329c1c7b874c3b02c4798034b8ffbf279f42454e40b43a7f99f0a975d505fff3481429f5d7d837d635637fca7658b3e0532006a4f13918c384bb8e03032b24ac50311ada9cf5db4f8ddb50ff78a9806798ee7cd773a3997788cf98e4220a4bfb92980e64a2e633","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"947a9afb3dcfd60ac640eb95f8551943"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
