<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #1E242A;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #1E242A;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #F9FAFB;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b84275c26e6c6152be89d3c4752588b62c5e1ba1c6b9f50a9d69c72510f50fe893911d96011ea17346e13640ab021df0e7a5e7590b0f7052a217bb5917cd457ed958e92608deca88001b1cc56f75001bcb5ed3d30e3285060125827a8d72c67f4855d53aa3c09507ce05c62e700e028e77f477f4a2748e3b6fe55fd0388ee8162584124fc02ed3458aa4b5f884fa9ae782c7f985e83463a657a5454e973174156cc5cba90eff9b2b1c913e47b86a27cc8136b2937ae82a48eb76c11d38b55688f7ba0c4a9c8bf649c16b13804e0561ae3cb02e087af4016c99c1e29d393f0d5ae8990b7192dc06324e92f374543d9226a4d7e028d0c75c3c35cccce7600a770b7109aa9277b9d61d4405b179ae8c041c40035bf022059c21ad45ca23bf92f6d5b1022c851085364ec568e2f310e31721148768ff1735a9656bb703d5d373b4e95b42b45d61a3beaca4cf9850070678b85745cfd71ba8a1d5d9c6f6e32958a81a97423606e4619e92d9bdc55d6f96e399353198c0bbd8c774f206a6e993a14813b8bc7681132622d28da32a2a5e5b2573901ac363b311c3f8b80be5e14c1e10312c80eef1e2cd5696ba9aae42067403bc3bcecf48352680aa2c81e97e97201924a7d1f783fcd79772255ccad5ae6f1e1d6087be4e1d213eff5f5110ce45fe2e709f656e3ed57c1b02228de856431b563980221cc8a1f44ade5e76411d18a427cd97fbcaed9d9322882866dc3c4ef74794947dcb6b6d425e844b9ac0de4a731cc954f1a9779c2c7e98702a79627e6df1780b44d5891b1064e2acc3aedab43fe01b6f72103ad9164e0c409516c93d0c1c287843356d17e80dc2b870c263897860dc6e20e69fe7ee8b776cbba809323f940bb9351c5bc8267a917310f14d09f0771269fe892ebbd1de5aa802a641871dfbae1fb66e58a9e50376814bfe799cee8fd436f2afa761388cd9e4be707841166138315079eea8fbbbe75567a6b53aed9db1cf2168617d8819f65f9d7f0d8e765fd92a1bfcc287772933d2a17d366db76ba375b5e8f572d20a689cc54e8f47407ca32c026a4feaaf1fb5a6b92d6be0344a719a83ff5e631d930b1918402d5d6ef2f77161b268243df94b124007822d49812f48df958940b55007dee371cf286f186f6929f8bfe690dfd88914ea4737f43eb26a4009e6cf407d0a374b0c58fc9280941377cf1fc16193ea381b2bb937581aa278c932cf4622e9fa7f48c07b88ffdce0b8556b785740897a2757ed3fc8a09e2c6f6a73bf21a7f0a1794896f4a5c995b20168fce7e615dfad357db798154074a91c0e502260b80265857175bf1139ed6efa7171274da67e458fdeceb1abee643c571ae9da2d2a3aec14bf4f4f0c41111f2fb1e2e2500c20c3174c3cc3f3e1ec610aa1e2861c9bd909178b555522564afae7a511241ffe8b2e4aaa6bc2dd071942b88eae4eff742aab3c01298992358c09ae2a9a93e8f1288305cc76a70a75a3c9f9b1a8116e25173375d8ecc0a3bef4a6c454fdd049cee97087835ff2fb399e078e1ac9b4646566e04f94869da64768d950bea111e6d2557b904fe50f615f997dc13161b45d271de14ab4563188ffc0a21a0076c3a9fcb33619185cea60a9e4630839da9f88bb67aa96bbe218eed29563f0d8654635a3f79500a86992a8b380f40d4d0fc74a298ba24b8c7059c2269e174b518d81464cf803bc2c956abd4d0ab98b6a6abcebf56f7f7246f219d5d84d51071736538cffe822cfc2c24aa0b559be3256051d320eadb79b16421076668d34899fef326971ded6f471d4521e23901ca4b5180813158336a94b8b1382620f963f57ff86f8be30450197f97914b9a27b43e033140acafa33fadfda670e6b2253905646338814ebd5c59c057771446e05fe6cf117d07dd4f62afa1e73fb8fe1bb40d943ded09654a8c4420b6ede25bb1901a4e4d5e75f88fda88f8e2c32adbc8feae47de2143ab463c648fe8364447f893bbb1dc72323658dcaaaa497dd3e2b160bfdfe8d1e5f9d2623454d6874d63139fd5da36d8cc1f1ca47e6f139cf7fcfcb6d4b20d62956439e7252719f5c0388c7b6dccd4b5b86fbfa65c5d7088593b47bf33380ff89f1093fd23ba4f599412fb1e0b9fb332f28db629be23e2278fad8a0a14b3004854bb0d256bfab6bbd0bed79325409e301059bd15f12c7b9f6a24187b444187e6d756116e8e5bc9b3c63a54954aee21723295c35275050f81b29a99ca92a846cf0c31ca4f6d184667f254904a9d98f58d64670535d0ed9875d587544d18afcb31b3d863e8e17322f856c6014bb9f8644f7eb8b06078d2ee2c4d64924c6a2aa4b5e8939d12d9422ce6ea89edf9c23cb77cdbad858b0a41dc6e9cfa91c4142e01381aac005923f692eac3b4aa80fd18dcd1a91dc1139be8a6e028beffc412e38eaee7cd779f6eb5560bbb5c5f9b9fff1a0167f3b8658d9291e1f65721a404cb28757da78c331b27da41f94856066a961346c73ab584cd5bea24e216963690627dd6441709926cfd276b2b3fc07fa34e602813734d34bca62bf0cce7b0fdc2bbcfa0ec38e62397bc07b73b7305284c77002cadff575b2029b988c967edb7f820fa57be4325484663fc1f9f5cc58410d83385b821d656b270d88fd82178bd22f144bdbcd22919e70c7fc9e6b515a58aead795e0f7d481ba1fbb4c3e6752e6ab534ec5f1b165c142f31b89e61b4bb1e5d19dd866bf09844fded73cfb3c8079e84768cc14252179be8ef8aa6ab1481318ea506ae6f7d190e48b56c28e7e0d6b05d0f279f103dad9acb0f944776c258eb1f6645f05e3b84ea1ff7a61df447f294199160894cfbe42f2648ffd978a9bf9f65e4e9b8441b22123f200b172d5dd36db11d3fe4a549813997591cc70b01c6bcc67882c2c695dc4439d097fbaeb6ee83ffc6c7509d280dfe1115ee809d5e035e1b3e0069a64e33d15857cfb1f94bfd503c807dc1a10f2aa625f448dd14a57bc974805b0a126041e469971d2f900c1ded05bf91e1ba6c0000588655c4e188ecd0f3616a3abd36b5da4888845e39498295a93922df505d4f66605217abda9f1dfa5a322162c1aff2718c1e35d6b155750280e1c710671a7a630bd65b5d74890c8cafa885d9016e43f99f70a04067d8693d1290035ec4cc678ec36acae201a8064725399d6c9f3bf014f6bb6c19b51bbdcd71fcedec5ec9ebd2faabce50519f614fd4fb6fd7a5beef264cc1c91bf428b95a7e1478b96b18ca6f22e1dcb24eec32a0d75f40c3246d99aec6699cd9a835b6cc0e0a12ea2fbd227b4af2152489e37a74a07e1048545ff61aac22bd2814c109ab67378a8440376a6345eb4757eef97a0cd9d965a25ccb683e78bb0362655e9b5f23f76b3445b9896361ddf59bf68f5cfc441bbfdfadc9cd86fe56804311209e5858f0c4708c543c2a486c8db088e0b0a6edb788a833c2e24e184545f2cca6acfd64c90b7a54b6d25f3315bc969c610b9c1a4030ec532e11112f6efc64ad3e36e964abf8f5fd1fa52fb2e292800f56aac0e835a6954730be947b154937950466945cf52d2916cbadfb272bcadf2e1e4472e465feff7cf00da156d86ef29623407fe362fbe86f2dc597eb9c92fa5bead2470e09631af044ec182d4dcbbc40504fd00ee42cba7a313620f6a02b23134858c562674482bcc0badd35471da7a88efd7ef5a8325383b282dbdadbb212f72f2685c08e11aefb773562d6acef74f6f797f811782dc17bfe854faaa292d042940fd36e6f098923cea3c7576ffb61b9d1ae064d3a62e925b15be4406d516c1253d3558d614189566457b9536a60bc602e5750195dbeaff0c64304d618b522d90d707ae114a4654a26ecb49366a80e6b40fddcdf470b43285a668e1f1035078a897ee1b3cb52094c17f18074dba005a5b86fdae11b5d23035d431a77c2afa99b8f4007594850e4713ddf33b93e1464990f0caffebaab8c0622dd03e1f1e9d2b3bcdb6ba2a158a1644449cd3ace5e3c30ecafa07386527721b9e68c089bd9e1a20e87170326bafe0b4369da21ef2c6db6b3378c3d56f11fb4f7f64af0ea3458626654039f202e6b81831c772e5addaff3527782345aede3349b7e7b9a3f3d3441e2192db68de354b882752e89d9682ad573a19ea1767645adc9e5ed037ade525fcf477e6540d201211a785d60cc03934d9b589abd38a6588365ea33a9c266b5bee5ed129787e2bcf0225afecd34a3ab4ded5b1f5b5e3b510059990f5af965c9cc675cf3b61b07b7cf86f960695c87af0aad7d2da6eaf6aa4656f32146c864e12501be71e6f1a616932177feb2376c594f6ff029a15dbdcfc4978a84ec736c81dcfa6bead7e637d3a337e1dd92f9572f69fbaab8a8bc4a747a0214cd8994224f46d7dd6dca4f87f5c41a6ad8267de37206ad2c18c2804230097af049a65f73cda96a3b2e1d55a1cd6e8a158e6c8ff2c9774f48385454342f726055b16176f3e294e22f2a5e2d02a7927df940ded136829d6a45bbb211a4c2f1f39f04e8dfe2ccc2a6c5183b26147d95b8e7959f5d08b0e2ed6776aa993a6eac5648fbc4beffad00ea8631f9c3b685b84f61c7ea8a24bd88e40ae374fd31e11d232758ef8c57deba048ae7de43f43f0a02672dc3b2ac7d845ea317b3bf40eaf6d2481e26691a993d4838081f1b057a9c5e8e609430603a9e7243440b939c3bb0e9b7a30306ef0376f30066f0df2f1c70a0bf1792834e3cbcae99a6d85082b70cdf7e844916fd767e4153516bf94f42023a6816ca0cf9c092f167ffde4f36ef0473ce7e67fcb9aa65322acb0bd8cb05e791e81363199759ac83e45e748f538696740ad2ea51d7e209e7dd9843fbe18484811bcd9149173c91795b93a7e1fccd0f38e003fafb7213092d4af98ea72a6d8906b9f625854cd389ec18e16b67c0e4dc7e167831a5d59d2b0c39308042bde813f6e4d5c613955fe911d743de7e2891ea27e84638e9f1b658765f67c25c5e8d31450fce090d2dc0936f535b27fc1ba136a196edca8245c91fabdeb2997a8b8d51459d996061de7fafa6de32de9fbd4a05effc378fdc42abe68c102f7647ee7572680b814abc259fc8ba46b80fc7dac331f9f49fd2cfca14fbd10df4407368b928fb88b3f60cbd7af322987e89ea646dd4e078b2baf834981eedb538abdddcd079ca50db0d781e119096c6dbb2948685323a209b14f657705c6b921960e8a2f91c9b3f9475aa5e7b762000c8d65a9a7aae5fe1f91b46240bf157cff77eabe536c30b6fffe90ca980417eec9fd01cb108d6b5f1e55778b984f51596352b87dc6032a69109afa5642f8eff48af2dac1b41fb50dc1b467a08d0646a1b8374ed1a0a25c86b3e60316762c470b0ba863c42e0a3c9308f77c317a32c6322a642134098f6221bf5c395f48f5a7eedac35c88a62c42d5957d5b07b013e03dee5e667ab2128e73e4d0aa90885640d1dbb238e64b2549108df07e892797bd0a366162cdbe1199aac4f7e122cd77c3cdea16f99d050eb96042d31b062dc51a07fdf416894cdfe7ba51ceeb5fd49bfca17620d98f040edba9d7cdf9f98d3057e3ae4ec49ca8667ab0a8a78113381980c02244efb0ad29ec15c8d298ca296b45e8ea59ed060e8e85a912db41b397e1d619f53f99469e4dfcca50411f2806aaee0e74541e24ad84d51fae3cd12f4055f735853e4704fcca31054f2936be388ff647ac56112d07f363ac7ebe39e47bbd0a0a9c24c0fa2ddd094328d6a799cd0dcf00c321bcd03b1fa5e000f8cba5c2705c59fe7643422679a580c4ccb98d7547204a0c061684484504b75ebdea800f2e183527751a5570aa6f2529710096cbe173e091e8e2ea2582004622e3e8212d0cf1296312ba65653606fde8a3324fb9e8d3a4fbe41d8d6858b878cc8afd666148343c000bd37112d6e985b1b503ae999f31c625c1bff2aee8f45734ac64ac090ccb6237c46ede05a7201d3c2fb3ed3bfab98102ef70769618bb2d120aca21b05cc2144f486a9221f4b78bc88025288c386e872e0d637088a632a2c5fded80fdfd2096c22a0e72f5c249e7871e754b49c068c9c015d7318fdce9c4b9e9f6ef1e5fa74d0b9f5a88ef3f6ee3a7bcb00fca3a6cb36aaef3a762204b0c072422e9e0a027ff469734e0b853fb10a8d46a88630390e092af64881ab29703c316cc2d422657b9950d3eab7521add5edb70a2dae5b8569b9cde36fea769c9abbd537a8c5e254340426d79c8b71ae43fe9295008433ad7b1263ea0dce07e7317851d5c8fcfdeb31be0fe5a6d7cf17908e8562f8035a1ae5597b21e225246b73b7da14cb57dedada68b98cb4d2b4217e151044580e2265128bb4b8191fc47d599c653d4b4c7debbda18a873c6eefe07cf88772fe0f94604839be288b3727fa993cb99b09d496b35794b6aa308fe301b9b718ca90fea0fac4702c4b146633cfa4333fc48dbdd4a07b1c0f27944c8fbb633be0b2e9545cfd226b73aa90a703eb5888584bfb41d6b798f3edacab27721c7221589db6bc09e279b7474999c81fd00da6ebad629299f32b1c1214ed2cda6d9a054d095b1b201f2e2aa36b8d917d04d710bb4d2c7b3bdfa647b0b5b197a8c2bd4e6bcf0a148e3bd0d494b4896c25cca4269990d8dd93fb2ce63ef5e4e2b2f7f1e06036880e38ade1f460dc6faec5b2a74882365349ec8f3555b9678129837011a167396b59a040e080ecd2edb266e64286da2bade71829ac70eeb5d920dcf2b8a863ed89459d8f6316fe806abd5927c68731df6c8005c81d5d5a810af4c89502f368a3e49b731639305489efa4c95d707b8666607179b77fde87acc092f565cb846bb075d7668c20d25f077cc5cf5ee3a746be8fb45e2f3970f27a6d9843c1200fed48d40b14972616f20a2c369ffd11fe1efc28a32e79e73db10a0430007aebfca742d3fcc02e667e5a6cfef1311d167b02cc12dd9ba8670123ccf0725bf386e3f205c067c693a36f564794c8de9e59dc4cb587798f2cb998a6bbc76e73432d59714f3ad23b7945e437d9ff9effbc0b5943bbb7a98330271ca41a6ae51a7c445ce96422158c55ad9389b8f5c77efa435a8ca5b85bd6dc714f5b5115ff4bb8ddab637f3cd660794cb33dc4d82be96daa6fe8ea13080d6ac8e8c3424af7d2859779f2e65136def30574e6ab4685e82e2a02ab8e0bedfa61ff284719212a280d2566e22d24a4ac97e031c0f102977e054158701046f09aec36f8db93453a63db295a1d974f7da719d4c3981c5b67fadb836b65903b07aff631f0f7138985a618cebd25f1ecb1736af064e93260aca4c8ed0d350051458ffc2f08c854543780bf9d1ea39f649d4fc48d43b523efd049cd05b1f32a7e0cc2444b9fcc4c6f2ec092425bc692f8b6b7ab93cf34cfd7272e2ae4fb90d1562454bbc1ef7b0c522bf0fed925c12c589312a83e22b4c39cee6d21b226d1a1fe9a8ef9daafd782d861003a7aaf45fc523a501e27fc0497cad9042f9f8597818f765e4a5d0cd7d98da55a6b088090d2b2a899ee555fcc994c22e3fb6736a25b9cd418238f75ef2e790f0d7e08dd12d681ed592b02c13dd991457506004d352170ba847309bccfb0ec22084018bf185f1fec61875504d811910169a2d6034dd59f34a42be53945376b3e56fda403e07fdb45ad2d665b68984af5e123da85dbfb21758cf4ec69d24c10d1fc00dc5b0564378ff00619f08eb5614b265a0dc6b9c76c82341dca0b20605bc659d68dddee32e095de30a059611f4acbf8b33739ebec464e253d0d7624cdbca953574a119b8de4a8c099a0c30f053d2bcb3161ae864f3182195f43b9ec1c4a8ccfae7a7ab5c7d1931712a9aea151a578018d7f7c5937698bbb30c34e27720d61229519e2b921c8232debb18bbfce6861cd7e2991a47953ff09c568826ea812b5f0ff842e3e0d70e99ea7e7d19eac345fb9e8e83fbc861607e8174148ce0fcc4bfdc26da6c974dcc834439f2e026ad019eee48a1ae8259a2b92ac5389025be0dc263f833c6b5575c1263ee1b2930a919ed067eb86cd2f7e698695b0b7b96f0b95e1068f0d5be668828b43686a08736c581ed3aad02d72658704da2494b3d04551d6a23f26c54306702503e4195169ccbd7cda2e87915e1d15a68d7a1f3fe6405b19c33b3ab410df08a760db28c1ad407a84449113be92849ab758c419d9a268d625264fdcc8cbda2b60d59ce88c14d9fd006eefd75e99335a4a2bb77f8785da258b9d1cb521983160f45ea3170eef8c0138e2c42d1f522eb44e521f73b1b58d47e124340b1ca6da14dd07c3ba02da47ff55266bd658b221a731ddf4cf8d5c922e6f5725fdb27149da7bc8e6eef211d9d6c4dd9b2f74651263976a0b2c236b8876a70615151833a76740e5652e9169744e81e16af314b1fe920d8d57acbea5e4159461cdc8ad344e5b89ae81724ca3c9243edd66cfae3efd52579b1d21b39818703efa8565e68da575a62f850860b413401e7cd0529eaf1fc699a5e9bc1d83b580a2f1b4a1c0dd13ff6cd6f2ed45f44b03636754d6d01af6411dc4b058d34dbaa2ee69b97ec8601580cd4f684103297e9bd598a185c1f339059feebc9f3ad9a62b0b5cd79f7a74fe70dad48ac42e23228e4a3bc08cddaab393a0b1137cf0192c79b61a7aac290bb89150d46c009d2a8a21d7aa7c5e591f842fc7ee3b57cf4d62a4c2b81c1df5b6828b84925d30e42e2108c6214c318d3594d2eb76f749aa48841acd5d8429067cd87e418b7c7e1ee90eee34bff222e5fab4136ca308c23001ad9101ac9ca7016f00271ffacefb73121cb7a247d18c859b61fa9983d8f18341be590b75ae229c407a70ac4f383851c0c18e96259c6e5dbc036401a27d3749efe2a6ac8b4b17d83db95030c4fcf9ed171f33a64ebe44dfb6b85097067c7ae8908bafe07989731c8034920607a8f23f2839d2ab014869247273282c73a591960dea4f2bcd837b83ec9a00f321483b8a88dd83f9ef791b4c9e38b91d33e662938b753b9d800e6859681dbccdd4cb14f4a3a791be75828a71b3bef88b2984f9b7338a3e3db961bf3b758b6716e30e7194b0d0b6267d24885f746444ff2589f5697ec72cbd4cd3240f0ed249690bcef62cf82ceffa993e3cfd41bec051861142d9dc4df6b883b8c6e51c618de163e2083f61683e2712b66d4933967ffdab2f621df894feeb444a7db77b4fdfb00f4c6cda2e5c34dbbd2bcd662aca8b811de6229f6aeec162a9f4cb98810f1ed45f9ab164b79d1907fc0eff81bad2a7eea42e17a7b19bf256e269af8eca4692557b9bd2f2608b3e9f117986df9f4ef23e37b14fd1c6602916a3052b0f989cb75d4e73852b91eddb96b3af76290971c76b86558dbab46831bbc3e46d263b3a93c55c406031c92012e34001bc813a8179650888fe5209b9fa517d4cc5fcad5fa6fdd71632deeeae4cde263ec67d1893b0346dcedb4bffe1f4200b70f13877904ec96afcca4e690ece570faa0e9fef5152a2c0ab064b41b83051da487093ce914a9ce7e4254456e499a671bac481f537c4583edae6ef0dacc91e5c16bb6b3d7a053e632ce6476748da266c4759885bf267d0aade2e931241e8e234453a7d4664f5c8435ccc94cf6fd388335d73d3bac4f2d07a9a27663835e08e50d39743c03373c14114b2b0aa5a0ba43f09ed31110a3d4d8141619d961f8c72cba3b4ae54202d53f89344b25c59e4a9de4df039824d0b27926d031e9d105a09238d036810b3e32ba80d7b34a618dd248bfb0bc7bdf603774355e2fea4fa7130351ccc1323b9b8d18f635fe0013026c4b4a05766be1d53255f923c1e8d92f2dd6a3eb573bca5fe482cfc02faee780604fe1d0b09d68e27fe4be25709786bd48a08d974a4a9eea6755458a01f8fcd9c7b04d31e85d57a567a4f056d37215694cdfb1d0b897696dd60a6ce9f1f809ae892fc2b5aaf68989b0becbf9e0199d59fca3ba15b197931ecf92a66dd78341142acf6fc7d6054ef37bfa37c73d4ead89a6e58daaf3d43361e59f59b269bd46c6942f8a55a96bf27be3a6795f8812a388b545436d8086e6c6aa60fa62b77fa1512ad719b3f583c85d7b996b4090cfc6c37bbb4355c52b9f663ed520cf258426cdfdcfb5b7d40c146fb0acf842102326b64aa765b09a250fe7a15a3df74dfd5f9ac438f7ab9bdb45bf3f36711a73387cc4bf86e23ef791e5ac340cb46d880b799e2c47ac9605b41f6712ae2295278821900cbdcc6dbec5c3edd9cadfffe970f949e25791fe2c82a9b64eb68f303d9b6e111bbc3e764d972f39e8cf86cfee9dfb61c19ea537bc0c7f08172c962d94e20c24b20c60e068394400847224c83db4e877aa65dc076aaeee264cb331e27f4245e24d48a9547ee9862f776f6601af93256226d25d6a2b4b2e70fcee14c2f09cae9dde2050779edd6c089b1124fbf612e6b5c0be53e5f5b24f98cb80c3bc397d6bbdfb0e781c09419bee979a2275432fb23819e79a52d9ae9300aec993162dd73712eb625008759061d790a779d14f3a18062e42d2b8674046cc92076a929a2c972ffd4cb6221cb7763dea9ea9e8cc0b0e052c37eb1f57b922195767d5a08c53be6f8ae12c823930a4acdb0269d9302a285e9ff475fcaa860a0b3cb0f02bd75ec44875720e6c8d9487db77fab5b0ef3e82b461eb395c0ade737b97516bd1083c3a062a48ea5e60325b1a9fc4f34dad38805ca590d002cf09a2dd983e66a2bfc83bddc58c20ac50fafdcd74ae00701c7c548a38e1858b0f1ab3a4e7e126f4f3da51818aed076541f72363b3cea6648bd33f7dfdafa45611c40bdb3a189b03f623686861ffc9c89334d57b701ab549026d32bca9df780f1c47996bc2747e6c09580f8762c99ce999ded4aae0158208302b3ab85dbee01a2e01fa17ac168b5175eacdaa0de46ec1a6d3de7a592ca7c852ff396bf484f1ca30b8a42162a59fb4021c57b7c98f30370301fc27495e06fc1a8f632704ad1882df9b58ab9e6b5f955d771091d3c45fff3a5dabb875961d3b9a710c3ac3570010c419cfb6b55176029c60f2911f1d6da4575c3e4ffd6e60f2042bc9328677d8c3d0f48e38321dadd2e74e7f161755200c0842d4f3454713f72f1b97b1c14b86b71f58e90764ceb3d1050c94c3e59c86d59ec403de95acb069fd5d56dcea5793466e0907b1e44219de0d35002fa1477458b9a5c483c07c493b32ed17923dbf025809383ee5bcbd98d81004ed6e7aa39c039c889af24116e3b465374bdcad748e9fed12df9d4dcb5dbd61c911fdfef0080b22bfadc8395a3c53f80453080a1377648d1c34d0443bd2d0edf7c1e75b4ebac0484af70609ecba264744022cf2454d212d58d97278bcd9ebab3d69bbc133884a9d1190492ede747d6d0ded75e981cbf83b678cc2747419a45d62fdaddbb5420f4c2776a6c1de54202e5dd02fd6f63f0660872678dfdeb687aca1c14464398902045ea44c2e6e7a5d1b0c959f181179edb74bd823abcb07a1c7033474474861d38201011540b95aeb0da7d6192556c1e7ac4b64001ccea405812ec057c8f77d7eb5f2ebac3356b6f1d997ca8119e339967c0dbffe9b89547d5423568a60dc8189ccb76e4db00ac0ddc4047de6dcb1f18deb3de19736cd4b59ec8baf1080dde3daec460b64fdb857c564463c1924ef847a1a4025c9a2751849002ecdf32f31fc23484ba8cff5cf78971605d85e135b5626eabc1962e5203dafb2e1c7ad1f5afda0df571e8cdaaf9eca44423e5c5707f2dc7c528bf7c3d9bb48d3722a383cb7ed77a25867756fb359cb924b75d4a1e0dba925c844b265a5110b5fb99cb23ecff912a39a1ffa17109b685329764d1a20e50e3e84ca21b8358ccd3ac5cae1a39bae095adf79f4b40e432f330567e27016b1008a0941bab4936934f01e2c90fe5c4c71c517427c235efb9553f411929c1ffdab0ef5ca6fcf1d64aa5c68b35cdb0977db478353abd125ba474bde15db53209d795aca72d44bc23343f294d2d34fc6290c5e000c8d964ea20661b65686c898c1034a4d5d1abb74142e3de6c76c990be34bc925ba7b5b1e138b20da4ff25ac866d4e46302eaff20b108bd88dfd78f1122461e36559a310c46d61d58029ce82fc3ab21db42cfdb9ebb468c2e0bc6b1cf41735813f47cdee69ed9358ecb39a71cd9bdf540a88125fffe416d9b2e36f518a849be8d8ae8026233af6c14cb059575f9a9f720335fcff9823723376c42f0213660240b400d045c8d0c04ef428010b46ccacc17a38c37e72f89aeb03d358ba4b754df86c7842baadce8b4baaec0449bdedad309f6a46b8692dc5a6d803fd591663182b5e870df23bfef80a0c20d880eb4b4e8174ad420d715776f7136e2610776bd50f5df2954bf52241a3e6ab40a59cd3cb1069b45d9c248d3e1103fbc90cf704e1060edd60682c8ecc2e79f98f5191a8e3808656b290d24b602a50b4275cdd7dfed43566c5c86ac82d9787bcace9291e4194d2483eab44d0edc6ff4546d96f8476ca1e47383d7d42112d68e94f2d5395c43c1c70c8f974957f9a591c040c96f66d386787547081dfeaf86bc4fba58f1066713decbfebafde5633ae48c10a2eff13524679045f451b7213276e1c1545ca093852d274acb0d85182084fda615e9b796df76ee1e6db2c1309ee086ce3400757f8af76d20e39f30505c944d388c7a7def66ae9be528d70e84f5b7b1b880a6264711e327a6006bd193a46b1f8e782f86c876290057483849e21547c484f4539ad0039fe5a850e0b9f93711dbd4fc8d7224c9e535750fa0baadcd52ad44fddc1d5f0127cdb9d2d9279a74e83a2a0a6870d92d2281cf57e14b50ca32d2586c61d01374a2b32987ebef433fa81e59f9075646b67a1dbf0a0e60a9b8de0856dccfdea91c6515c2ccf66c949dd905bb749fb9563136d03bccf431b56efe33a10c1e7598a027efb8130b9a5e01c9fb771ddb1ac0e1bf3d4d5acc01bc7c68edfad1b5a7c371247f44efaac3f5ddf7582697ccea38b658acce6b98c4c04112bf1500dc1249bf9d6003841566d360ca9b6ce27574fa6df56958794bc2096dc4f78fd2d0c0b8a5a251c4d41440640581355f1a5e41f4cf1fad535256d5a34677e50c0b888ce30cff6549fd93e163c2499b6e7f46bdc926110388dd09b81b83cf31d3b2782765b93cfe1394ccc60049028676d9de2810ea04011f8192624692267674d7f4115833dfe4324b4257aa10780680f42d3f66e2607e9936a8282a998afd9f47dde191d5b6534965ad9c4834cf4e1769d4dfff509a9d06394e8b734e2314e612456677c33fd5906d72fc8190a91352f76e668b6c71d4c2862256d5cb2e22767ff3dab9fc646af4c9930bfd461ed83ba7a0152a9ea89ec548a89a01c7fdaca000ece8a6a9dbdeeff6cccd13f1a6a76d93742d5c8d4b81abde8507567ab1dac70806f73ef988de1bcacb1d251ad5f502321b48a8e37be5156a1bd7ba01a53371b231b117bff59793225c0c8b4bf4140bbf798f7f4a73adaceb88cb2c216117441a29100af89628d5ed0d7afddb9d041e6729a4917bf95aa28aaf609368e54fb40848462f508f47f97c8cec8ee5d120526fb8ca7bcf1d6340f96f10db744c2a263ed0f8851c876cf1a1793c032d950af5e446cf3afb5d369a63262255c59ae67abacd81f5c181465167d199e5dcbca51f43d80acaf5dfa81c86efbe979350352827f1c1c7659f057861da4a4a53e422db3d7d75a37dcc122849a1ce6a4e87df49b13318ee0d1b3b72d3c15de49c92af29b36de250a739a23962a6196ec39a1e35b57d4539cd54d1da3a75ec6abcdf23024404fea9a221b689e0c7ef0154130d0a4f3f7425d04eb36d744c0ba764610ff0be4149a11af8bb7ae4f07cc3b7147d06138e0d5406ff5190fbe2d12de310f4b4b1007de8ce9ea00a3cc1e791836e5819c3c4944554de176ce1a801195613cf4ed06071847661f37484cf43d33dc3ee954882097ff488d6ea8b53328573d76f5a4969bd441fa147ca703020444d0254cccad6788742aef1bfb8c075110b5100ed942e1befbf00a786bd72a9cce9af684dae01541d18f593e07b5d91c36897c6323dfbeb07cb65c19e07fc63f87e1461ee55ed1f018524a6ef7380f7d94ddee121a9a121e657a50bad1099294c3d33ab1613c3cc92d450b4e9a935a9684b539132fb8fa69807341e4e78be4fa52ca003bdbdfab553e59e55605a8232ceb43087f097dd615cd88e13a5287f740b49bbd6cc1d3e4a3244949226602dbe82a3df042797de56627e1435eeb90caf9dc82a28392f6a577bd18807f8b412eb3836d52d877a7dce4a216f15e42b2c562308f8dee13df3e19a65a18afaba0470ed47dedd287271dc41afdbc1e5ad81610a6e0d9e6dfffd8c5f72ad9feba7e6e17fee4553201b8672097f0445e5fa4d607cacb0b24a373c4aff4c2177fdfd568aa20a3bac304b2b08c7c3e29e4c9494178ceb5cea713a4ebc79d21f13d216dca65f2eaefba2ddc0ca0059c0743a61986cc297cdbfc9a79b807cd7b108815d4d5fde8f2b6b24d6d594321476d42e488b083502eeea558aa836dd7ad2ab1899bcbb5f04bf009f6a841b221dc44bfbae33e52effdebfef2ba6d42ff89e4a16dd201f10495752da96ad0b0003b5fc1e2814dbf2f420f46bbe9815a3e34fca2dccc246979db3a28bca285b52dfbfced06106daf6a7795fde1c67dd8cb3406ba46c465c8355167b767eaa388510480964cd81f26d3856913f72325aa97c41035aaf05aedac5154ca68cfc522097cd8b4fa1f623d17dbcd309319efe32c91fee82e4282a71c70105d960d05757b4d2bc86ab1db20e4f75bbb298fdbd24e44c29d317e21f796df66de3ad95cfd1cd5a73fc743897906ffc8c0ee344c8c39212a3b3801904a014f4bfe1d598550c10609934da6af14de82daaff9c1ebdd154943b88e9a261e26e600786e5ff1d89f806deeccff25fa60c2cc902c6fcb4d0c3699309463068f94a2df9c5e2d8775cc7b081cb5abda11b90f9e42894696da598330d6d2bbe405f641f49db337bb1bec9c67b3bb51316ca7c97114baf67b0ad522dee6fde4a43eef554fde8015451b7d7f8a98c8348835ba6b4d80140ffe1eab1d25b4bf4af23710b691b61771b7f0b68fa9679876fa93ce570db835727cbce52337378d24dd5347b4d8207564f52a1a1c468af0191f0f67da645ad199267d72a93670ee5b1a0986e045f46a241a1fb29f91ba0bb7692def2cb8440132085df7f453996e9aba7a6eb0242b2be1b194a62a707f476ffab2f69d17d0bc4da0bf28c9bd28c9542e48a9afcaf6af3eebf68946e297aec18032865c0c61a8303bfdd45f26de3025ac3b0d05790c0ef0e3f1ab333888db60f16b0932a1f3f778b6436ccd784eb047dcd20f6343f1fd23bdf9abc2ed41145738963ab7ff4fddf8ecd12c4cb3a9ef8e3d0e4eb5270522203f34cbd80cdc568b15277792e33101a21e0d62906029cfd86768b173ad3f5ec252cf0a9612d026d16a66a8b6b6ed04fb7d0e64757bc8bef13e7e95d3cdd61b8c0a0cecf708be7ad55a00a7fe7ba526b64a392ff35ba3691e83bfcfe57999929f06f053b93e441263eaacfc127da94b90b0fa8146c12b9b13fb17c461b2923955e9ec06bf1792c16d2f5f6db4b8e817b6808d17e6507410bc5a683ed428d1ba67543faea0fdd225e7b0074d73f3a1c836c9b73e1a9d334bbfce7fb078e1f595615d83da2fc0fe945a4a573c0e8915a7e5d32d6fbaa8f0138b0873bfb5606f37d6c9a124614fa7e46eb5c382b999e7bde05f1ef1ba443dad9c4fa4dfa2bea22b38a68c06919414db88d71275621370fe5d247e1f950353802ca112130502a2c97b339696760780173aef05ead3c83541e874d49ac2c29f0624ab6acdca8953c9a28d3b377e2b538b89c1a4d8076ef65b060344167522f450987266eb3f8a4886bba31043cfb7aa41350a0119857d0c58064d2d14e596c152818660948e2e1da10fa220ec7512e74b5fe93c208d10995bb9135ac88ebeb738c1974c673590b363ffdddd077d04b8d4203bbadc8c513069fb044b27889fc5195321e3a71811e624d67a4f905e808d5b488640adbc279485d5c46a16eb4ded65f486a8705891cba76938678860b959abdd8bb802722128a54ee1bd93afd7b70ff68700b217089bb90e6ec1d63f703b363fbdd46d256e405ce5d719bcb0e4b81614e2a240d4bb90a0e5ab325354ba7b3f175040cef7f47a060111cdd70f9a4511a52147fb3ff5298c2e6d139303a8700a972f0eef652b2c6bbefc04813f8ebd1cba357057b7cb8168e9790bf155b89bfc3a86ec8827e677ea74c0de94463bbc416ece65ba0df5295f15340a3be0184cd49e68618fb60c38e2ac4e3347710ed91e70d5192a5e830135f6646d6c22919b20f496cd609f2593bab7116b320cc0313b738159af99234ebdbc9e79f6f69215b62c4438ff67122e5c0b232c2b281020c13b018b52fdf72deca36a3fa5794ba8d57669e66be7e50a6e3f97945698849465a60b7d8027c4b39b5fe2309ea65ac0a3d6c237db1c045bffbe7afbcf7db998ddbec6d3492503f47cd52fb6114af3a6ac38df4c087652b5448bdff0a980b3c1a93d4fdbeb6f932f1b194d5d6b5b1e9f4d31e0bcd640c765b860bf5b757d1896b357e32e839877c48f84f9a8bd27c1d4e7b29352879b91c1694b9e525c65190ebbb6212e6e1d3868f893a9fe430dd845cce86cc3406e3590fab129ea29c6fc275d97a9899d0ceac498ecdb2c446d718fbf66f7f5eb13c6d1633267e23f15160df7fb1c75b09447420bd74118b2748c63f575a3e3626df021ac166d54ae0fb2e329d79d8066400211f6fb1b3c8da9055420aa2a15cbe661dcd1d420a6fdc11f3ab6b3429f03afc55636219bf5798411234a3b124af5fa79cdb9cf00e4ba1d3450f616e54efd8c12153116923e95b2baf463e66a1063725ae478505f2f28c059a65beee791a241ec00fa07dd0c73744b0d10a141c019cf0dcf9bbda56a1db026f4448c7b71cd68606566614be2006de2f465991e0794943cc592d4370ad1551e582424b20be7bf7909ef3223e7478835b4cb00ddcbc2371faf03254c859c781bedc0f3dc846ecb158937ff242023141664a5d824b1e975fc9b41bfd6d589c8adda7eaa0bd18cbbafedea751d5a76114f91dfb19fd954eb23d4958d404b2fd64f557bb725280722adb22670943aff6bb7a78bd7f3e29cd7624131242516f11200cb1db1f633c75366bdfeaa84b0b8a071010265b9109a9c1cc9b34b270d9a142f4450f292aca427e201ee3ed09b4c4ce778a8e04e03d3cfa2ef3c00663df89ce7e1a69165836130877a32725490df5c5aad2b0084e0d57de495cbef9539c5934e75edaf1362935fed1ddf169181d6b0e85ac8de112e13e307cab88981a42926287055d004bd43ebaf7bd818ab334308e2bf05f66883120a97a419a95a6adfbb9dc7cfdec65c2ce002e7d174966fe6d2b73a7e040314133c65007031709fa2cb7ac4db1495992000f90179ffffd447b57ea7dae144eb20f1fd5cab1109ec6adadc634470517d7ff99b080c1babcfc48a94477e604847911ade1ff660ff81915a80331e62db53e855444b7781d1b1d8f8fecf08f9d7c04386686f61ada2ada08d9046947ce70d9f353f4f7d36da6a396d8a93f26914b3319ecdc9d3f55f847cae24a5a30439486fcc989e81a452e313a5c7d77823d7187bd08f533cd1d32db396757d72d856ce83a6df36ea7a04facd2be780ef4959ab2925f5182d3d09aa01c1efd6cccfe388f3dd5ea48d247900465f0eac275e779bef4bd852bc893995a24414de54545f0dfdae14c3d6aabe33d21da6491157338b07b26786cd62e4a2a81b435c1c4f3c4bd4396d9b9c1065dc59e152677bd77c5548757c1fe2f629b26db5bb1ea2f7867affcae30f5767f020ae9072fa3ced030c88bb220a17236517c19290b866d5bc1a49cff041b5ec0819a8f36e664e137fb294e1f0f93f8b9798196ec93dbe16df5d23334e8a5816f3892d455d439cdbd16de787bf2522d744972979834f3b69387baec3eb427076bfd737f3c53f16cce70870a4af42df94a1f842fd6f36feb3aefeed939199e2514ee4933f1a960dabc4b2841319a20d12a89b21ed91af1c6751eef40f3707e178db9a417b1dc375c087dc72b99bd41721df001b7b7620a0a48cb1aa66abf2cf60a827ae638aa9776f5892e9acfa5dc0c3e896fce3fc41c1924d6c1ce24cf2900805f1c3213aac0b53baaeba49bd11289af3aedd0dd4c79a7299f0a161163b9b2c43025d19d3e13f496ca9f0e64fed20e649d83f59b3b4eaedc56fc3273f38f68b5eca451f77241bb9d70acc253b3cab9c72c0db33740afc0adcef15f9a68893d4052115e8ab7ac4cf9e26062c12f3233c6b1239f4df609237ea300871bbad69aaf1bca519b4122f9965cd5c5bf034676091e7bc1a3da85b026e94cde1e11039b5d6c1c62112ef9e8acb29fd9285c2b49b170697fca736189bae2624daa412ecb8ab3e4f5c2aba7548c895a780bc2992fb28ed7e1e2cb6b13c12e38d7d283436ba578a3eab738cf95f3f41f674fa9619fb4e0a8a7f3976b6fb2ae7b41b209278b37803831bbc861553db96c89fe43e76c6ca8367e2ea958acc6890ce4f3853d45beae29bcd837c455b99f582603bfebfc2f707caed8e481e54eac49c1d8c483a873c40b0663ebbb510f461a40f9f35445d5a88346d7014471f2ae099abe6f537078a4f752e483be829a9c75f7d85d5d0a53f87e52c839ff80c8ecd7b3d3fe770cf649185b257fcfbc66c99d8cfe9ddd8fce92f613adf8730b9c82e62d4b458b2477d09241263fff2590fa8371ec73e09b4c2adf48d05fece33fef9aa7709798cfdbad9852b947db6f7a35587d2498dc5f7adcb2a540b609e7d57e10486c0d2c8fe9e3ba5f8252003dcdc5507f0a22517ba45baafed2a3bf66194cb851645fdc6f9c508f8a6571d91100f9465be356bdbb44e17459b4a991df27166be4d0bd23f3908d708932c31c8bf79502236b6f5667d48fb956d57c292da13e83c31795c356fc931adc10503d34316ba368278ed160d18b10ac3b8cd90a0db5","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"32e2b69f4d4641c6157c4cceb3a1c8a0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
