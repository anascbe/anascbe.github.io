<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #1E242A;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #1E242A;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #F9FAFB;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"27645e9971cde1578c9344941a6c5c6524244367f3d3968dfe39ac48ea99ca3f8442cec57c5353c08bd5ae73c3fedc19f6cdf043d83edbdacb774c61269b0d1274e19658df9ecaaa8f429748b40eaae87439d4eabe9482fa7160ddab1f63f45d314bd5f0c81cffb700685774b478cfdbc3dc167c1e890aece328521e002b570fc9f3c5d43c275193e1be2894b75f0dfcef0ae0c56cf827a274ac08b8c71d75f5b0381b84965011d5552836ba4054c757721b539c1d336518c93be7d865b614d5f29e35624d06490963e3a5c68aca4b1e4b77d5018eda82c0f85f2ee214cbbe752b172697d8019e28d31c0f1391963749205d2a90aefb47227ee9aec7d0413674b7f26dc5ec1cdca2fba5e88759586585ac1abb57f34d3868bcd0d020e490e7f4b7ac3008b24c4e345e8a32cf0a8bfd136f404580d7d3880f9081109c919d33e07489ea00f771e5e8a3bcd4527862c8a8d4ed8a4b901fe365e645f9877c7da90f4519397486b6857bcd695eaf733512aaf5f7839de8b42e520bc670fcbc8625c9b56899c80120c1890a1d6a2b6c1fcef95f59dc1e360892488b404759b430490be7b071dccb2601e0ce2a4ec31a3a410d37eb58365494507e984c88f2867358aa7d657c97db3dfd54ff724c1e2b5bbba96396c41e202b7b0dbb031351a32635c7736d3f64c6626421563529cabaf1f2e7d355d5b82e47e1296adea3fdb017c1b09df1d151ee03c06e0fc0b7c695437db8a6e94d24d996974dd2e7b9c5a8346b96aac1e4b8cb1a19c76a7ee249d685a5818004b7db23625dfe7e2c1a4f8c980c5bd6f1a68def2f03ed0af18b21af4e62153e2d1e34830695f12b3fe1f4cc7d04d0ceb2512b1f62f5856f78d85d544aeaa23c7c9aed9b8932a640939f50e8bf70c1a0eb2f749abc41873ef19d66cb324a89115853f77abcedb6736142f654640d9e6d196eff2c21cad51b8b22c964e7bd6b5b32d1e8f43f83b174eeb9f47e825d2e2c70b4de14e46497645feed5fcf7bdf0abc13b48ba0333e1ab25c3b52a6a9d51bf75e3926809e6cb40466b1e289e8492d74c981aec1b5546b73c5b624f7ac10742ae1947d09db6dff3154cb24b711f6a20d4b58127f96fe3135bfdb75edba496105ce33e057468007a1badb387cc2903b0bbb517a24bb0d1220379bd6355ef057b2977b904b93f4c6ed89d8deafd10c7d91265c0154bb776c4e4415fcf8e6415329803551e03d7ae44084a10cb8a1d34876e9e417266ea15de1208fcb12cc137006025882076cb6e19e3c865cd21644ff28c3cf681f26f3823ccd368fda19f9d8fd776df04d9cdd4a9bb0e088c4f29d7cc87053eaeb430d8fe0be3c49cad882644c952fa46921f93b6ae2ba894c37c64cd6cd3a299f3eb01ec4287bf529ac8f0f08acd30d489f8bdf8e42de61242f86742e634a2a0bce8a87af946bfd487c1ffb5b8d70060bbc239356141c39fb1ad8ccdaa28a6bc1317de78ddc9c0ab13c23efc8589484344ca642bb7eed60d3e103ebe6b9054b78558ae05337b9fde74cc0e7962e04cd0bde4c4a69f830c224bf492f172fa78c192f1939373e697ce7002944742ba4b4afc3f2b3fb64a3748cb07292b9923b949bd437d5b63aebd71bc9d03862ea84496def040cd50fda6da6999933ac727425c2bb90271184f8e196eb6923d6b2f0490f9132803ee21aee3af28ec7228d4f4c40d2caac94f7d553e0aec4e98a7ea1a1fafe472cc2977009f0551e566d0c1836bba028a1f99ec4db8400ca04469780e79e5674cfc35a998a433ed7b482b8ad8970546978c4746293c24bee08d468f635cc2a3044b01bb2cfc7432a1aa5b989d22794cb531183e51f8ee864b202e0cb82415bed66dbcbca9062bea6f95c8fa8ead7f9af0da828edd15ba24078ddf08e7bace5145cb4d18507f8acca00c771bff7d6b54d4feb1d7d1efe3600a0510646a8213f50229bdcc51afe063663c44e4c6010437030a08c9c051f14494ece67a06decccfca9e9ad7e7dad79ae91de1056b76db36330d4d45062c8ff359e502ec8c046a28abe05ab1c2c27db1f35866b7b4d47e4f0e593d6cd978a7ef16aed0eb357b88e793f30c2007efeef9f9d9bdbcdd81e6bb1c707c5654fafd62305f9997db9aa4b8e1519dd84c43e8eae4834cb26de3a6345b897504d6e8368c08ac065cd92eec33361e085ebb0f76a905be19b44c6ae780fbe7344387e8b167aee614eb6516d708063eb533bb14df1fbb318d9790287e23fb8afce5f27ecc1bbc7a65aba272f8b549c8339e79f82311e153f04c896c0dbcc80606eec0e12b74a3b52b8a00f13e6cbf97585b56b04e70daf238761e17c5afc26c111e841df931cbb273b9213a74ecff6a19c394ae6d319997adb1133ad2d453c2aa2b9d6b78d50e5605785b1bfd98ddf9da5e9329e57cd18e1e0e6b00d82f2036e5917662850430d80211f4fb38ba643f57026701f7fc817499d2dd7948a8b781c2827f1d8b2c17f8705b12bc691082a84fb3d0e809a596ed9ccf5a05f8b0d8609f20d617d9198586ad0930a9181fd34d2a4e41ca8e9b2f5a461e12dda1d33e8acb080ae82a15b543072da2cef204d10aec0e4298da678d0d6788a542d885f43ed9dcc744857265b75ec193fcdc4ea93cf6ec80925a5913a361ca39ad0e891d8ddc258d292d412e142a8a51f2e1a6fcac81412c79fd0808cfdfc23ae483fc2421a924e6f70d2c900b4ddc91d13fa73453e623d039b865569f715b6dec232d1bf865bc68f1eb25ae453ecf4b7699d600ecebb4efcaca52a14d0a193acc7de185b0b813a363ae14c8aa1cb71ce06dc8813cd05d9d251b61b3a0c6a5e75047d6c77142bfa51a4866db3de1dc23e930352c560ebbdc3219215f737a8b2aec11efed9e8b0eaaac39ffab8217ef897481f79bff0bd004ae8af5413892361503eebe85beaa84a1e8c7a25e7853c68b4a2fd611f7b72bc409f8c91442fca27a8945663443317430b66921f75f6237f5be0fc9c0048f2c832563234d39ef4e421ad73affe6ae77525566a4fb4bc67b82757fc4dcb4ef3a0be93bee912f98e2558ad832e516be112de7f8a18807a3af4ef5b360325802cd39640b557602797ffee970d5e8fc1d06fff6c6599e6b34ebad30d8954848ba8c429320ef6430cf1219a6b3ac11b09abda798d99a19287aff4b12554bfb581c59ba42c7ed9c370f93e77b3b3198a647bb55e9e0070bbc5313a1f0d73cfe76f900eab961743e1d215393f7fd37592624188d72616b26e5c975e78fb61f898bb30f16ab05427b6116d40920099c0c7a5ea502c0b850412d5acfb4f033d85dcdae2b21e733d5c01020954bf0654550ccf58b24fbce99ebe948c322166f1534016ac3c65193ee77acc0c97e893c2fd6235169d264f538f92075da8e2e711335acc874c1df669c0457f02dabfc90b4d511c8959e8abbbfa0e1cd7baba5585076edc6572f9611af09856303357e055a7ce14cee4fdfc643d4c2954ec1b6b9e8f3cc8fb44a078f06c54e3af37fdf6ac7f4fc9a6b75d7569c2e9ace4a9e3dcda9a83df0c5d677857d88a27a05de7c194d11fc815fbd34d369316ca75176001360d78adfbd8e3b0ab0ab97b5df2f576c7aba7ed63b8abb2ac783709807e4d4d7cc6f4ed97e4078b78db86fdd7dd29dbc3af92a540d1341f99a7205b3a8fdba4f16c9f3ec9eaa7ee373c4f8a4e0bc9a1939a974d8d76a0df0c2cc85a210ab066b3cc067108bfc33260e5d9734b60cb496f0c4c0a94fdc067655352a5c4012ccddb1265f76ef50d662c11e14fb941dcd1949f2e0c957b439feb2344adc46ec5c90c28789f7d56163f7b484e1547a215e96f642f587e1bc0c4b6335c9e6b3151a667002f8374d1e7a504e9e1d14f299e65d510ac298db73c76c8bb948cbd22b686e1c3541eab994b7a12e4321e783410d60304faeb2acc9b18f9661fac32a6763d40196b18f04a7d90037694521a4a2c629a0a087feeaa39825bd015e4580d7b8ca15fa725d4c41e20152d09ae17e16c600e386d64121304601c750ef902ca6db3e7ae8ba3fd23e70bf4830165f5343669ac07c838abcb0f03041f3a7f3a2035956d0c91b80d771cf251bde117327e16a90dfccfb8fae4a209b54cf49598c3ea0b2e68737569f6ba7ff8fa3b164068730b5e33827d121f27d2d2a40a0be67689c69f2217bf8965bf2bf57a1acf4f183edf35e2a476c8d9284a509c6a5a309f6fab7173b341a83f4cdc497aaab37fed6fb234d6f7ffa4d5c489e35cc9b92db5b3756dbff898df6599b7ee8e515b01010fa3df4d5a5f76d63cabd7a8243b466a10027ba2f6fd89a8fae230c0abaeca6f06afb71c47a5d366e6bb4c6295f7dd945afbc6e2e14715ecad1c6873dd488c51e926916b7f484501407a077226c1d4c9477dbf3aefca2acaf7c6d6d2a401163f352ad98d9657720f141a5d7cb8886daa791b887db5c874422aca72e801dae52ffa40e18329ee05e6ef79e9093c5e2a7e366465c88ce80e94fcb863fa36031df0af845caae36466978134a2779c159a6d1e6a1480b316c732ec453f31819c4d2434459d34f3a00a1f6ead731bd4550f0cea49902895f95682bcb0245556af3ca14c983a35015467cab0ced6cebe09f45206aff92b05cbbee67d3e2705d1d5c72b3f241127386f77acea5cabe45775c304601b370d44cb44eabe59488fa34985a5709db6326a1ca60bf8fb9dd5b1dd5452e2368b09730409f76a9874b7f95d648b5cb904e5e1260bf137e44056b4318c60f7e0cb986d12ddd2baaafc0fc16a92601fb6b4e5e6db151c369019fbedbdadfe74c32efcda5ad004726e7a7e74f4caa61fd31eac2a4bea95dd0c3dd46d285bb5e4756ff6d04bfc4b43d828afc779e86adcb87f8bdac11703c1d54948c62cc6a5475abe15a50b76c0e1ed6e5450aa6a3b7d7408b7d4a042e24339056e66797fdd7b859f94e932621c7f731964c5e08cd37de2b565452f923e629079123dc37f982b59247851131d3f4c762972b4eec2db5968a08d3582631155e39e8cb9700644b576d89a6134d338cdda022af2252d2d8b67e0c5466382be055bb8a9c0d7402c7c2de8f70d8e4ed247ad7d1c67df08930e2181716a93f6b21eeef59ea2fda8a03f8fea3f82ff558d08ef6074b9d393c7480b0a4939dfabbc3e615330e3e00aa19f3a67feb797b7c3c1e9e5978eb6db26cc0c52b93e5253b88dfbdd061bc7906c743a12aaf503404d0be18eee34ffae5c11b5a4651886c496a968536c17bf2fb5873700ec164601df1964592676e4940b24f0fb0d13fcc03159107c0d5c4e8c81cb2dfdea71130e9d45159f726ec96749eb4b97d65c2082c6674d71bd559c5e7c5a97586b9ef36a3ac133bed0dfbe6985ce632afcece337e49bd9b4875034eee031068de51c7e1fafb6f31ebcf7ee4e28f33350c632e4b68c02907fe109a673a82044de2b9371c57e9e103e6ea3eddd71b420291e32f7421864130c7ea927d4250c515b9b772d8797e09b1a2ef794715532294ca2718fa2bffe27b28b533a6a7abdb3f075756ed53a01349ba19f7938b53613e50f0bb046d12c30a2acec334421c8f82d755ff61d4242254efcad8088fe20e8d56c676546b83731c499e50cfdaaa664467e17942bc9f0b10d89e0905282cc9666ae470a22483f0824bbb942ddf83585fbbb104b958225fa14826ce87195d58e8ff01e125e5cf4624c969d6a17ced6857f237234d65ffe6cee1faf4c42abc8bb63ac68d2a2644361c8542b75c8bc6f4a00b86328f23689e84b2ce16e1ed31c875c4b2f5c5fec36ca8ec5e56194ad4c458e8e43fe1ccc4b5e9358246aabd0075a482de1a61d5279e4924f799e7984dc5c87295756552d1c475be8ac87613f3bbb5aa4d500522a49aaf2e37a0f3b931b523b4f53a25c21a44741c149270fa3975bc4e0b76507a51d18efbafac20742bb9a5dd970b5bbb6163b240342cb8416811e100267fb7e741a5a3deefe45af0c8c6d75f3ec98efe3641b247c449f359e01c1f3b14cf3e7ca41e34cb961abca61d05553b5db63813fb12e46c195d3ac5146d9d448561790014c04c9f994572aa3b34cde6af1cced981b43dbf5543f22730567c330436f3c288b055301a46c95597b0c8ba5edca09c8b95fdb372d18779969ccd0305f068157baa13c7d7eae2f1766fb5171a6b73393d124f242a7f853323e53fd7dc4f7e003125f103cbd27f7f05ba2318860cfd40a0ee917e55b43dde90988b238c83e2965c79e31312993095493238e45aced8e059cf8c0546dffb94b0634a84a4ea53948fba3ae39839b7d64d06b24d2d2ca2fa3400d8465b4c48d7966472f6464b07f4351811d72d97888b8f4c924379d0759230470d4850327f4c0e170a0f1dbf92a4961da68861c3898e3b3dfd3302794e3d40ccb937f743d23dd5987fff16d32ef8b951746b53c03b2977c8ce16ad427fa8340382ac13a54434ca8dff07f892fb0a3963917f4d08d522dfe3c2e22fef975536dda2bbd12a8ce431b10faeb011ea045c0a6c7f4a00bde2066965d8ca11a7345132ee9ebf14d88ef20be02c74e7b363c781717a2efa42e52d0650ff1819df722aa5ad08ac33292b267e63da3beac4fb0899922fa045c3157d66a64f50fc281193989e72f135ec0ce9015cce275403bd91243cc37604ab4a23ed5b7a4a10c4885772afe35b268b761f9356df9c85fa7972bae6d6ab0feb14fb0d307edc967ad5b9ce2628bac523b91f196084fcb045f2a68268049ad18642c8b16edf56ca4a93f3cc6dec92739a910de4c7946ce8a8ba94f80b1a3f8026181b8e61306c93ae8beb6f8ac46ccd400f7771ebd67ca2973489f2c41edf6accb0bce7e279a9e55184a7c3a7324b7f2007413fdf26c5e44f7a95322ca33d179942d04b8a1158c4c33bf95beb279690e061c3a0d855f677ce34d5d0e66b4877566e2c6f0ad626ac796aafd72e6035e13673866efb058b11d2d44190f72a62a805b8390d84bbe3bb18492b0d57204207507a57bf8d468ea5a8b66bbd9ac86970de1a7fe3bb617d2db8041b45273a321ffc368ffa5eee98a7757a25c3917c3b04c60c940036821153d73c5b007246c2af1526fd95141f58a4fa430ba75be8b3ba9ffb51bbe35520b5f63309b15c9fa61ffd43efb0338206c529f6ada82674f0bb19d52ec5dca90c4c3d779581aa2f6bfc4327764b48ae071583d1d705b1910395b9c42bc42db211043e4610effdb89eb4459be84b13b97d072e5faf9062fc63523f989dea9f996f3a84588b0a2d745b6795d909f8d99dadf1f88564a52375b6d8bb006aad6f269ad1c0df7080738f9bcc9c82bdf837a6f2b3424c59b3ead879fd41396c0d823c7bcef19dd40b1825b9d4ceb95a3a3372e20be89521c06f0af0462e8ef4011fc6a5310af54012dd5964ad4bab3f39b62d3bde06a8cee4347e4a3a034395990c591f12b7be38db031677c44a15ca692ce59d6270a403a0964df550ae7b498d77f56a750a6d2014b60c5861994ee8efd9dc483d282ccabded346ec862cf309f4d46aa4f05b264502b6617955e28ea00149489ecdb7117830d9c0ea01090a19997d43f78dd6f711ac47ab4186ffb4962e8ecbb368a8fb885beebc535f9c12b258adbb136f77ec9e852cfbc56f6a5f120f745ac5763b602f215d6960394e5af4b399b6cee1f913a9be9b450318129ac01999b2403680eb18a4b6927d90f0b79a34b73cf76bb2fac8439efdb610d568a12e6a0325f79bbfa859c9cc774143a3304e475d615c2d032df7216dfa81117be7ea285420b5119f25d5c919133087020993ad61ce02843ff458c840fd76449bddd92518b2dc5c1551a3a876ee6ed731614522fe18a08bc578fba3cf9093a5df024dc278c298108a4abe28e1f9610ed4117b0c18cfb504c93c189e564e63a3244caaa96cd60d02ca274220d335c6fa873208a3a31d184eb98ec7ea57e588230ed32249dda2556913ea9290430355d1be10fb2bf10ae70cc973adcba0fbd7a1146c8d8914b6165820c1ef216705f051bad5fd11cfe813bccab0fe15b278dcac23762e732c0f51c9255817278a0991111376bfec79490d9d61e940162de963d18ff9f173a85d8f0f5b77306cabe7915ecb6192cd118450a5153927fd5a410981005b700bf5e4f2504af2166a71e1bbfc1ae0f409e67dbe9da9d074326afab910bea9c7591ca9eb82d2e2af1f32b1e0aa680f781f628a677e295a71db5cae3d279f2d943166281742641dee8a777da5d1d175c2366724f41e5c73d95843014cb0df39266c5e636efc99af341e3c5b50d2a51e29961b482c78999dfb0f9ff78f9c7a90baa29dccbd34ab27c89c3fe00e918227d4ac5407f3ded271fe09286fd8f97f946b99ada03eb4d60536c1fb7334d58047caeef751794fb197e4386ac59175c13ccfec61f01a341ebf7254c840307a1fb6c92c3c12235e33405fb1e7b5707c99499627438702fd9ee5b6198292088b6fcc1153896f827f8e4c0c61502649023606bfea32ac9fea9e215606a69c6d2dec874926d095a9317e1622b154371ac1c41e7bc90fc1dc2b65bf72acd131dcb8d6b2489ceccb9eab05873ad165d9cee75c9e51dc9b308de5b7b384f83d28106dda8f5d8a5478e50580a5bbbc708c1227f4cccfb5a6d7a4ebffb48340decb740f4133897c501d6d9c2961793d8e9b57f2ecbb3a12ef2ba815e77203772d1c06eeedf5095d9ce0cbc4df04a38d350e69284e0aceff1df7c809da61212e097ec4cf7e61ae321862c26a908adda8336fc01690074240a17859343c21d861f87d3d4ac66ffaba5bd88f4ed8fb92e79491d986bc7dbb1ec29ce0d99bca30f31ac0cb7cf488c8c99dd107deb03e547f89f35519553050095ae8dd3ccb60a56664a0af8cf422b7452132fb7b891c0252a4b453523c42202d147d1942a38ca66433570137d21683542bcf00dced9a7ae331e8d66b265fe7535b1f7f17587d45214bd672ce08f4b0a42cda167af0139a281ea665ad35bd0554951771817c1cad98dad26fc9b7c39b245ae68ecb5f7ce329b0afae33bbc84bc42ee2ec0935a53ab5433d588a2b1639ab13961f223f60db642f9c1c6f58a10c71e85db00fce40d0b6593c7b6a368309d9a573cf027a1cd0997aa794a2b9afe539d8c5890f55c402fd378821a99935a110e172422e4172769ae368fffb7c9fc49610cd54b633f7f83936e74f35e8c339a533124830992c8d7ccdac880c60cc540caf0a1675bb4fc69939565e143a44ee5255e9669c5ab39f2e966c6bda7dbaa0127f216f32e09c5502b567bc1f3ea92eaf86aac4f2f971c6733cdbd61e90c3ab4ed2ee4de5b36925fc722c4ed9ed85adbb97ae605a1e7ff32ec9819dbc664450f8bd9d9fc6fb209146b4e422246af733990566f0740e11d4613f36ae7d19eaf021d34c2e6ef2e9efb48a2ce38df31d2898fc07a9f625daf19add04aa63535d1f0233c47ffd28c82ecd1e8f305ac86b321e6db2e548ad847775fe0eea2a40a4f17dcc87c9f8b1da498aa33b8f404c9e471d051d23cdc86c667a5a244a79e2ca01ba0b87d2620d71377e678e9044fddd128d8730568f5c1522deab0a623d63ca3821470925e057accfa372857bf8b17ee3215bb36d7638ebcd2f27a2187c543056df3ed17bc46af3100de412330787b59f63ec27b0492ee8d59d25ae28dcd582ea889ab43519c239ddfa8c45b9db9555acf5635fcc12b2e107fadc72d5f57c9f13e46adda3eb626a0b803d249dcbaa65a10bd32957ba854d7e24e8c9d4ca73ffe8304b53f4d818552180215dd245dfa778e8ee1f3982143cb03775b38473587071c13d6802f6a695d03423af8fde975542c36c3785a1f9b7623f4e382161ed05fa82746d84d0544063e922abab86a47f0e3330eb1209d2555252062239c25f832087ba982ab019253ff0b8eb9025f6395761389ca7e4465a5b2212fd67e77457951c3a0a3f38af763ac53e6da1abd39c072404e6740801880fe78e755085fd2c4368887206cce41768bea71e96ab9e9d675307689b49afdcd2fa1f7a6c229394cd5600077567cc0962bb49fd0313b5f0377ab7dd0386dba78127ae504a579a345b3d2bf9714e6b22ecaa2d07746ca723b1ef37bba59ac162020f41f51b15f2578be6b0c50e94c6a87975fb39747b5fab35143595205692856d218b0b29125494c275a39f4c64c454e86bfd1439e6a987b5311b78d435b2ed4a62a2385df86a78b23d7155f5daefae7d0f68a9c2971a56df41649246643d8fa9cb4d5fa0e69d427fe8374d36c129bc9227281d0d402fb19452c34384d85d2c0477174c70f6a5cdba3c14d6da79672bba94153fc4d877cf003fa3612d86464d49feb9aa7fbbdabcb32681851e3ceffc06a6f9fe458780b595873524f1762b5c4dfcdd118d28551fc043c460ccedc2ae73a301f795ad236715eade228a1c5a4f1f4ffc524d93b73ab87dadf5e370c69588d4b85e8358ab3e5aba89ed4efd5a41354b73f903533faf901362d2e6197c0e63f859778e0e70156cc4fadb4ecd194a165f92666c6cf3b654747522a89b12495c13cb5479012f8bc12d515286116bd62e2f5530ab11dcb03fcf05d095cfd5508102fd6b67f4b085d05175a8771eb9cbbbf0c81a8e73e7ed066c4f5d369341c21d362d86eaac0ff9af66256a1fe8a6ced6d72d01b3892bbda4b2e1c151c38955f3c9a36c70a1a4e377be3ae975f79d2c1f82ddb0cb3885bf1b0afc230c97bd0de58da10c64e80edfcb8f348da34e55151114ed3349e8d68276a37f40618fce6fc3cd9924f52ddc431f351c4e2a8cbace5d66c4493c1f7ac3662a5b784bf6020a59d5592a9fc6f9405d7833721c0bd9b79e0f6fed6a84849d6ae0a736c8784501dfe159d021e587bf1af87d83ca7bfe76bb7cbf14b6900af1791b9e849a19b6d3e469c8460253251fc151a460add6e20972f921f13e666805dda446309bff8352974204805943110cc508d9572469f07f553d69b028fdfd0bfa647a29cd86d023bbd04e365b38acd02b1e0756eeff859a49932cd0d017ec66182010354df47d89d7f7a8ff88ccf593faed8780d444cc6c09227b1325d37afee6c164eb99178b5134cb17f0a6db7f7fe43539a25e8c386fea0c6c7aeabb24ccf1c6da4088de4fb478e93e16875b7a7b6b0332547354d6ffdb01f5f516ee503d28e87b792b4e855e2968dcffa653cbdb718651325136ae8f90f584d7b2276f09f472b9be4f23ef7563177dbb354552861fbdb3239c150bcb4ddb096be0d403046f214dccf54a43f9bb37b23e4bb4cf7c6e9ecf607aed6a177349edcc729a656e90e56cc7dac4d7d8323db9ad8e7e493cbea27056b65e00af97b3a5de52ea1345f8ad2f277398774d932604aeddf50de81564587470bf6ff8a29cb6ec2b2dc7c8773013946c3380fc5ce93a4a5d9cc51df06cf6de6cb586a7f3a5ee76570c8cd35edefd78b124670aa5d4e8acd36d4e0f58a62880ed9bc3576c4fbf5e89b990aff6949b70ad3cdd6758e2aefba2b867c549bda784e1d7a6a62cbe0d4fafa3d2935294be3635988917885c8383eacc9123340dcbd35e8e489222346ea3c53ae79feed7927d5b4280817a381b49f94c6c8cb84615ec4a6353962e31eeaa786049019ef52543264746df0b266159371b247720a1374934bcb25294461723594863e7692be390ce900c84488cf439d472f84981358df0211942bba5f922f0be461acb0ba926074da02b060131a775eac383011f861a5574e76b2de5b6997e55dd55d9038cf9647d4d2abc5a61415e1c347761e14a4e81a89f3a6bbfce8e9607b3399fe0d5fab28b08307c0c2603144e97ce63b6c8d5cb44adabce7e6e69b48c374bfdfd7cdc05bfb6cce10b65f5936d7639f856e122206a5e30cd8d655b86188be4326d6274c8f62cb98a5a9a4b0df5fd4b2aba640c422ec0cce884cd81ca0d05f22ac259ff1c816d52d472ae546fd725562c9d693e85c142e9eac40a7ce73e484553c26863eeabf1e424ea6fc8c93deedaa82a2fb751e522a0c90e29ff142ea5132ccfd3a6cdfa29154f25d9d858db146b952a41964eba7b7012434c2e2739e8f9a2046aa696ba555d55d0f73a71c180c562ff56f981f0e9f35cbf196b722b46a0e53e10c80f30e75ed2268ba8406a58d70a140b2f836c3e5e05ea7d8814e9d0eaef7b219dd36627dd030f48de5cc745b393cc72081474ca59448662b1414445dff499bfb9810b90c53268fa7e020dcb8536bae03ae34fa0c3e400c19746f1cfe3e3097b1232373a3a44b51205d282afaf1d2d13bc139953d9d2a3ec9ad8fd140b00318e0025bdf39fb0056cdc00e949472151417e46fe40ca6c6d82c319bd3c461a4f28be1aa2091c41446424ad9dfb36b5a70fdc7843766fa93a6246d72d2b0bdb0eaa5e4013cadd9acfe8ad424c8dab98bd1398b4e7f9e1193ac80e852b1b30ae7ab4597f022716996b040c27a9d4fea2df98167fca0b4d695a3d3746eee177f9e2ada41d11c278f53a3c5510cd62720c98f28dabd4316ac34d39ca79093de076a485d496dfe731bcf6e8fa6e4b0b803fea4ef3b3f11f5c18f76a0b6088ed11ce3b927a23d8c6664de8378bbec4e5e319860932d703b67ecf7dca0e02c6e18da67a1088ec27501ad86713b7aad67e09b0292ac3d19d2c39a7261cbd225212d056bc94f88560ea11c8f46f24a386f2c19b9cbb7aaf151d49107f9f6cd86db967205c8d575d4ffa18d95dcdac54cb8b7380af8e8ce42506823749b5e4d0a9bf228bdee84894ca65a8b80b41f4d862a00c56b30c6583292f24940ddcdeea2469f22930210a264769cccc70cf1b9d5f7b97deaa1c0c27f3d6da96da36a03258ca0c24371e6def1b018d01daa29d4b108198bf82a6aa3bda46bd6821109f1a01522ce9893243e136a598c9b015353e35d2b5584472e35f4f1c8e54cf32ca1d0990146daaa22661fa23841afb1f5f519cd07d1e1fec39790ecca8d2bc74bf816a1cfef58212ffb5b94bae254e8d422975760b7a77d7362d9f39d036de4b2335955647ed1dca160f99450620cf5c673dadc715997bd185d57fd9d226a799c8c1667ac93255f616b1363a8f9ea903346aec843e7b83f9fdf9e4e2afc162feffe14efca7ae0a9e1e8eef9489e7f245b59d5bf52c9a9d8f3a33bb4f83d9af1aab4a668022edfaf278fd8b0e65503c43e9529eb80051d1a796034c47dc8d215b0876a56dd63eeda9f5bc9131561a99d128e30da8aaa12cb25b2732bdb45e40cd17cd2ec6ee5b3bc87857f1d144c02961adc944cc6e4f28e1ff9e0aed240e74978a9d6da2785f3c934a8733e1adfc08c47f95cc8a91575c531334012447472334203716e93720039a9c6bfb9223241ebf8e0c621f0686e3e8e8ac6760382a1efc970a3849071b0b373b1866fd5d4c900cab1b531e5f4d7a4666be41cc27dff4c675488f6bf026f2ee2203221810e8302c9f5bb0c9ed1f35d91be05b89db36c2270a34902e05bfcf4770a06c14b402e687c134f16ef72a3c50b6078b28919b84bdacbdfde3700c723ab219f8ec9808acb2eebf4eb8ca0d87f519d4d02938ea5a9dd3ca99930e90851d8802957229138fa1702cc2562fcd39ab110f7f53e3577cbb51a9440e5f7df09d2a87a72723e32e3be118ba16485db59767af87b961442b09d1118acd87748b36f8f7deb9586a2e1de4fbfc69ee7be7f50c4e3d1273b32f9be1e2bd8224dad5459f32d0f1c21f38971d4a5c39a9bf5350c460c4fd3f2050fd2dc99824149be3437375ccbe7eb3c2888765864beb5bd4495a5d3cb20eafb8b27b903cfe94a9f37560f381b75991e30fc768d3264f023fddd964939ed18458d099a6b4ca4438bc4f03d3e4c9d660b4465f992bc21269a4197f4990827775e1077135214781a84d960956b7062dce9ba4fcff5df99b63b790355c8b10de0e32cc46d311476cef555014d181122d732459bd9077d0cf5a65aaf542c0e7c72f515ed6d2c8a33237b35118e8f36394e92791f55999f1d80fab575776effdefbf06bfdc0f09e5dbc6bd865d2742a5cabdc8a53b93b8e6ea853e31fad132b976859b79217240730945dad3f8a2270754708addf2b5c226a355ebc454964c4394c920e3ef70383553b9565585591ad6a6998d2985d079d01df5a0fddf25fcb1b5a0b36a82469537df1d9395e0715545be15721060ffc2c2b41aba0c9edce2d115f2be32d38ff7d05da6fd4bf9e49b2c6ca1b9be106b54a6e7244e35ecb57a7cc753945badeddea8c6fc75c8ec621c536455513bd9997cc008003551a14cd69f36f658e7ac15a5fc0acb7aaa05f9a52e86e6e6bd592ea04554a35f9550ea5f57f2efb1b30e98b3f0f90ecae7746f232b50993ce7bc7d18ea379a5fffe0701bfb2a7231ca01886589165d4fdec083ab7f4edad3635f05cb121e9132acb72adcc30957cbdd1fc2ffd0c364247b9abd5db5e0ad778b2164d419ad3f50e46671f57d946d61f0372d9ccef59e2b73c00e1895727580f1302e965fafeaeea06128e8dac48739c4579550ec51aa17db574104c6b3b46a616bb74b8c357c99b5dc3b2e5511aa24c9ed6ee2efea67a71de09bc541bf2c3a45cd25b05db0f19aa1aa046df5858906b92a9de71a9b759632db44d0a298fb50817520c8d38a4b6eae7aad0d53d14d45e0d6966a4dde42cac4f0087125e55ee75d8a3aaa43a39effd50e6857a2e67b57d963bdb1092a9b488e7a08063baab35cd4d32d68c249656203376e9db994019661cc7c0de6860797d575b06b11feef2ff0f8fefdd4a55a03e70fc756b00005a474fb746d00ae0b61e5b24df7dcb3282d029fc2d41f3945dd4253330e8acd1e26d85b7378af2db40ec0e028addd7403871216c216458d6f32ff1636063ea566081e4fc3781cb88a33ddaba5bef9bcb7fde9508855b137f060f567e9e4a7bd08cd12248dbcffb34367261f374284c761271b94cfb4bb8e2cc7599ef01831998d4b27e98fd87e1d9a4c09b84e8af6c4ac4ea0ae07827f5f99bcb10ab1347339312b8fdc1ec7603564fcfd42fd09a647d408f4f40562a1c5daa568bb8aa871fe2f631b7d09527d8181f2644258baa7d2514d37620267b93ab7760fa7c7d430d5f8de0e4a57e8e449c8a81cfa305f883897fa82512c8b6c5e4cbde928bdfc010d0811aa3ad83ebaa61ce79eb8121bf82a5cdf0e2dc8a5327af5e43ba18297add16cf6367e2df5ba4665a43b51a6a097f593cc88eba0191bb1d7f05105b58b971f1f7d83353b4947804d57ed2adc167f51146f4381703fb89b808bf04777d65ec36a8b09489a3f5c70542b1f59892d5142351df2cb8c29bd6a024216116f7cdeb7b018dc56c0eeeac17e8166bab93926f052d929420abcfffdb93a14c7a44264e15db4257d06c79617f4f2f5e51c5c1d9f2a1bdf70e5fe72532f0340cd0ff8719cddc8eeb1cb88dcec940ff5684ea840c96d5ac8d47edba4d12717cbe6ac95e1046b134417cf4ca88859abc16d7cb4c38deedadea7efc40753f1b4bc7af905cd3b2e6a1eddb0df3437d1957e1ae7ceaec5c9488ec256ea5a8c979643686de5822d961f764ebc26f728039948f5327556c17ee6825c0fe3ff5c79016fa53b5792d3aa1979e38fbba6b6b70d3b514ac3f11ed5d6ab0bbae2d5815a4aa35a03652c1aac0ac67537a27988228cb7fe12a9ac578c4599c21fa524e7c71b601e422460f92464d2ca94ada9118ef251632fef3c0833696e54acd377c0cb4c65fe9f121c679b198f276b3c6add4de593007d25277d93bbe20b91f3f218a5dd095912dca90ce74af969e3f07ffc5ccf2f7297097e40e18ddb2b18b9b5d1e797c77d35df9ec1c2b2d75ced27ce105a148b0a118a5b2f8e80b7983f7dd43bbb4f3011d96c0461fb80ff655d025262b05f9ea35318a96262b93d6027d747cf9694abc9939cbb7f0795c4ba3feae549adb1bb6200adc2b7f27dec78bd2eca68c647000024b394fff46da698b7b112d507fe1dcaed5aa6c8f7db43a7ff5074fd873e8e998a917250e895ea7440fdeceb2a21c56edaa724442eb7faa19de46a0fd551f391399500303d35c547d80a87349c7a294cac59bdb5daf170e3b1f3ed809a0c2d676496ac5fd20d0d273604631d1fc2d916afe7691f194eba61f4cd051170e900d3b886f2347dc7ce731703b214fd8ac7e659e084a543a97df3d7674ed9d565ef8c3b0ccce897f17ffc6e181d8c473e1e80e66c194d30668461b3440a88ef8b1f830789f18af9a44fce83b595869e9f42481d3f656f9f42871c3ce2e69b5bf55601e1e623442c46986f95fefbd7febdfb18cb0b4c83b4c0ebf9200d2f1d9641dfeef1ad4f3c919d2a67b35814451aca345af3720a2a489649f5022588c9084e0a2c2f7cad804d5d5c840a29598ada1cd971e67d221442b423fcefac7fe02f206b2142560de487b1f7ed8ee9402bc2aa67cab0373a3d892fa94ccf5c7e5ebc48917d8254cd364851dc95ae87b51e7390efc1ccc0437119f7f39c3d7bc640ed064fadea07d336e213f5a56a14a8252a175c03045944b6c86928b81c279268e2f6bf88a6b136dfc41116ed9d6573892265cdb0e2329d8e839ff63115b03728d3f5b606054349b4e2fd7f3df788b3237c813f89589f00877162e42536760824d1a1cf593f3cc2ac9de8b0c1f4ce5ec6d90a3e8e7a95642dd5e4d84891c8e8f3ca9a6eae5242d527c8554cbbc8eb0ad31ec2cbbd2abff5641c3948a353f9b796fe4d84082b5be69042e1aab91dde421e8f8f67f35eeffa09aa760480ce3a97786d6d557d82e5b6cd24124c4a640b6efe97156485e0bd6dcf8db9f3152a2449c4874c6d4db47999dcec554f0e9d3f0a5934d022683956d454baa55aa408df7143a609059186edeb990d6422ddac5a720460081bf4e720874352d68caaffb0da9fb08c23bd541c9a9fca98a02eaf151e998853a93cdaac6994b46a5a56875cb4386b5bf4e2161b1ff2bb502b8c0c0fbdca214a6a4c6d90a859baa6dc446198ca2ceb318d7e6dace7dd42a26ec6a0fc4c31cce935738f0d00be2cbdce73e8cb05c363a9e5fa740faf9499550ce6879cf3b50d9833304ed5c3368a18857260d43d6bef7e20d06bfdbb6a5aee818bd13f967a6a36367eb6f8263579f62fa9e6860b985e79f2bf2218b8d347e5eebd8888918a64c16e0542a2b824cc1703f437ad09285fadd5238271dc91bae2ab42116b2e9ac7200f1e8e957832ccc239750817cd9d596283fd13d9c69c855a6d88373fc7ad81828680da72c7b52b403e255d1c030325d53cdf5e3b7f55cafe1c11d243e0b4e46832088dfeb81852aeeb81ce3c4499ff72de21d1d2b18eef9a0318df1628e6fd11d8dd27e765218beb5c6eadf72a1f508616a6fbfee45d287ba23bc7cb88a4e458abd00692c4d86cf848c05badeb99a15c40319acf94a7956b196b019b9ddfb4fe14bb225634d27a618df80afba827e09b2ae1d75978e0d04cf56c9a4adf0cca31918c5a4d6cf1c3216e5407984532d1b46c816a33dd13f51ad97b6da45666295f24d79985f234931c9bf96812772b53f25dedb223eb88c5eb4869b530abc52d79ab76678397a0c92929b1fc62530b4c04ce2be4ecd29df42c1e82bc6c3c78aa50b4dd6b50226d06fddc7fb99fd1b53fa688d3ee53d420896658c78f620ea84fcae04e57e659393b9543f63fe269bec8830975a1621819a9ee9caa56ace8946cbe6c9da11409959baf817b92415d9ada5b17d56b9b9141dc7b9027ca11db4148eddf5ba6dee572fb165e01618e5a094110a5cab52bf19364679610b5cb12b284ce5f6ea1820a910528110a883cd62835a2e637baabd80570e968a2753fa687905ec5ca4df849058472db1303337c4e34a2deab58ae773f3d56caa8c231eac2899f4271be89e899b8e779845b42f38098213b32b4ad7b6d1f26c897f62c6a0560fcd5f9258ae832f57dfdd488aad4ffd12293f5ca41504f0d68b4e18ed351f392bb67a01e404c67082bee5115e5e30b82b267b8636285eaa1fe3c90c751474146b7ca1889f4ae6997c179852b13ec4a1179d9f3e22a8082a29a629013af2d4a73941634accde2defb0ad4e0562d1672f4bfb2307adfba3c2103e640ad073fac4d5ecdeedb0c70620e8524084489ef604b4607aea7b8796cb89003642b559474cbeb0654500f5220ad7139872bf22ba4dc982541f2db9c4403debf28a8446838bf804ccea88f4e422bda8493f013344e663f75923b0dd8c4ef546de6a434e16498ec603559abecc14e5c4b23445618fcea52aa981a973358a7f0e5c2720e970e534427e9bafb42418b96eb7e341e27279bf8bbc54cd8bfac0081ee1dcb36744c0a92df8f99c87021ed58319859bf6c4cf2977a38dd8c32abc64ed40c5ae095c1a7c63b45624cc10d7eae609768101dcdec9be8ff41fe2266d6d391b4f5583cef6f5c8afeea7a5c3838e187c7d261c6602f2a72aa8b229773ac1fb2b0b8920f1db3510084e5687141cbb7b7d835ab438c7393840cc05189a7ca61f7e1d8d2a10a25f4281d6bd4d4161df4cfabc0901d581a7bc8891d1fdfd6ead5c609e14deb482198ee66dbb3feb778236723d4f298409fb023caaff656e6a5c630040dfe708005b98a58f28addfa87d2fd680a1c56746c2dfe1e1efb7f6580324b59b7bab6001b02ed42569f1f182eeced67ab53eef16365724d93e4f7d3586b26105f31576a2277fe8b039efa58d481e796c2d16f39d32851fb4f1389604672afbda371d971980e6d867f7704cd429d0ced32f1b0cd8f2688641bb748bb75553d0386d379d05d9471a50343c2ec1d890b144b61d90cbcde56b06d2a1b18504e2467e","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e808e505deb975ed818e32888616e22f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
