<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #1E242A;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #1E242A;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #F9FAFB;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5bcaae6b350a88a75bb8135dff203516bebb4a0cd55fad494de0cb86f35efbc765e691c9c96c8627cedce5b0bc8e53e56f28ffd3dd6e59269bee4488ce5ee390904225c3058b4cde7d3a72fe257f27bec7a135b421f16fd2a013889208ee14863c18cf6a7f98aeec32ab64957d3773adf545e6959f014c4f1c563e03773588caeaf0b5ca1a947e4dd810feec69431ec109c229a4e7c14f2084a95be3ba61682631a031ea139ef456b50b54bba522f85da1f93efd0b84793b9cb5b9cd12bcb6d3f85ad7a10b78bb0bd36b901513d21d282cbfaa3c85e1d366b02251b1db86b524624693726a2aa618aa85d01ce520c28649a319b283d2508d941be4c09fe3ff37702441fc7fc785af6439ee3576a23b50ac41e1677e80c6645db9f977a847dd3a7b25e669ccedee6eaad481f0c00eee41c9cc705ee6d2def03099ccf944fe9485a8e83b9b1f9e10467e6095ba2a596a2380e29e9014c19601947ebb58a0c67e53e7c29812611de5b0ff6dcfdc5a70deacb030de5e79ee1d3dab7aace6170f1e05ec4bae1e8e6870b5136a89d528e3f516ac10b7312679c727b29dcf38d02b554ef231f26cfa1ccc08a9a9741553b864c4b073a46b50d5953617b593b2322cc8374dd5a9dfd3c0ac41466fc396801f5d009df32046de7f7921468bff7e195f87fc53373f00664a03b96a52a28a60c17a4f86a446c13efb5163410b8a435754e8960d34565ee04dfb1baa8c683335e0aa14716ba1a85e293f245c20e08e79f9317e4bd3dc3582aaf961f6c84c1f8c65d741660b5b511bcf656bb5acc206b1b260c56f75d3231ebe659b089a874431c8842f8c35e1920abedcf2ed0045de6e4ab7aa3f2a425a5b226a7c96b59d7873286200a2cb3ce0553307c4ed11fe481e149eaee4aef935416601c53bb112c44286a43adcd89260e9a962b8227cee29919376b4f93f3f2858c85aa40ac83f6052029fa43b511300ab8ca492fce1429a215084ef07b0d7b8d5496df869329c5f6cc4a1537485afd2d73c75253c7440fb471914e0a7120c6eb25df163af78ac4fed68b53d33181cae72ca421c7b6dda81ed8bac86f8a008ff68872bb9ef6bb4800ce4a3801c1e6129af19dddac185fea268e984ff038be66c6708462de3730e35dc5c10bb5e7c788e3f49190ce008889e25b9825aae895405ee124a75b4334fef9bc9720e55795f3eb8aa2485040f583c00101bf68adb2015b3be8c24beedb0c1f3e8425f9fd05fb2fa8cd751374f40b3b57bd4b7ae8d5be42e0e0446a9d769de8cb7dd6d01da872350b6610f52465c0d5c553116a219fb09813aaba74bd29ab4af290b6c943606a4efada5f8925f69b83a2509b3a6b88076fb62c48a3b7c0a7f8515297113edf19a45a9b372bacae2680f904a4faa077877e3c751c0bf8ca9d34bed0f491425d9f492a3597b8ccc0ca733e0a6d66cfdd6c43e9f038d9df3a45d1d79cae6e9ee9c5a00f4f97c5d5dcf9b41f92de9721bfa70f2682d8d08354a9c9e87e460aa002a9d7919899562bcc612e7c44e56c7a41a424b060688d497cd089580f15cf6d983f681e835301782d1d75ba57e5ce369c76dba7c9bcdcfc7033a1b985996124ee4063a0a8a29b24d8e8d219c8c4b5215374e33510a009bc10614c73d1e69bac23f396f440519156b312192d0ae9868175638a7ecb22c04bdc4b0af546ff515314c7f93be15f7a9b7fbc798f28144b8ec522536f971a55cef22ef6eb800caa96fb75aa66cb8665f5cc275cb445d61387d2e95bd99229da5f321c03500b8ed8e4df98373cf000af826e50bb28c111ca7966b2847070b808f2c3485ce2f9c420c467c041dccf45b07a61b8f309383ff7a5061fe0a3e60b11d2ca6fb89a1fc79ba8bf653378da7d73b2814ab127153a2dea34711c7994006a34854998d6b847caf0b1d75129623c655d6f4c1e9d533896958a7d65d20ae8e50ab42dad4ec6e2b54e726714e82d4dca38592f75ad1cda611ead49a922945245108344e61b00865e68e70104f0f89f0ba33153c9b0770d4bf70cda060ce8f54e0318d178e3a5ca73583a46ce06df8164d81346c54fa45999fdc5547d4266118b486d5c989996e075f4022a9129c9530f3364620f5247d74f92b641bbad712c0b889ae44a78e3f1f3fbdd2ab28d451d5bd8230145964830aadedaf88fe88430a114a61b09b9d1c411ef6d2aff8bd872fe00b91cf70f80bbb670ecb2e2743211fff1e9571b0d2bc94f38825055ef151562947daa641ac5d5b8bd344890c66c234aa440599fc59ac1cfba4367b557c54a2ae3e57336dd1fe14add448a3bc493457b0347a27eaa2879ef0fd64f53ded013f94550cda83c077409a19d3ab5d3598ee2bb7729a82f5be324eb0a56335a3d7535617301cf826314252c8fcd8444227ea7383a6768822769aa18e07b03986b6679ae4e86cf2b528722f9fb97abd17ce6016b8f32805ef129331741fb445178c5c6ec4300b07ed84501d4d0c271e40bbacca498241ffe9d8d9563138ecca558ee23cbbd26115897c95e22d93240bc32ee807cec23bb63aa763a20719ee227feb149aa5dfd53db9c4a5070fe10ea415549cfa32e230c17e9ff6f5db5273e7238601d762680508655b14e67e47ecd6f429eb7f21ec293a1e5805117086ad4a05f214c762c5705de343e4faf18759b04d8acf8249ed36ca91b8e3fe49bcb7c4869f7c21a88d5d89414ab0a8196deac21aaa0bbb289f93cd61df32ce54c2186ced27d745b89ac4139beee52d5a19e703c63e04df3d5d032ef07c685d2965c40d8dd1be3a09e12a6663ca0a575a8cfaa06e7d07ca5997ee101a470de0457092e683d9a6dd2af5995d92a83708502db25a5c89b0410a1d1182765694b244e5c5e5d7f0a71a3bd31f1b2a32cb27e5c3d93ef3e206c6e5d599553d8dc24a9e586b0b0ef45cc4b6f1a131a7aac05888f614edee6783dfe0e17a52a3acf8c311ba8cffa030738b74fdeb63aa302168f1cb29736476130d1c0c19c14467c782f643697ac24031458b8024c0be657d2dd6e413b04d1a88bffa22a556d9ba8d6b6034f15dce44dccd4716709d0d9b4b78aace5a3882a6cc42d6b51de183b1f11ec178558ea386c07fe28c748b237dc28dc98b395f6502ca6e47fbf6945ee78cb836192e29b59d85e2180cfb1191ffe158d166e45938d0e283e0bc942af502b096191b2f715c4fbb3913b987d9f5b8641ea85dae9a8d5334c7e6eef053a13952e417c8d9253f3cf9bb0ec04e220c26a5c80e56bad816adbe70122f72c28407732196ce7c594bfb8796026dc541b88f665b1e45c57277efb6f2190694e3eb363287cc64c1c116e116edd828236fdf931ec3c544cf0b2cbacd9139a342d2e3e7e5bcaf1e675d5ad94cdcc6e72c048a5f6907af2f41abdf2619970de0ac548b46afe33668939f3652256504be66337d675e7b5c4ae079ea3cb1ddbfb13abf360c50702be6a58eaf7b47b1e8ecd9be38aad4a2e4b715acfa2deb82c61fe1876586a31e722d070007497e5310ef5a8ab0374333fbba231008c9576aa0927e4421a349e6e319c6e05e908426836ed77e3c18ab55bfddfdc76dc723a8d6b0298c8cd293580e89b152db92bf52a58ad49f74dc7aec8ce1fb4266dba1527e598d7341869f49c93dffdd90678c3d83388b72fc2df00f9a37eb2781f66b5b1a8203e622012e46fbd898573f7c53d835b1866022f4d588d2b92bcf1aef129dfb22c6984c864900e3d1fe5216b5eaf2db473a5d707ea232022ec7112dfeeae1035a6d577342291e00236431d2c2ea078de0c491921a291806a01eb089151a6b318fe90ae35c51243276deb08e5b00dc13533522cfcf16c654bbbefd4b16ce30795439feec4eef172b232be46032431f2de7857b9478d014fe3293fdc4284ecd6cfadea04ddbe193dfdd19864a5372b6026d426f07620a4cb1109886326797519054cebcd97857f38a0d77d79da6d4354286467e24058af4efc13e8298c4c6313495395feec232cde646559754b5cefa41cdb39821527ad045c6e6cfa82e43a42c5ce783c79acc03f9b2025a0e6df70960c7ee4edc5f518b25e53c0600193da82ecce54643c2445bd622a2a8928677f6664ab6556f4b318e88d04021cf73aaa6639ac2c44a63e1a2bb206ff7dfa0c27eaacc255155e74557d9a5c06fa8c043ebf2cdc0e41693d93f95665265d3766a17a2b3e38e5531bf58dcdd9e4e8c8daf5b9836530b5510a900d59a60f467fb0ebb28d97cbe0b6612fd8705a3c88ed021d29d8313f3b4e8fcc9dd31f9b391351d5d8e51177b91b8abbfaa6cc5b148a8d3c767d903646c3ef48d485b612a38911afaa78504e357853579d1d5068a61bcc04d30506865d18d59e85b73927c964416a2861f194da28214adfe09ce5a7945b19e08d5ab9eda85835c292d81c4d432d657bab2fe2fee7394d1b064a374a328a934fc6f5622be673a950e487f3d3a80ac969458bd6ecc145a81c27c93d49167f95b19c5c14e4728172475fb33dc230f9e91da8d865b9b77b9c574fa3d16e254ea6037432f012787354c1d16af62305f5f0e6448a92511df8b94089ea5ca395ae322919c8349ad25a33494fcb0dbecc4bad5b1a7da33618638f3e050cb3470c7762e2f855c5f20762e9bce97a860c23e5c4f10b8153a9dded1ced80b236e0faf43fd53c85870335e06960422fd0d17d3152c4504a452543dd1efb646fa30b2b591404b27a8404a4eb940694f5df8df7a3d187f6bd71826692d0371fadbbec05cae6f9260b6fb677708667283378741dea7f53d25643f19c6e029c7575c84340625ce7f0675f8a998efadfc5e9000cf0b3f5ddb6118be771ee0396cd3170c61a41783464ce7cbb3e277735598dbdbc9e8f2c8bbfb53e6d9d6c7a7066a76ee3a36549fe3193fceb124787d0ffbaed4c715fc250d58bd9563ff2326f614b1e178c953d25d1a6b87257e3b707c7b81f9883db651d73e2f2b276d124bc047dfc3313ef5f42bc176d12372e522fedbd15cbc27a4bb1ff292d704909f1353e52f749964fd372447eba16f45ec63e63203e08059faa72647037f5cffeec9735a3ce7c9efcd3b63f4eea0809e270957b360aaeb2a37f457e44591ef38784c48cb15f4b49a05e989469979ae5057e1ede0dea057cc0bd2e2ce42110c2d046c27d53a9bdad8f767724fdd33de9ff16d556de37a32d544e81716f4c6f59268a42d64f84c787d94f4cc798c0391f5a861f667f40c32bf0721cd8db94a595fa94a53df522168c0dffc1e9f7bc59ef7a92edd8a84c63e14070d6ef2894527f2aef01c80edeaaeb09540ba4e94a653a778d2a4d20948c17ad129374b8f26d8e5ba7dc9c8dfc36835683b7c682f14b21c4b6da25216283a38a8578469f7561c7d3d9533bce3147dba12ea15c02714417c8d34108f45fde1ae48ec07ed853018bdbf8f30fc3db398a13bc3b4fbba857e646d21c833d430c50b578abcb77cc33dec5b1e6ef9858f86e7411a8ce0f7822f04012b74d86f2092ee16f43a4876238eb3a35e9fadeda0fd56784268df478e16972304b40f02b084a5a7f5b3dd55b141285dfcf67808d25121a1f86a1897ec6e4e7bd5d788eba15cef58e2369d94082e11a8b32f80c5504532713e179bd009abc40221060df72bf8ab9e21b5c02ae093c67fd499962546f94853372c19dec5b68a0cba99d8c1744e88dab3a30deb7cea579ff373d07211a898cd3c891059f1c7fd003758ba91512e0a1f97b796f409668eefc940908e8a6b4036e418a5e5331bf773a716de337e38739d37c1cb489b4efe4fa52c2b23ab430df54a100d44a565f55721e887affd6521a72f6ea7e4645d31a25c83a9d07a08835f64d18dee14e96070e18b858cb8351cf419fdcb4767a08359ddda15e233a5c25302899ac1dcca82b711dcff43a80e091000dc0e232ef2d152e3ef38b506412538e006555e411ce495a1a765f0e37ecf63877ffe83d6e875d7f8669e69dc7bca7777f887959c09137e497fa71d118b237cabcabf8c66255e7588a17c4f358fd622d4eaebe3f9c754606f17ff10a46d68f7054a7b771cba66a6269089a4d5df7dcd31d47f55af9026e93c92c5a73acf597e31d27ed0a383a3205e0eadaee0959af0b78dee6ad39da2a794872af9bf1aadd5277ab58e8fbea4454775dc35e42e91b96634eaaeafd0899a36483e21b2b5570b91dc7d5800dac74a66b436248ae69892ae00696ce6762a9e11808572db8ac4bed7d5f676f8c83ffed79b2629a5bf4e4bfdaebb2d3cce49c72636af8488d2d0374df0625f5774f3f9f6618b86aa8dd8e55533de5afa77e034481e64e315359d3f48bbd65b4014f80fae3a52005e95e41218beae62dbe3f194b179fb613a7184b8a4926be842e3275e2404ea9f0e5f48dc9342afa79ad03e55c3830081da8ff05cb84bd7d3261f50551a3905a5a593da235888459ac8553cf87feee86a92d9630f95876912e9cb5a4fdd7dee210550941679a8de469a155751800de35d4e4e27f2011234fd033bb9fcec7fe81b7bf149ba95b35cedfaab4f3202cc5cec48548d6e9d7894773299bc78e88a264673bc5fc84e241288dd5c7b995ea39581d64f2ee89609deec322bee694b0a07185a90edbcdec8332512d78e9fcb35bdb1ee9bec7f078bb4b65ad68ecf54657dba95e7257e723bcde351b4406fac99ca7efeaa646bf73a49924441391694978e0367b7554184e66790a40283d09fcebb49d7fdee60093b6cbd2ff5dbfd5bc48d373f6a0100862de8349f53fa01737c53d6925eba20c6f3a19786d9f2fbbe45b884b6e41fb06ae7a4def442fd239685f121988fef963a90b1959bba817bf90ed0852216fc208c9f00568592c49e130e442485821bfe9a819c465af2c394cdfabe2c07b27ee47a19ada2b51b6154c2f6dc230463f198da69fa4de5673c1ec4b99e69e5afbbe1a4ce497b1b33149f8598be51cba373e1701e4ebc286f401c794a4f4576efa51611d0c75d5b97df46df0d70bbba3aaf760aec288dfb821164c37b7d7ba4bddde120d945d5e3e8c18c07b4d750181660601a3521872866bdc427d22399e2ffd51cc901102318cb40bbe27d51221acded5ad94d49f58ca6943ad016372eb80b81a37551d4bb59b956329f6385a64903cb5a0e66fb44ed0f1e39fd54e39e00cecf2309c2c0a4abb687d44b984df6524fbb231dd7eff5ad64df0606e062ac0d8f5ffc1b5af0127410f479ae9088e00b3d71fbaadc5c048e2787ab26b54295520f0a70833ac6146f54784b795689fa94b899d500859bc71a2ba4f10b3e3bfb52f381fba3512724791cbb39968e83965c316cdec445af9a5654beb24c1687d888d67805e6117400197e6859de802f0471b998d1507345c99798800a433485b898c12b70434be9a4a4241417790313149539c170bc0a33a0db314b6d5f0e08af2e7f64cc2df0a4207a38a1f8a1dd74f6ee1bd155e927a902004e3eeab6654ffede1a6960e253cfb7b9e2b044432ca081ff822f9558f04559f322a527fa36efd8dd4765a2f9fba660bc5daf6e8f5d3f9530cfa59e8054f21fb2c2f7fb0f6ad32e20638705331fcc18413e027b98fa61319c362b74757b2e5f42a067e0314b500f959b992ea968d5ca8e4b437b8d99b10e7ad5f1cf8b00b2838932f9eb60e5a4eb2430c39072eba29b31d1b84586ac55f159960741c53e93c05606d8a09188bc2c33c9aad143f26b0fc2d77a9cec7e2c5471dced312b015bc3acd99494da84aeeebfaf8937884058d661f4fdc45f2a18f72355477cc45858a715f53a3a237ea4a0a0a0d51a52eadd2a6dd66f18fb18de6591bcf3f7cf1df89c1bbb8937f473a265ff2600d8af68fb0e254918db3120c6e9bd94a474edba5a08e4d3aca3a680074050185c4e58f39d1d274b235beafcfd786ece2b7526d64f3f7ae0f22b7754d08cc607fa286a5881eac1611be6ee5b409dda20ac7c515118047a7c4a4ffae3316aa64bef76b4355f761dcf957ee239d8b985b106ea59f658b083e6de0288e1a76820ee1817f7568528e1275d797778a06a471710b18b2b74cdb1ac0032cfda63b1844e847b9239f607fa84e87c438430735186c07c3b0e9ede964ee0504bdf265b3d85a309f21232cf3729ad9b8bb5a370f8d52a62f47551d771c882b1a7ad84c3112ae938466ba2315a01385ab1807419afc94ef2a6116039c103d398eaba08c058970081b5dbedc3c4e1f49671b8f2d393313241c8b53ed2bc92f7ff9d2f3ba6667b848176e205ef230db4ec4a4446df4a20dc735c6bb40c7b157675b9aabdcaca65f51b76378988d641dcfcf027c2616b07370708c63bded59d557627b72aea2145fd5eac1a0bc7a6fe852005c17ede99d7a9eea45f0e0600efe65b905d08432856f22e0b9ce0b07ca11c76e238b90afd88f077e3a571bec65fa44259c28de8c61728eb4283da4d76093ad79fb4dd4573e83ceb40e759965e6b62df408f2095d81952b2905444d8e638bf1360dd0902f73da9ce2bc6512cd25acc0c91f3e07c3c36a5cc67b06b929bf56ac8bd1c45a27dfa63095bbcf3c97678ee07bc1cd47686cb860b9f74b49a8ec2dc0705df606d7947ff3cd5ad9897cad554d77b27097767e6579c30f1b45b240bc126b4c844effad75e4bbe738396d8ce9c46e866ddbbaa56fcd32891c000bab58ec7194819616071181ff7f2780fc3d1991be88f82c1b956d20e54390e46ca9771d7d1ea58bcd98942f42c2b8272a6a364475c5b8055925380272082c23a8f9a07e8210cbb9dadb2da23c929c4614e438b7bb591841f32c690616a1738db2e03a4b5dd8cb45a66ec85b400a168cbc4aee5033e814390977d6a0f89a39c0d15e261ca583cc1578016883c46fa7c5bbf248f1ea663cc09733e4060e5f95ce98c37790b8f09a41a10c3333c570c5255dfe74dad796457c85ccf7a8bbd951196fbe8ae568898447b451883a6d4221f297d95101125e9913783ddde71310d345e6d4a12a143ab582d9ab39a525050f1d4baa16c5439e1187cc1621b91b490da934eff5bff75948434c949457a2a7bee194e693f9eb721cbc80efb18cbccf6c9aa04d334a7a5a9c9b5ad967ab19eb1314e2fe1de5480b56544e66fa9281be484c4e962ce5fe730dee2fe527332038257128323d0c96b7e7997418b2564d68995d217c3196d7da8e909cfe187e75319440c09114411c7885e6b446b82ab6b97cf1d8c95c2e354b42678cd2de0e50897a96d52312b47daa93a79ff17103d37a519b233bc92f7822f6b010d2a2fe6c2664efb0792695e8e3598634c9c96a3cb83b16dc5facee6d6febd160fc57bb8ae9a9bb532ba1242a0a72d29e073f435aa693f6edcd2068e03de8f2a4fd248a8b75488e74f2ea19be2b319b22f7f2b087e3fdb6fd63d67a67195eb77ea252c1095fa5ea06ccec3509088e30cee248962996f893c18a66ca0cff32c6869ce6a6d75fb4d8a5d64c4c193ecda5371b7779538c8c44b402e77c483136ab615e6f19773ff79d24e584a718b13cebba7a1dae4f5aef04d4f24faabe842e5cdb3fe36dd8f517229004435464fecd8e84b73be1c23741cefc907cb1695b06539f86e6cb71a4201880e657a5f19f8dc00f2cb95dd77da3d30baf1822f727bbbea11bf9f0799ad5b653e909503d4ed49a6da9a230d9873620b9a2796f1d04d87d657266b375dcc6b765471930db68469d1f511e804bedcfbde0288149f6de183500d1ece2c753eaea15f109d963322e0c7369eac82fe1d5591caaf291165b79872f0620365e10676109a275a9b0ae3192d6adb025754b940282d16de55ceb02c62f7233431a811ebadd68fe6c8f2af4e53b49b5288a067e36702ea072a8b6c2b1f3390c350cef18e3cba75ecdeec86d7a9ff4d8dada1b23f0e8655eb37928321d9749aa96130ee7d747a9e0d77dab9acfdf2235a8cdda4bb1178d3a1edc9e775f791acdc7bf72d35dc176a9500e5e7c4c956fae1f95eab6fae3767b83b943d7159851a325209e4dfd255ab4c9561a933833d044aeb151189a8b853719eec346eb28ccdb6aad0cb97eabb83bee48c82fcacae1b29670524eaefb496d830924d43aa821365b29f87b12a0a25a1e18413e5581b1eb9593b9742bc9e832b06050dd961a4c7d2ebd10692e43bf90518b28d639e60e606016c6d2d96dfca3af3d20413464ecc2c54cb941af1c8419570cd2d9eb9fcf312b833b83dd8a3143ea6bfbaf2488f95c3491d292182e9a302e3ad55764d04fb70b6fffd3d0df5085a6437a06152dbcd26de6be091f5aa8ec5d9e9bca8bd1dffd2aad77bd13899e10a94e5bd3491fb3ede0ac11f9a5af39e3579ebe9a09578a9131dc949ed59a4fdc84e1812c5d2103b20146e53131a66c4dfffa6d9782a49d54ca6e4d6fc1a4e63c6741d09c90de5a4c9befe675a742832efb755a4c61a3d1ad5c069d47ad48a0c6947e5d6e9c6585ea156734a407e9f969b1c4b680433dcc1e572fa38f0b7afdc0aea56566a1970d4ed8aadccd55a7586073cf62eab1de6b7a88f8691944ca880cc757730ad61953d27bac14067050227ecdec30f07483c897ecb3a711b34144533984e6001c3cca3e363c052ba52e79a59812f4f57869221dedda674374bacd384e1d5e2cafce1c652511b91b5054aeac2ed3bd279fe4f40b7a3c190c12d22d3b3b2796f1c26651744ffa1517174cce75c982b06eb611d0e452b8f6a9099d0e1f915d02808d36a7560764857d67d2fb4c216aab3fd581126e0763ad5afc742a5d7bbb5e0f4602654062dd7d83668d455c771d2fc9bee67533818de0301c73ff174725041df512e938b71e34447830de322d071b7285704d39460446ffebe84b5225e4fdab42dbe83c144ff2a50e1d4ac4e60666a10fe2a9149920c8106b1f7e1f80878fd66cf43a61fa6040c4fae56a96bfba7b46fa1f6042b4b187299f52d66d27891370f400a210c483816288a84d128395e172c136b0c00dace5d214254842a3fd3556486169b8f4449329d0e1921e1fa13368953062b61ce47f560431c7d6e15ba63313032f551699643d31c3a7bf5d220008cbd15a4e8d452a599f0b6da5e02be93202cf641f7ec83dc3f962d111f3b2dc468f2af85f236bbaa8204ad408ffa3ce1075fbb5708fd3baf4ab62fc65da2259486845b24cc74f5fa9aa0c175999e299857027e8743ee29869a6d02d991dc1ad384907eee4161bb10fa54867c32d32b545bae4683a2c939e5690713a8b2df5a9ccd6bdb4f613356d01d68cdd2ed2dd60678c852d823b412b42e17ff10ba28c447fbef61086d0d45f611509213e5c394355138b046714159d0cbf79ad86b4a724aa605147b17dafc5787f16deb6641d4d1752a520e1dae49716ec363875566a5cb9fffad87d2f9c505c59fda8ae0053d9b5f086c6e2d5e0df81e946360f5d376e90e1671a3e4bebf6356ca6e4ef8e484449a94533627d78bf4a29728b7f9ad2afb2244204d11579b891f9eef7806b1372bcbe75bce242d44df748f483fda35add9aae081b1e3440a964ef741ebe4d0422271732f5a9cee2b4e982b51693dbf1d882c62edde033fbbdf7a4a65381cf8d8f3b44382d587ff92cff4c233d6e4fb0e1ac7df8aa97c91748b7fff329c3d240b6c062ea2dd2660ca8d479bc475f6fc35996055020b349496a7c225522ffb88f667553c3ac290f62aa309e688d88d8ba6d566a83f31a4c30880286ad9a865433f156271c92e9cc22fe1acc9e82dacc132044ce3bd36a9cd85174fba8d56bb344d4732bf2be2faa660c8b9966bd1817cee05cfe94c65e389fcd7f8dd9e35da11c2cdf2d907a9b532e08593d447672d406b331e6d7c6b7fc59fadaf42fb6dcb3e638189266f680aa8a401860ad4cc335aa703e5d03bae7b2459ce67c01eda4fc5acb977f4394e5061c5c25b52c4cadc16a2304cd2aa31a92b1d2cb5d6a6f3d0a143cc84bc967b3595a95b10ceca7d24fa5621b225dfb8eff8358555db98e843065e9c0fc17245af3a05043e50e9f81421290e79f695e9036b21195826e79fc3feeb1e96c7198d66c0be1e9002b4ecbb7c6722d0c125842b391bd93717260cdc6cff9a9e24641ebd5571529144414a02d7565071792f2a522fd5fd6faa27f454166b76d760153242888d49bda8f8074a29eeb8d7229b50b998cade322175fd6cfdeca2c9a6fb0404b3c9e17b979264fc8ca68e116bb21b4d1820dfa0414d3378b130c4c04550de42de44ec0fb85e85428fa2c320565e4e7d77af301948c4d3cb672f20a6d51e779941a3eae259c8547ce41afdad0a2a147dd0cc961056329cfcc1e8f9a779c1a5113eccb4ea39d11c0473582270f6f8c0565d979f691ecf0104d43b6d71fab87a85750c5a561171f719428c04c54f3c960d8051b654462d5690b29ce14559f2e2c0cc8a24c1308b49998d5f4c04d1175f243e4ba7a627f6edcec7ce1f7bf29efc4e6ddcff37a38947bddf634f0e84c967c48a12d07f8fc39ee5bc8e9647981cad3d2368ff030b64e8fc122ec04c5047325652c8c4845b75196a59926dcb7cedd37550548a92cd209f09ad21d28027ce41f721be776b300a104123150569acbb155f0620574387042bffc6e84777ad3ab048d7c4fa96e5b2d9f31c69d1157faaaf8902017f37b6af58d1912302985e1fc26320eb9e8f8184b97dde67e067aebaf1c8849c17a57de27217eb584be15ad4cd6d3aaa8eac698a0d1973ca7ef98a38c125900f74786b517528b503a3f7f11f37921f4c380d5034e02c5d438525473d45201eeafbe0976a44e0b977f6ebc820872a8680426484367670dc6ccd7e52d5d1c179905dc27aa991ee7c69e504fa08dd8342371faea4c2801ad8b30f476480168819b2567f7153fd56286a4f8ee103079dcc40c366f3241f9eb20f62f3f73e5302f00c56dacb47d740b5076a4939dc45132c20be66c776adc6d9c0bce81774d7c169ecfa42c54d651a983af68a6d7c096c8fa97d94a42b9dea11b91c3851ddb348aa81d4ecfb8b87f53bf4b9d1eb6e45c8fab0bbe2778b585dfe9f5790ca127dc7ff9044df60a2eb51076253c7c85b8e6864752f42c4caddb4a18ffab399d097136d1df0840f0d42e2efc532b0dddbf6ff2d79868a4e7c3655cf07d7894d696c8fcb28a535232e16f4314bc24ebeaff2321a4422a66bf9b4ecfa57551f4cb85db44b58277bbbf53235b26e803a521ce70b7c5491505cac25f68f5c111a6217823edf515b7b33babfffa7388d3832eb6ec71097209c0bda14ac84bd8398167b3c40d9ba23acff305a7210835f490e735f3d6c0c14896712e2424de806379a9d14c9657297b864caf3a835ec011f60bf18a24663c04e8abe218b7f87ba4d4b9d790cb1b28bc335b65f3170602d3e2b7e971a98faa8ecd3f73a0d200c3f6664d932c938a24bdab97fea98b1a3b6c08c099567e0ec5096df54481f80f1eb3302dd72f38b1d4e6af2fd2d931228bae600a0d0234e6a982d8e7b7aee2c40c3b58eac47095ffdc1d8d2e827b9909c503e7fc4b5096dfddf65128b82cd9028e449f77f458ea0d1388e60eafb69a0842179f4b21642de6e4ee1c636f128cbc49589c15e294165366457c6758c084c82ab1f7e245cfcf4bf24e8653103c15d70ecc9e30e1c9765de05838aa831a1e81e6c6368fce7382d35da64c89fc0fc767a739ec32c39498c8fa4e03219d4e2e5e9adf96d1ea253b5c088048ea440035a36be2eed6b53dedb2d87fe31a9d6650711edb9b2f97b7fd827d9817418ca866e62df65345e7a13bd79f2894a12582a366ed7640decf643d5f18eb049f2be295474a8a5e2c0d332af89c1948755f2b2850e84a65dadeb5596ebd66bdb81a82ea55c24e6ecb08f666980955daf93b16cb520e959996585171b5fe04211a0350392a9564b8924f2626cc5e3196619c045c5ed367eb12150440438f728de3b2e09e4761521f6d340f0fee46852b00b4f1cf7c7f89cf42f96311320b86e72f3f16658f44e1ff42d046e595e116c360d63858bdcf82f0d4c863e8ebade7aeee8a3c5ab438eb0d0c2302bba321b02560bf09cbac6ade78370c7c2a75d1e6235150a88c6eebe23cfff16fed9f8229ef71618cc505e563d36fa1182e418708645651b83464934969f0cc27e3c601dab94ad0d9e5af0e77e8e737b51a4b016d9a68ad6a82006fa3801e908910fd69f19cc42ebe673df296a1d62879061f211242a5b829ba594918205d433188e2dc3525e6dedd21e42c984bcc7ea88904d006b786e34cd0b4bc1414a52f73521c293385863c1a6328de6e480e75547a23b1527d75be55272d703d96e1495eac30fe4d06205b3ab133fac4099c8971f511c9b6fb24767e398ffd5b993deebc9b891877d49d6fa3e25099ebd25a4aa6193dd0b016708454f96966cb03f0d95999cdb714e122d828a47bf729e691a253c6ceb629acf32a53c3130ce2e552deaea25f7d65fe3bda9cb9d01f30fd2205c42aad0035fe5d10bc3008f960bad8debb9a9265b136ccb5c4b1eeba1cd0bbe19de43615b8bd9797ff111b5f7607ef7db0ffec2fb1c0f3de568b3cab0aae320d567a301a4b5dbede521810909c0646971ec462d38d95725c227817b8d7f2610b5cc1181840d7710bed74b1e90e0beb344ff74784b96fbbdaf4a03466bae95e0781d9f082532dea8245485b215d52525b53a65919d7f084c5e5786c888e2418883c4e93a9ba3e45aee6d876248c598000fe65ee739810509278a32a39e820c789c7b10f1d9fbd6061072eb8df90c20542df30e89ff4fcdeaacf79bbed37fb5e7a770061836ba10f9d128d4cc75020d09c5cdb7e4b1937416cfc9ab00dfd98ef1bdc4f3ff73b4bd9584995d158713a8123532bf426d9ae828ae07741e3053dfc01b2fb011d244e941522f1e47e74244719b154873ce86ed43ad2fc3a9c066ebf995852cbb3698dd94c3dedea1b9b606def6ad6b1c7b8c24c24050c51dfc989a640b1f86a03105dc64b20bf6042193bea6b957db70454617fce869f680d536936ad7e2ba5fba2a73f321b6670eda11113aebb8b75961457cb2c88ccdf4c8b7df42ad621c81fcc681f59ef16c1f5e26ac4cdce9fc8c5177065343c96cd6560c2ede87a91ce29f7479bc5274c826c2ab8b17271bc7a7ddbf622e1ab982b5e67977f5641d0496dacf7a616f17c2b2044de355da8890b81e498b36113e652b5d92f5299db668d4d6457555324cefbca5b5e012efc945ac47e6d949fbc1570b5fb9d8d444aeafb177443243274017e2f99fdc14c29134a3561e2258fb96b726ec7184d9d9224c7a0bb5e3b228ef3755babb4a2d49ef2a689f922a17a4ed78878321c3cea6daa63c2e74af06c489457d5dc85a79f70b264186c4f6c2f4bdc575feb3dc670060a26beae0ef6b3ee2ebb0654ae2016cb280a0d42742e8a96f9f99df5d6577a476a074f66388a6e5385490ac2c88b9588ebe826397aa82e05da3d565be009e878c3b344599f4d7630757fc13a9d72c4f7e820a68ad114e74dafc3bbcb8ea257e3009276d1ebf520511a2da40f3369ef3f8a71ed6335eb6ad48b9bd6996043a94a09a1de965afe4c4bbfc7f5c05978f9b732ffb94b7f060110fa2eecee4fd46eceb70e149d6ee090f574b16e4708207d03b84a3b501e52e71786ee4779102165ad26281471c06a4d24df253f21490098d012b36daf9dcf4b11ed107abcbdb461d26b8a112e8ee6a9733a219d735d4540f1244bcb7ed6dd14c9bcf5401f24a1253d48a0fd39674c3bf9d3f941dc4266860d3e66cad0cc0a7160408c92e40b039bcd360d9aa1399516972b725c32bbdef55abc0d2a0ee1f80054a9c11d9aad31249a5cdac50a2f581f4736578820c396638047af267f6d149b08c91af947c0d95fa5d5e71b9dd7071647b91f564f779689b67c7982e7b380d3890fa48a0f919fa71bea303e209583395630126b034fc619acbe38af20abc421244b79d40cc3eaa90399d6ea3a14048e514db1db7ae57d0359a35b2733523c0b4b3bf60fa0d36f26c78d5cfc34acb79f3ae84775e004f5422ab6eea8e1c2e3a3bc6b9234b7955d7a3044db3361ccdbf94b1cc49f0a6eade913446af6e74261ddb008fd7cabed9f45254695511747710b5d1e46f8c423ade84c1cc8660be68aac29d6287c8bcecac402bde9b81531cab3a50553d084f53ec5f8e03a453e8fe1bdc48fe774d0c2d47106e87cdbeae1468bfaca097de12580adb033186687271e005eeeddfc0073402e422475719925a3496b15cf4ff2613e839a518e6800a7601336b49f90bcb56cbf5c073e8942766bd23c387433074d905139504934ecdd1b95a4eb5cb78f8c20b7fc4f35a326c8f3dbefb1fc0d16a16ccc9b174c39e242228665d784514d9cb86f8ab27990a7f5ef60ecca294982e514a3535508a8a507bc8eca37d41f8a52389c0adb8a376511ba735ce4f652da3ac8b174c2f8ffff9106e9493ff8fd30a90c40c974d115c778852ffecff1d556f7769b547f43d6e44d20003798cbd9a7b03feae84c0abe56a30225c304691237eaceda31ce19110f96df79d6df28ca8e5a78627e87fe0c58bd51de2a0bada9e0cd67cade8a5eaaacc61a9c55c3eca5b7f9ef116d28d050fe3c556a2a4243bc9c4c6c5fc6c976f1d073736234c3c000ecba908b8e5c7bdc178f5783d578c10bcbf239f8af947e3bb70512e2c2f14a27b4d5ecfcf5c1c2e5a6ed5b04c49fdd34e91773d3c62182a82f61f8edaeb1dafc0d66865e380f4de8e689f97812661b03323e69434fad64936f17a87d6b0d12202a1017440d9c940519a7ed97998dedd615e19838ebd4a097dc915c0c436270636045bcc3af9b5d6668f5a2d16761f7053e26bb13b3f6683171ee23098b1d7bfdea4e0e56a764e9f0b61808f604639a0a7ee3f687dc00f266f60d6e25adf7747698fd46efd1f9a215be1c039dff1969aaba630d6971f4479fb697eb48dc9f17d908185c5ddf199c195c8b79c7a759deb87336b1f62abafe2830c9f9d7a695b1081a809633d04047da6eb1c7f31481678a8abd14772ec48a98f59a127d5d8a2382ec6d440631686c13167a23552d6e315c1988197ea58b0c201ffaea6dc0ec186fdba7c3436fba7cf86ba3127baae442460f45d405e7477bcb612306a61299d438979215c07d16632fdfaa7d7652f47c21c0d26743cf18409e993193cfb2cd9249ee6c9f16022e24005cc598542f2dd0439cf5b3240fbd02514c23a9c201187778cfeb183171f627b918fa936e960edbd93ae33429248ee605fc61699ac788d3fa96532adb84a5b47eef315774b7ed8a52bc2c82f7a93b49e2aaa3d8a2005e7db8194137650753b8a944fa671099e1c785b42e84e0ac91a9c154e4efb968b6c6d95e4028f3047bba3ebcbd82b8f6f89c76c82c095bbb685effe1675fe0483765e828a758ad3ca7736f60b81deaf782aec16f6f6083fcbee53f8e03b1cad581831dae877fb81bf5a032f57f05fdb3d209adac3220894a124ac015ae4202b17abea23924f29a18c958074abaa3c4fe1ace1f9627f20e4e0873191efb04b86c43868f3ca08d3a57a667f46e4e38c0dfa5ae27eed2ea754f0065cc8a6d9042fdbd23f5edb9ed545ca6f16a70eff224f4dc5d247ffc3553414932affafaf359976e68bfb01e6cecfbd3b8fe5ab915ebdc835478d3c1268cc70b69ad538100ca1d7954dc8cc8f0accb1632eaad6bced51cab9c07c9d45c747607fe6f32fadbf4c997768c52fc5a2e4e452f7c21b86540858e4e826131c539b00d395f3495b3ce10f641d292777d6d2548be4ffa9b8e4bb4835355b65e6d283e36be1f617c4a955fbdf87af6fbd384f91343dee523a68e1367a0450099df32458831c213dd606fd19d8db337e29543f64ffd3e5313ba7eff9f5a5e2cddb98711f3e02ab023b0899d97d9f0ddae7049c4408714fb1b9b4bfcdb27a327c9ab5823f22913cdba55555c3558a5301cf28153530a1fb66e8c2037e17f752576b8778dcdb02a7b2994777e49fb63254f923496ee9fbb5e1d3bba96b0cfa98815840dc61e23f9f3a4c6098119c7927645ace5def43241ee9cce9076ab30f1f5071cdf163ad32d5e7a1824e334f7ba610856a7f25785b666caaaff20b637b5b056140209923bb62784f090e8f651de0ebc79087c1255b158117c3ffba727527ac02e0942b73ee015ab15cf7458129378f309fa64b7ba9d5a5a07c7c250745f72eca65f87280954a4672d5f56d15954e6b17b6cbf9d78730a72e43c5595df0e5a1ea95f04f4a6649f27a9db1968317033241b1ce35eb4898f315899761aa357307c5cd79901fe074207985e784ef10a9280ec23e1f2a8a35e65f0381fb187c0e7ee14e61a8c0ff7d9dbf549e2b4df36c9f537ce07932b74283087d81c0b8b0fd1c91faf657f486dcba044822b79b1c33efe88a4fc7a3d4e2a9d8b19b625a085f5c8951b1810a638f323ebda77fdfc5ae14c3b54b2857920d1bab9e7a45591123f59b1fe51bf2aa9a269a30bc233f6e954f5e68d58d64937ce524eb01ec389d1805175176e8d42fff4e35350472684a277b3ff463cb00eb63b5a1b3a05d3f8ef74f0404a5c919ad720b76b268547f481888559daec0eba763ed33720fa0c9406450b6ed169090af813a97725d6b7fa5f383cab1d1cf643de5bb939392927dbe6450453f56d6ba250303f2d6029aec561cdba57d5c9dcca9b64e30ce59bfefe470e955b9336b2b4a74f92dae6a60ed2aeb13e621262228b49f203b1f94403af593655628ca9fdd783ac043a191b2880d1df62a480e497fe024c65cd903bf1ed67d79e942b4ce149fc204ab9df820efdbcc1d30aebd836298872296d1d9bef20a7c5822b3eba427b73231bd6e0f2157","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"b7fb681a1e4c4de36c87517f705f3841"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
