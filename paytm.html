<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #1E242A;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #1E242A;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #F9FAFB;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"76ab60dd9c15809014fe98d9f138f5ebd00994643def03d43a467f18d123b4b532cbc10e17ff8a3d161cb5aa85d2d2fcd9b8e332d5bc44ed03a95e22bfb4243f05329a5f67f1055f6e507c9dcf3b734eb48b7ffc8aedafb8afa2496ecbc32142a46f7166cfc9771cbf7354c458739c769208e32e283efda5eca0c6a7ed025dedc6d59f05d53eb48aee6cca246d8939b795403b153abe8a6aebe663b31246e1480518fb09adbad71669bcb50f8c672ebef3ed746b420e5a835140baa3ca67e628f24c19608d67a3e5c1af120040a34f2302f130759da473dbb15ad8e12e3afb90ba5ee4f805dffdea09c23676e5e581a72483067629b496df9181c9a853a3fb8f6cdb07a4b675e5c39561f477115fe3360111f8d69d24eeeb0a306a0cfe6c3f239d426c4debd20089e54dcd1f72f75c9a2fd3e91ffb13271aa15b2dff8708b363894866df27234e507ab669f7ee67a3fa4f153fbaf5b9a72db0357bf95c5be395347a09964a896215f74071e27a4f0c6021e315272511726e0a8baa36418f9c1204ba26a3c118b548d065d4c724725281e6039f8c8d2a1fc2d4e8a4fa0994b2fc3cf92df5496283e889d564e726cb51fb61e437ed3c6315eb6c0e23784cd9ee093c373523875a132ee8662b36eaee93540509853328ea2202a716335b2d5454ebf483beb1003efffb2412717e6c7c08281741f7f32f9c922cec14fffbdc38da291e1b7e2ed23e8da267943f0b1ea0741e863e57212017d71e97088488f411b25c6de4cc159a62dbcde05502fdda47f64c6c42fe2b76d48eba31ea80dd69599d756c09c33c8df4be79b8f98d618caeade967e95862f74c10e4ccc8e797fa56a46856c90b2b8db388f8b65e0b64c06bfac16fa89455c50a366ba029619082cb528f681d070677805dd9c3698f4167140f199fc747f2e63c5f8ae02c60d2f40507ec14ac96f0a3f0b29e8d9951009cd54a58b34979493b64e659b08aedc37726773d04b2d3a4be10e8b8b7cc02338d7f63d418aa75464eef2f75e1a6fec4e6935cf1dc18857566e2407a45ef299d656693468a9986d8df59bbeb1a1a7b889c02cc83ffeb9c5175370da5f3a44f9539d4159754b75991496f1d108a26a15a7fcd1ca948121b0447ec26a202262e36b0034c7a2b82213433e886bf4b5edc54076903982c45084406ae7900c9258898a184f552b21b1b76ca49cab2341591435ac9fd271b5dc002cb5ea6d5d2314acdfc17b2e8462083ac9c11fa8e159bd4c56173d3d520f5bced883e918bea32bbfe7f5429dcfdc2ba87ff0a3042d12375df7f6ac9c6811cbdbe233da4958da96cdee17b2006ffb611e0aee50be2ad4d4800c7d5c16db6ec5be9e296a230300c0566ae7d7713ea60f1e24dbd1c41b541b2d7fb9d72cf8527e425c3db304c17adbf39de765afe3046b4fba33046083d1e2b17b76bd439eb196f41b2cc2d00ba5fe307134e8567e39550fe97b19bf3494bedd79964f242fdd7ed23f04803e1c22d3986618e3a025d21da5c7b504bd293d352958ce70e7dd0beaa04ea63cd1b5112e0cb38f03a558c32d740cce721b2badecd3ee2dd4ce8dc451576c0eccb9f94f1c44c088531a406a1a4b6eb62a31619ca64b3f2e6f65b925b63f21cfe4f6c1eaf2d277b3d79bb5bc6dbc78c911af50d32d7d5be45f4ef53729261a3e8b0f72a386cd7f1cfdf6bfea5529e62e13c7f6930656fdb151b5ea3d8543b2fd281b61a70d1d15a53fd3b8a03a6d37a5b44ed0091b4814472d169bb4f01e0c5b0ff2b88d2c374f430f67cf48c80db972354eeb66f777cdaa1bb668507a49ebf369007037f48160d60595a850872372febc378cacbcca12fb28c02fb925d14cb60638838bd682d9beceecf4ab1d0c89c11bfd11bce8d9df3735080a83ce369fc365558daa6b2bc0500521dece6f3f95af9690ce672280c9af38621fb95bbb8bcd7228afd3b018e10e9ac4e18ba7191f14db7b6f7fd7630d78156d4b9693079860fbcf979a68ccc896801a63f9308b3459d63b6254c4f58526b0e5e56f844a0cefa8b8349ef81938cc03a2aea0891e64d744f409f2568cb516173655d362f4a8a71cda6aca3a50ff900413b70c5a8f1600660ee522a4367f7573c6df9db7b75fa15a6c51b8b551a56b43d4c59a6d314d6acb244e6c5632a015acc244bd33b640e893cda7e3a291647b8e380ff469a3cf5f0a1c47e8e2d4cb355ac82db9af56d6f09b47616dca72f5cf85e0a8162bf80bdf7a5ad2a9f2ad32c611621e97bcb5d38d3e486a5fc45fee392dc32e5e0c0df9167caefea44537dc5d5722aa16f51ea3c1058c4522db4030f33e3189c44718e9f1d115c1448291b32f36dddb97d3a2f3aead0957928964a5e44101c58eb091d42d0c22548caa6e7a3fc1b655de5e67dce2f9985df380595ea7fd2050e658c3162063ada1c0fa7ff3a15dc8a5f98aa69980cc63b3fad08b297b85f11b342d608bb6e14ba6754a154997e1b06dd2fe8264c5ae7a2f42f78f2614ce643a473e90c991c4cf25337818b7220f313b585391c3226e632f880b86c75f7211de583a0e3c57f5fe04a2333fcdf8ba53dd03e4ae875a7c8e2149d9f4033c8e73014b25923d8cb691d8a9dfc1657c5bbdcbaf77a2e2196380d308e4646926e200a78044dc464a25955d432f58a31031ceb8f0780c904fd2045353e908bf5a7ef5d382d3defd565fdbdb021f8d0c8d0d266b55728ab89f0fd827f06a0275aa24baa20a6727b9e68b5fd431a30dc8e5bd34aeb1137b23a567d786a44dbc96383a445f7dfa357a460cf63df1fcd2a6bdec2b5f29d2fae97cc0508fddf6b762d81a377fc13f5bfd5941e4aa1f851d9545b4d3a1f12c6c836ef10476b487501196298dc7f284572151d0f2474e3b2e27ee6aef16bbd5ccb06377695b2f917a6dbbf38770a5793ba5feab2e80140f8fa711bd9bb2979c417487a193570926abab5e59497b1ca6166122cc578974c9292f4b5245aeff62008481b7ae12735b6d891499a11308591401edc843ce04a25e456fe46701a218d63ee6be5712e3ae25768148093228f029139b284e65f08113f7d5371d495016727f8f39b2212f2b01a1c134b775118b1dfc8ee2ffd6ebacc6cb5856cd66fb95fa572686dc30a3c2b0e6a45c21c7be79be86da5aed04564b034ab71d3cf710368520c2d56ef3df4c747a8113a330b140335232045ba111eaaa552e56ce2bc36e0aac8c14cb1323511358a0d113a791b1ae2b7dc9d2fa5b57d1479b30e381b9d6b54dadbba999fac97cecd7f0821e1806e1ef2913cdc85e8ba62d61f314e638307c6c4e33e9dee26710ebe7656b3a4885d1eef6a6c1b66f535629303610a805e1613f070fac69490903320202474b6d33d3167f5c7015236ac48457bf13bfb00674b1639f76157bf3b444f58189f83ed55de39dc38e837d8539875d565706ad510beb50eef6d14ac4c3e655b175bcc3f2fbc9e654ade52b7686dc117f3fa35da21513adc8cdef99b905ebb92ec1c81c63dcdef958f45cf4116fc4da193dbefc768a3aaff6ae80fae4b0fd63256196e6f89833bcedba9a46569f52eeb47a745807350d46b5693d2cf9dd02d0131512bbf4e7e91d3ad98069381d443eaafad0e4bbc153efa64b2a0627c0b1f690b4cdb0980019d51428618a25b1c6f894c2715e941abb37b235488fe38c760822795e878eaae3e981d634d3fd6d3135b4192b93b087dee4c0f2ac15e1e6f7b8fa260ee0c1b80f61fb53821f1f8bceddc76c7d0102c3e7be8bccc486f7032445f304f379d598bcdf9dace0ec38f8ac9386c6cb002b154a398c4f941b4eccac6afe11f39b8701f91c3c24537ba6411215da52d2b9390687c937d0781e09e5b80c2a76018bc1683067d1443b71b4f76b543923b8aa1a22fdf5e2201248e2030a8fa18571e10f5bdc0c9752acdad9375f7966dbeea4482b1351bc4e4fa40a0f7941e02ed7601b10c4ffb94657d358fddb1dfd127189aac2101267746a9781d5e6f91775bae212fffb3759fa67d51bf657ea07dad17d1a7b65644f3f07ad76cb2a2bff7bc332c56e632164c2ea47bd07da2705329f6c9fac037356c77b7736788fae7858c9b37116148edad4909fd79a13636b811b05055da3c3c367e71c91a7bf49be8bcce10df9a417534f2f0dae27d2391e6aa4c6b97e4a52dcc15d45ee514816083f96741801d916474f607428f90a2a5c3baaea9cd5e019bf451850029f218330175657c299394f555c357b94fbf8f50219a15ab28396212746ada600ccaeb1dede31a6d2539ca3ab026054cb7286056df77cd8fb27e5d23bcc6aed402218a0ad4d1235a5534db1831aefd7955b81ef13b181c317a0923a9431e5c14fd8e1409c8dbb23f0ad64382908b97729c4ce9577071199de832b7d0b52f93dba7879a04589377e3e88c89134e9639c702eff9725f233b067a94b19682df54b92d02c3a40172a1dfb244a3618f16c487ab89c3550a20d622f13f660fc32aeb71b9303ccc9e0c1967750255f8f1eadb0138b63e8d90052f8944d41bf8546c4d01d2e0e40782986c5c9b1f72c161068d39d5567ec7df97dcde0e03d65f2f980676502b3fc28868310ec66a480a59daacebcee5bb017cd673992ad1302d44a5e391abfa4dd96d463144451a7440953bc1679e4efbedb21458a99bce61ea0f3e6b5f9fb93b93a6beed004a031e779b71654c9d3967d629ad487ff0743610c8a812373d77b956fe411749b1f4f39af6991960b4eb1739613b0979fcd92ff0a76055fac4f29fbe30252155caab2df4987faa525c961baec2407ec8294181f0d8194a0f07a44feb1333c8411aa652fabffbc6dea293462f6957a2c91d9ffa4563a2ed89d20b273c5b4b9e0b943adff538a341fff7455017b8d4de67867d1c57dbe1bf3b1f8e22c499484eac9bd95cb50779409cebd9c795077e6d3ff05295557fb5855e6cc9e0ebaafcb750dcaf51e11d98276d5b0e4921ea0f7435dbe468fcd0a92d6c0b75f3157e89af488bf9ed84b7e9ca001aeb55560d91917c1b46006c8cf13d9e2e88de39696d5acbfc8b84548ff993223bdb8ed89e1887f11e50f8ce72e8646583982299e0007d63882877d6343f13e4688c78b97122f487a2432751ae4c7a50901c7c75573005af953a987b98a45c11491f42bf216e7661170be3a2469d4bbc4e27aca7786852e2ed7ca31dd7ae09ec3295e344ff49d83a0c2d183f694cf2dc3bca4b5a5553c3970c3c98ed605ed826b73be6322f9ac06933545594dff0079761ea7bdaf4061d45fee643e7c1817979eed22089cfffd10bba6dc9602588deb54bfe65a58fc8508d136fe4d7eaddf0c3148b4bfd38be7a052fd038eb8c431ff583c8d21151408235d78996fc7c2e2fa8859c210fe08a015f79ec4c8580ec04fb660e95c0255c8af0b353ff7258afb1034d26d555f0a579a46cf6e3efb07566c1fb9b48567acb7140c5f8049e38dcedc5c7d1eec05d01554ff5058861f01e57440b562af080438b7cba1a37a7501d468110d8ff2dd2d19fc5c06d50a74453b8c2c9ab803945221bfaa3f508030d1f084d8853d2b8b00f7b04d26d14e030f5337db19679f9da9cae32849fb7c9952d00205984f1bc7d7311b84c9ad06347cf8941afd6561af08c0a8e014dc29a47374acd0a09a926ebbb5622e4659db8825b0d9dabf7df9b1dc22ff2bc3d3313eb01e9fced09cd2818485966c35766f7f068cead2c535cdb632f8cb9d19776b1c0b4d66ae56552ac47acd673140f52d933b695775087923bacb7b9cd82044cb338bab87de209befbe2c0c9eb657ec9a87d3502fb5980750a7a9a379839ba8ba2cd7c6fc9a5213f892f839abb2e7adfdea1b16fcda5051e98e40e12badc7281ba88ca158df1f52cd597296cc88be0041bcb9c6ec4111a7c989ab529945ef9d0ad7ca28bfbef5682c84b0c9fae8454a6003a3e0c89c68929f024a004092764be044deb23ccf50b35f575c85517827897934acc424810b2f497f8268f9a962e87e12d57da98441d3033ea70dbc2e73c6125248e775571615ac813cd3828407f632f72c90993221cc9a8a29f122cb989ee3a3d2795f346d2eba114aaa52d114c3ff178cbc9302723c93b32c7809a34357784aa1525932f9d68bd1928564d54006bc4830848806df0039a2a738074b57303b8eb10da54d355bc195cf2ae4321948c0bd44be5de3ecb89ff71800a1bca89196d8c7f9d85bd07f5aaf10f80a087e8c725613bc0e357b7cd37a6645229f0c0930d6de0221de6e7995abd8a3668a78c1f2758719ddbc2d477f659f3e39de845eefac74837c8e0b8812483cf47cabd85d6685e2c54c7155b88474d56c870b313f79f9a49d60f6cb2f8cea9d4ef303ca05a4160885e7e831084f2d1c4e56cbcf5ebf25c55e7818e2975d289a3bdc2cc175d8c705188c020269ccd8b87f138e86f9f98c59aea50967c5120c8585898e18489307c70c18fbf80afb93ec8e722644fa92351c36ce8bdba8af76199e62fa8e5dfca3eb7e644c4b224ee4d80dd13c94e1c03e293426d437306ec1d67cd6f85afdc30e90721a6deff27ce14f2276b116ca83c63866e637643b60de1beaaf2b01b2b337071c67e98cf7e830660457da7ea9ce0e9012501899cd06ec8670e51523612716ef11659659da241fd39773d6d885659c04fe859388749cb4e004b722b98092f83229c9fb0c1ea0707441e877444c7f912113999c997e8a37cde54b5409a5788b8cdf99d2008270c05d7318000ed3945046c7df3bcdbc059a4c2a25ca918856778140eda8c046ebd84cde09a29010f81a9a5bb37a04ec004fed65891143dc2ca9d54c852f0c4f9696a7d5c74fd0697471e1982654bce389533c3684f12e6e81908a6f39c4815703e08bb6f077f3f20006852ec37deffa48e97fb74f78243c9acf7bc9a7d411db601601991a67edd625c61846b4177403bf5f94ba97e61c635a52d8c0d1f366d6bb478e1cb9c1b55603ab9630f2c34e04cecfd187c518088c5853dccf02fed07c98e43e5f122dd61aa03cfba0a9898eb1140b92545f94945a6ce97de9c8e84457aa06f5530ce570d745a0e8307318537ef845df9846ed578a3a1618025b745b8fd324dc84abc626e204a4b3846693aa42d18018789e123e637f0547682db2fa644e8149caae2c8e7c12656222f7013038c86fd126ea839ab91536ff3a707f9e5b45b93704ffb04433645aea454ac224c19af00050f4a0d83512cc085d521fb085667a7d761fc9a996e4d7fe935a46bc23ad354ee15e63bcd929416c7498061b02723c78e1be4f125acb9ce314c40e1fbd95ebcc84135ddaa09613c3a625a48e0d5c4da2e03038c03444adf6c6f3a39c74c5603c937760ff16aad2c919f6a49c2f8baec093554230963559a82f4d1c2bc9ab9046a831ef6123d2439456beb287636ee26619783d11d5da0a1bcacdec43c68e9e0f45c19970a08588dc8a78e6bfbab1a5ae576dd9f3cf93f181bc16ca30a905a97281146b4a0e293606afc84e993465832e3dd2dfa380b481697e52ff47036969a0cfee8303ce2cbc4b15619ed8cdcc4ebfb534c3488882d48fa1510b4aedd0f384767e9f0e46510847b9385232897ef03acc22193082bd987acaac3d618d4cf49c80b1017f41c0c9afbc18b124fc033ca2aa0c619f393a02374bfffbf8b9482f181ccee07abd3ecc02d3797191c6b0e5dcbf0adf9fdfa636e60dc4d2b92c19dc5b3423e24c6dcf53eaf3357ea08ba983022446711e406445ed752dd09498288a92ab43eee09922f7df9f29c23a1404c7a9fb6abfc7e1eeb6ed205c14b550608c95bcdf63034f9a143bbf70039881a0c77eb7f4b180a30f9fd80ce45af4fb1a989ce0f740e57dee5c670d36eeeb6a01b6741dfea70dd9528950122ea7c347d5a03c1ea056fb2083e527e48c6e6205871772496b2d4501e3c683aedeae8a31a706dc8ce070d857ec5463f0d3967d8bc3c06df619eeaca1105b581a18d1a00b38ced204e833fa55d5ea4d0ef7ca9e2a21fbca245a99e1f13dcc0db1c07b9cee0999bfc6b4030c029041d351f6a1fcfa333a9a727deaa48add1441f1143ba3ba8c623f529a285678e582270acd308550455984b76b8969951713c92a361edfc4d5e0d27a9ddde31b8ca2e164e5d4f61199edf62d26010a72f0a723e1091634381593b1aea6e4201cf83f18c0acdc74c805cde3f79fd123ea5f6b37671da990f0778b80d7877b977135b416349d7dadb5704dc56353d7caa211b821117e2dac3e833b8ee70860fbd0a3304b5d7db021d26623e0be967d8e10fcfa76cab59f0a05bff43dedc68e6d95a4b046a270181eb1fb6c0c79e8d62bc3dec47d18389bbf25196bc44aeef6ae4263584373ffbf0e4677ac098c478d5cb6b4e4f6a7b27b392ab15fe31764ae478cc1e9149c065e5360a347eff26937cbf1d8e4c4c5c5e150e20d9415e660bc955d3732073d2da66942028e9cb30d6dc9fb483881d571085ea48819641be21e041122e25f3a79872eb83e292560efcd1b1e3ab71e147669b09b241d9589573dbf9323b5f0bc96156d54cf49ef133a39523addd9b02475e462cbff938035e7e89704c878d405e09393824151daca87ad8110f8f111f41c9666f646c1d584c5e1a45533bab2fa9350ab454ff6608052d69aff72d09ef0d07de7f6f1f6c6213074729a9b55a7fdc74ca1ac5d044400b9fd6547c40fd13eb9991cdca1c4bd282749744bf664eeb554bb947344841e460737c40e5d1454274d14ebb06993c940a6e017339f9cd86d2d4b18cce23f5f870e2fc776c552f5f32dd5fe2133264df33e75ba5669651a5635190ff01d92e3c3f04789da6a3e01949268afb9e7534919f70ad56fe6d701ad22acde7f9f2677d817ce814ff3b24734156955e8e5a21b50c1f2b6e3d6d1d65c8ca6850e5e9020b0da1959b6ef67a81eb8bbb9fdd875d3315ef4a394c8edb5abcd9d78497f948e67818c71ea1e205089f7a86e521b6e4f58a94f3b0907de658ac64c2edb2b445aa22345764247a02de4937f72d11c5a1264f7d155a8dfdd01305b3600568d9b32360b0ad66714a071bf7cb2c76e28f320cb2090f85ebabe230c28b77e734e1c73f6d7f1b18e739b2ddff8b8cfc780ccc53d707189911fd2017f55d8b62d215b689dba6bcbd40d189fc6825670fc21fcf3c61703e8ecf86995b21a6a4a74b8bec40085724b6786a7c52cca8f3c8b4fbd2d52de03c221d7205fe582b64f7fa042f98b0ec14554b7b1baee67c61f5ddd0e7f40707291b05fd9f06cc7f06d0972e8b9a80c086492d6d4870d964da5f245acbf5ae55559ca0578fbee7ead35763a9174ec7a1cd4c79956492fab345952a093da6867601f9d285d0b1e8c2c7162dcaef78088886a77f052a8d0ef87b2fda32b3e281dc635c23d171541b420a51bedeb518689c1cbe16974e4c7a37f06b225919fe49c9269bd37968d98fe70b26db43fedae2d6494392e7ee8f1f0f37c395ec3a7edd71a2371c355b03beeafca3f6456cb0c78cee12d758785efb61fbf508aaa67e8dd677489f5f3e46295378a30bd109f40c202cc1eeba50542225097c642aa7c56831b1a308b8c688038a0060bb3430c512f9b9409bf3f8298c70322108c5850e3150cac1b214e7433f131203e2f68f49af746b90c3b0140cd930e6271e12537037fda0e176a28dea0792598bdef65651c7dd810ba50ebf7e9eabc12d71bcc848b6dedf2d39f0cb3d393266f54d4523534cb8de39dcb47367753ff6cff1002b6cf088a0a473b851641d5d2fe47c4ee75fd1607438d193580f6b82d701d2927a4841507db1a79eaf0d57c0b848ff2ef371fc6a8b165f9204feec220935ea98d0e9d40f7fdd58a5d1519f4d3abd1e9efd1e22b604ab9f4abf510597e8945d2c187fdf5b9f94e2ffdb4608839e39287f23552bb4c450cc844b24ce80fff2fb516752e1cedc639e3000dbb9165bcecfefc0200fe44bc1263da56191ba4414c954bb36226bf77e74207a6b84eec2db5604cdd35cc2f78823c86f88e41953f9711985bc1b982682157cd8db3a2b68a796bfac669011f142e9076b1118c1e28adce6a7e80b06a6f6cfded178327069ad254be9b38c4cb5100462b5e709e1d4a0ab036707a11e1ee1ee7518237222a0fd18e07e3f92d4d6c1c4d0a0fe31848dd795ff9f824b275e9672324d3b9d3eec05a3ac0cd8cce3288cb278216045c2a607da47f26d4a058f5675ac6f8c25f4686fb70d3393642b2038e8b1901dc7e72578c48341dcf4c170404af41cf0bb86b90a64c165de9cf0cdf083d9082b619afdd8e0e4b1f6161bf6baf4461ba8af29a600a5eda4a2f4b611ae956a07da0d5f68d9e1556aab9d9d1702b5416d5cd4b8847b160cf590b559f5f7ad5c29561a4ad7a50192fcbe22fae7d755f5ecad498bf0277a622b3da89bcc5bfaff693dbbb0f530bfaa4f881beec946c598ebb18c8a68be18ea0d92b6369bc0dff3810f0b4480bd1e19c75738c078ec07aa6b2b2a566869fbebd5d904a63dc6d7782deea451352676e522c7262b346a00bbcb09a4dd7c05a153b894561fbe59326111f775d08b6aafbcb73f9e91cabb93dd162ccc52ba0cc71c257a47aa733479e86071684f73969daee9ed9da4b7707a4286068297f5b136c0f522544601a6167777d8f437ed1dd657093e323e1ab01654c275bbfa4c1329926a7e4a4cae70df8c28e05cb8afec7239caa39c8aeeaebf52d16a27c7b2edfcc26601e49bf2b2ef3c3907cf97a60f48b165d0f38376af12c975f9e1ac2bebe2ffb74cb0acd9dc40be1dfc6ecd065735d621f0e081aa78b569ed756a2b4832d06edd330c6390d597f260c1e8ef4954650844e5404eb67151cbff401fb9f495f86c8231725e527640b061a309a672e5c4b840c8a8e3181f8baf8e0e9788a90410c5090a2e878cb6e9fcf232e5bd95e9145975fa4538fda23db8479ba7b163a39c90c65a7147476818eb0b213e7533582815c4f0a3d95ec2f746eb27ba7b0c15e22323a322b94341048a897e62c4dc357d1ca5fa8be52649ce2dde7b9310cdd338b6d0e237f6f7a629fd1b073e5365d6fafb8e65d451ae1f767cd17ca4078f7eff1864a07512a6ad4f0e25fca499f426cd8ad2329519c0a6d068486aa251280fac4682df9ac328e5d4e09f7a422b9ee5b76f9f0aa25a22e0094cc1d3973a9469effbf6095ff0a2d3a24c35d5c0417a27502f47cf6c8e4ef6fe5101c8e0e66e9244c1e12fd4e82cfafe510fad1286543f1fafee4c1226870b25cb466cb4841d96125d405a9fba3c9842c7d291dc7dda2a168bdbb117468480cd5f73535f8a156448ab29aedc74be66461d195e0f627db2ca7bd893a4fc18eb6140932f39c2d661da7c9e7882e23800a06e0386d15ed3e8d304fcecf9b02bb300ea2817f322ee58e7e1803206e37ebc83199c7314ff5c8727b1ef527e66df08980658a714eb7f62282927dc94934a35ae6bbecd1178b99fec3e67e960a2249ef2df51cb2df6c199d8b689ea7c29deed589a953540ff25542788468a91f17219181f678294885ef7a206f400e77a8a7848d52bc4a5deb0d9386a61d1c057b252023206cc5dadc6338a13b91f7ae42c0917cec0c8e810c3f81d9d912bb37397af76d6c8d4e02d86fde615a52d8bdec5bafed22359c4caf402d3ebf5483c20b8b2354c2570b27f6def620d00a87abbcf3b3fd4d794a704c8bc434ed8cceae1bf584aa7033b6bd40426c6376556295d1354150efbf2a26587639a59bcebb23a3b5dc5fe93fc9a8d035293d47027b17e06dc6538f5f1cec6ef621a2d52b22aaaae3a0bf89fce06a63a2de7aea24d0d7725403d417cbe15d2e5fa05db823a6ce3c81280830090945adce07b931d9541fa9ffb95895a98650154370283188949aa8e285b59ea6ec25116ad37df08570df8f478aa0149f9619a59ec699fcd47a76dcbf6912332ef97cdd5b39a99656c2832fadb609d4719c27f347b44f0dab2463b55bcc0d27d1cff3a7e1aa442b186eba157ca30cef1024ebb909543a86383445feeec04a52a76bfa0720f264c0f928ed24345baa83d6d0eda72725a9d4d0c0aa03c89582d263dbd070214c31bd1f14cf05ddd7a46f2a582bda6b54cd34a653bd9de76c3f69d496f3129adb2149550d7b9e2beb75e08f33610a2d42c99392906bb38a583c9c644dc577f7bb657a69165bad661c1527afe90a92328412817a921989fa9e66b642a83e1cc155bb5ab1d12268c1eda1afb9a4bd4197c71c03cb76c4e2c025632033c5dc9c9c968e2f6e36fae1275e438a0efe1f6772307ccce928e7437ea4a855f8c5b25f09a35b18dd2ed0e1410800f22daedd97ac4f40ae5ba105491c9f3447d92dd7715167b44e010c8a045013bc7c79c22fc09899737261a932b41736cf0ebe6a4bb159eb06543cfcedab5550e749b2cc0e0391cd937f31f176ab65465050bd6343e20d994ae9eb8783fc700a257fa926cf4202f56ffcc6b32ca895d0956f1b88aa96e6faf07f86952298520731cd6fe2bbb8661841f35898eb72b0111491aaf0b8126c41aec25c6dd14b3fd41b01603316251c672607f8e20a17d61de05e538a1274ea83ee59fb0b7c06162c4a34c2e701819bc9bf5c637b3d9f6541e91fcf13fbb5cd5c0646842fe14aefcfff89aedc0f94a33162dc08e5e193218bab750772aa90b6f67fe4d8e71f63a53f66fd7c970f8694cb9e500586b24eb9d96e9b8de7e1493b6729400da5afaac396bb8ed0c2b0a43c65a20e45f522dbaf389c2fc9bd862483062c7dbc71c7ede5776754161141f01b8ee0051f382156bb52ec3a96ffa526d59c81eae18cf13dca634f44ffb04395e0428d5390ef61f450eead0b571d47f916ede0fa27fb27ddde79429ce17ed2bde405eb1a37496310e704f5559b36a15666a34b07438a534d99ad1c6fc577f919bec395056c83553838916d6841288dc5278ac47dcc87b1c4d9f7e983221bb7ddb9427f1082223855dd3d4d34303ecd64cac6adfc505e2fa64623476a14e6e95b2ab6f8506158704ccde61e323296b7ee5e6169cb7631dbbfd2f21dbf1c0966743e528a01c6ed950df226af8f2b4ae2f11fa99d0791578d1321866ab9fc2f16773ee6ca97aea1cd28a2509832853467df01c75c925815d533ae11fbaa5ca3e4403ee8db146c6ad1565546c5d29e781de5ed55f41ffbba22a60babe23e5981074f7941104c34278d9dd1e4266d66b0de2a4e9713ba68b4629393296d290bb37b260554ad619c6568fa4ff12ba22562f671d2d178a3bbe13cb75d5246f72d248e891cdd70790998e27e724a55dd54f6e1fbae5d42670c189374436aa696155598aa53ccdc60d42559b15ab2e9e2d51de04bad75e771ccc160d88bfff091875a9ca582356d6d9efd9a6562dde0ff50aa6a8716baca875ad6fb372813f8ba7864480d11b89be4dee6cccbc494eb575db33081414f640de0683841211798ff56509881a5aa35fe9a819e27bc190a8a07421523b09d9ae45b2f6112f59e14113f3e6b01e0ea042917dc8741d840170fc83594033712108ce514f075c15a1920ea726c8183a0457da2f10a4ec142e48b8c81377a73d66c9354fbbc5a9fe65d921abf144543cfd1a7947a279e53e2410fd2446f7bd304bac8dc29d38a35e3cf83cf1bea58a1f3ec37a334aa3f4842bade41d62227cc84021545b0f2fe7625019e3dc016b40c3c893c18726335d85e806876e668df6eac57e089ff91a8f7f502bc9fd85fa605e4d984cfad57efa9950c9f8173e9047bf08e98200a8fa04a0493bbdfa468c3015500de6bc64da9e5446f7b4b8736f5c8f95ec8664f7df5d0eeabc22b8c7be75a81c05d489598814ca42ca835ab60c51007dd4c6579a614c8525265e09687729ded5696332e314fed32091871be1f93414aeec0b1a9e370d56b25cac8b6fa917ad3ed9383be1d003ad45ee540afacf4927152a247a77b7434ea447b4d499b80d862ae50a42eba991c5ccba405ef6e74a6d9bb98d5a07215e85eb5e469a33bfdb95df969c82c4646f558a1c1b262a370a8e5d49276fb0e61205e326b1501fdd5f7f70e205b790eb6ecf757a0fc443de8f4f5e89634a4c66b8dfacee090cf1c585fe3234663b76d11503cd3183e027cb90124cc77ff72febc80cf8c4f064e0c5138457b82a0f3ecc6a7c043e81c4f8c428b64cd7f67874c6fe8038096b58f70d83c7a0a8aab9a1aed9137fed12bb34af5ca70769a3172af88ba6e0d5063d24fde7372f78a56d0072eb902ca1442f3af606392975976d911b554cd1693bdde5b3d9e6e7d8cf279f005237640bab6de8c9723b7fc11340bfa31da37d159aeb01037b8b2272fed878733063a67213c5ed67b8b09338091aed9274ddc3d13437acc5b0b22b0e332f4f91fda93e5a418fc47c3cfa1aa95e68e03073d16fd90268039d457c889f2082ef185f15145fb570e24cb03ccf5e17149a1338b7222ac6a2d24b493ad837c178ac9b374ce5b8298e97fc8f00f32150d958ddca25d7506b3592e67ed6ea989df26fa16020407920369f8aba0b0f6ee08e2d13dfba6f7a10a8b3d72c2ccf4530e7eaddc03330987bf213a3d2355d6c34b9ffa7b7627f0e9a857bd028b7d5ca6a5dfa343375f565877fff4b0da516ad84aa3ab6220502f95cb9ce9a749bdf263e90ec4e8f74e443fc6caf19784f53723da09eb89334039f6f0f3213c33ffa750d31eeff7a568b03aac6b93e863f13edd9a9ddfd26aaf819383e29fa1abe1c3c96a08aa02b038e415d35ec676fc9e398e4f35150a661eefa6d4760a8de8067eebbfcb0001994f321464c327e1714cec09be65e3e86bc087dd69f1b77d58f980f6843348c5ba01276a22bcda4d755ceca50473080e72b55133b452b7a32cc46c8095d6bf4a14605162455a564cb7bcc8409b5bc1a358df338481f9a6357996df9dde01d50391f4cd9c552161bb3c129805f277bc6db677068c004636bd3f56dbf39b5fb7eeb15aa372562c8f50a82387c4d4bce647288b35523a5b89d4e0ada039690002a94b6c07c256e338cae3551ae5069ef4957f62aff65c55a9b3e11b7ddd6f8eae5347bc37c9f98d73233a7a0a376de43d19d244171c12769a2456cba611bd761cba4caf43d8815c5f4e03d23fb0b9cc3c8a1317809be75cdc8588da56132a09c411a0fa162bf7b6af6d29bbc8a5a41bf672a4357690699c310c7fee9527d035d085d01e4564cdad3bc673a028cf2ddbb214886f11f2f11b724c456e5bc1014d1db298aa9c5bef5e9dc8525ffef7332390729f53322cdc56a2f54610917f629b4fc80efb84f9db45d6a4b0d08f323d2e42e15a668d1fb212e0d39b599e14d2f01e1004edc9b8bd86fd6a0d6dd4c58b0255669a3c5cdfe9b4d31b95ce9791713965076fc3149cc22e4d32539eaad657ceaa026f887d088b4cc3b07c2960d9c379f34c7a61e1f2a03e7b06d0ea5454aefad50fa5e11e03931bb5b41b6affc4d1eb762374fe2c08f4ee3c2d6d409dd5017bf82fb6cdb5add231d0a25678a096dd0a62563c10ac4087ad8ca957edce08380c9b53bdc90f85f1a9a3a53e0cf8a82afbd5aeebad362f4ea1c975653e8c766c6c96dcc82d6c5c22b18c399b26545a26b61426a01d87b942d9b8041c0eade468e877d3cac92a6502397a7e720153f114a5ca047b45b1df2705304a1c8ef54044028848551f624d75cc62877d381909ec64a91f8bc19178720928f0a1126f88924f87bc0002cf17942bbff0cb0b5f789e0793cc787c591a612cc1cb2ad93ae20c79166529fc5cb440b44106a29661e5ee3f78a038f4e8fe9aa1ca72bc64099984092ae9d4b3139738ed578449a854d6ecd9f4b97675408071063ff1992df2b6742785b2957f060b81844f83654cff744b7ceba78dfff8e50bd88a3acc563e57c2a8917c007d77f6d824205d4f39830d7e18b91c1f0ecc3a29e5eec7b9c28d478079a7d72e2529e674f0d4b9db34a3c79a510fedd88a9b8869d2a00afe2f0d70a6e153402ad0d27c3218d7ede8d0fbb30f9d040b3fa6d1997b659fa3e11df5e39fe3a5fb655cbe1a8a390e51f7277e75ac4371cb333e9727525b0289adaaac1e0acc21aa828df1a07c28b49a551ef624bb1678e290f3b8e38e32c4dba113549fc7772e99c30bef30d60fb13b94cc3b28a3e48f575b55628aa7f81e6a31cc2584c52db70fa243c45cd86b5bfded30b6eb376a3d3161a8fc36a4b5323108b969ac55bf1cb25540fe5859d781287256f255f08b4292d24a12ff5b1f77f1baf245cb94b06f3c18f85b53d90bb2b80b7fb51c6d347932a967ceea9aaf99735182118a08cec5f4d5bea3027786bede754191954372c1bafbed97a79a27609df5fcb7aa06caa4e41380ff5576618278f1e227ea74b63e91296250505c099b542a9ee86c222a5772703d6528bbee0a50df9f944a3292ece8166dd37dbe709692f17bf06783be1cbf1a53823908c73b425a9cd1c9660dfccb23bd3276422126f1b2007dadf4f101350600b5da4c7de2c837ba29fafc209d37105811dc08d92e8c8a8343dba9406847067b3ba467a36c119b72aaebc7af8c2c9c7c320fd4b586ae96d9e62c1ef382dd52e4d346425fdfab506517a78ad2ab462475618f927b857a1a6ccc8192888bc0f8c57d5a5a6bbbcba610afc7691402e7b738dcf103f408adb3a4b6e69541d7648fb0b6a87ce8b920b996b3528435ce3dc4ec1c036e7ad6539cb7befdbfdd88bda5204c7013eb8651c577e803f3e278f5c4a38db6a687da1769b7fdd7b8c9a105f617212528705dcd000716d59f8f986dde3e9330850acc0393051db97f3d320535bb5b01427b24cd6d754e7e3638519f5eaf7fc9b910839ad169d2d9a9f86d55f5c9d5da54badca679735ac355be517fe73af1fe1e2fcaf6c17e1f76c762f8a6eebf41411efa13aceff0fc9f31cf0e37b513714ee6cf564770a03814923209364429f79c59e2ff2ea98b368b2b9d685106a7ce6dbd6e73b4691e11a18ebe5b2defb5924ba6b6c1389a1c182e84a13195b4e1b614a7f95a65a8df68523ab5a1f0b38642749de7f24112af106a10919dc9439a9f709bbb598f412c317447b736acb08438bb7237a5bff5d5419e1e4b64b974e49cccef3c4d621ca82552faf8605bfbdd8441894456c2fceed10ca723a9c775dd0d09263a0a82a491c9f520a873e42156672b9343c2111e2311061e9459b8c0507f10084b26133495030e41f8f3aacaa0f4b7b0c24bf945de2ba54e106b4a0e4a699dd1d1730f71dc70641870875cf7b7377b71819f83032ff61818d08ea17e3963b321e3a8df324178374133b6221955ccd7ccefdfbd2371a993fc79cbce46f1c090e2bb98a3439c022ac414f90f52eb54cec3a8332ebb16954a08b7c15b82c9487376156695523689e6a7bfca3d507fcaffd6d70f2f4126ae80e94a174d76d55a6d3a6dd1df0c99db07b24d2cd72fac678d681566b9f114763843bd45ace1d44116761dbf1590cce56c4305d02ce8f0233b8be9affa60515ad2a6df9e8091beb66f05d72013a3b1e767fb4ac5369661d959793610cd5fd82341336b0f3a099ed378869d3a4b34951db63f6ab1919ad2130b7b744ba890c8a4d76d96d18c33339433308334f87e807f40342f145f768c987b681089b8ce51ed4b044ecb9df7b63b7a70ee5ef69bb04e39c4026f017393ba492ed6b3bb8c4bfba066b6b825175970336276796d7e2ff215ca9293a2282418fa3812bade9dc99e0c207d58fd7deb4446b13f440adbbaaea22c3d94f6109f1c8e26e359b1e6f7c6df7a85e1046a901e148d13e7595a94ecfa9cd13c541bd334eaf3876dfa7eb9afc2182c6935067c310f12aaeeaa35600859d1fc56866077cc79d12d63c1daeb5ef3bf95735caec0746794452beb628fb5998d050ed3fd7c9c90f0ede2ab68ab345179434d347d461e3f81f526c5a072371ca73a9e8297bc04355340aa0510b5c8c64d9899a41f162a2d016138176411d20a1af7b04a50eeca2cc7dadcd6b3b09bc4a37119d6f38b01abc0de16be81c37c70d30a71ef02aa392127818cda18b2c646a96bda674e467d0bc78a0636899d588a2e219307422e73dda77761d56f5d11a73a3a164a98b6503408a29f5abb59757ce08c65c1979aa82bb0275e79afe0420d317cccc4f8d061d1eb2af135d115a0b0db78482bda174f519b66b1a675cc0d3c9d97efa3f8eccb75d064c5adb6b872381752c514f6caa879716bd6a3b0427e5916a10266628cbe6e75f5b66737ac438bd6b3bc46c6ee6d30da18e6e7b25d67e57fc2f62ac53ab0ed9ce00308fce10e5b21be8786226ac368eda5483653a8be522226b6eed064650d42ab39012ada521934dab7cb2a1d3d28304660c5aa0048ae172ec76b8cb2bc04cfcacabc0f8f8d86124dfb24878d3bbc0008b5b8ee2fb73cc7713915e6afceb0cb0dfb59760ffec30d8951c3fb79017c128c4ae32f9d4321ff27eccf59503af2a430bbd86683eb42e605a81d4d465dce16c639361e698a557fc5df8c670150b6c74e8bd485e387f409bc92d82390d5158ccb2e0588b87cedcb4c4d773e665950fc261f3296ccb0d685f0582ad658bc6321b4d861167fa9c30e9eb75c7bde9f073128abb84f8a1fef7f2acf5869621e5b6beeab98082eae5330b62c75a7eada41f2966b84e4daa126de2ddf91eca6129bdc75de4d5e8ab00568863902d3c1e13dead6572cd0062de53d81fd352370a8a27192de49e46169e994a0f641de38bd3b49234c000d4813dc3a45f6384f357c7cd7ab35498aeeac9fe696d0eac2fab5155748788903dbbd3f74374847d4781f220dce886e5b46c3a69d4a4517937d6a89579e9fe4d92984293cd9fe36a053fe91a15846061af400a94d21e562b3e8c9b69a32b79c6f7c00bf95aa98a8a13698c8267c2a06e62f9d2b1667253a5e2ca8f9709fd219598779b197d506f348dcd41aa3e54e088ddb5a1db993504a44a245df76fa1cef3c77063a67af8340ab612371f7d864f4bcbb124d917","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"2988c74ed382277e2c301f964eddc072"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
