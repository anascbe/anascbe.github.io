<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #29323B;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #29323B;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #F9FAFB;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1b97b0f8362e286d9060a4a712be039a70f9c5f2c61f70bc5ffecdecb07062f3e89732b89dec557c659701414ea957bfe331a3b1fe9fe904548efcede984e963391fe55b59a6132d020f3662bc268a754cacbbaff57a2983a825927f084db4cc35cfb719299bddc351b55d9c16eef241e66504e0a359de5cfc4212e6241aed150df96340fcdf549237ea1b7f89b65208a19965a604c1e33e686f1c3c6315e3fcb4749e373fbf0e5ca5b620ae1aa4d9fc543e86358ae25f98c888db4afbecb22c7c556b571216399ab98795cd6507973975da25f3f5ce782a8397ec7be5c70572ca4ae360b1bac7a2b5ce929ad74356cde6c1bc7f08eb750f95d06c5afe3b052c7c780832eb0174cd8d3a48fd8e76a49c02c41a8b152d33329e69a29b0b2d4a6ffb370266d9e8d840302eec354745019cb4f426aa43e0a30fb670a4c7fa31ef820166fe10454f519905e5d842185dde4f62d4837c32e47d393b73d1190cb9ce29f03f8434d3bbd9a2f148dd68e12ab50875985170a11bb486292ce565ddf89d163cbd6f2486e573662e420d68a88f37b091fad581d0bd640c1740eb21c335332223907c3aaedeb18bf883841dac30faf470a73fdba7cd325d41ca9154f0d79b4011724fb60a05341d773957e3f3399144bb1468114b44f8d282dba6766323737d432963e8df16d78eb61b46e28b2ad3ad3e3ffe569110554caafade5e6d570bbfad06772a496ab59c7ade53657ddf183ef2f473cb89101e7052e8b691f8bca46ec229ffb263d7beb0e140d080098bb51331cdba6776c2ced87d94f61c539e866cdfe2fec9d399338c1ec2603554fbdce50d76453c5efd5b5fc6391e98cb866945ea21f4dd92fbfd9a6373f61fd515efb85068c64a1093591e3cab86283ea9231cc85b2b92d8bdd777f3981cec3c6c2daf34b0856be68deb9d77382056918dceec1b5b0ef189a24b5e4bb42dbe5f5c919cda037fa233d16e98b84e74120248a5c448bdc9f6e92a076ec4bbc7307a44d173c65e232985c934e3ca76ca6354b74371bc8784a1c11f11c214359f1fa496d8b6b5348f0d936508780f163759b05f3480915240a285948b7b9ea8cc01d0053cbb9004db601c535473852f48af2c58def9fe74e5f9e5923fc950a8083a182c5a4e10cdcaba92c498b89ab1489131dc3a32bef0ccb02818081f80f5e4fafb6bdc32dcd1750230b1e5b0f75b7be01863150e1d7038fef90470246a7fb45824d6136303376b514fdc0c4a84c4eb7ac29c455da6966c61612a2fc5db3aa28aedce0654081571c03ae0cafc118cd6cd5190bdf29b294ea2fd54f0a20d749bce5fdeb80af081dd76e93d0e9a500c35ce8d96ce2831dd414840856d01375b9a97976696d66db2d90f3e51e614e5b3d4c48c60df50f88017f95c38deeec992decf396330fe928be920704729371f6b62cd8a63ce2c8e0394da46446a149abf66881e84a131c9ff45cc0e5e6dfd37f4099a1c98709ac251821c397fa3512955a979441a3fb77756d8d5cf235f096bb9f662108ef741915bff85100ba024fe2067f1658294ebbe497e049f8eb61a93b0f7ab155888294534bd87ee5c8064719c3cd26fd444eb71a93b0f0f52f1de4dec37e2b61acaf4990c9c06dcf99414dee56bab699133f6165bf2314337fcd509a16e2ae953a8f4a5602530d86f025876a996237f70f2eabd015a43c81ddfb971306f45263c9c6ff670189dd20c74d2459a017d4f458560230155df6d963153f5750787308302869f2432740006a6499cecdd6728747e9bec5a002a5a31cfb38eaa38aaeb4899f1a2d4e08ffb55e9982ccbcade32356fd8c639d41426dd711c3160fcac490f6893e2bbf021278b1760fbde4ef135ee23825891c1bdd9544ff9602e7b0e13fdcf0f367c57821684623811f7aec3d6f8192519926f20b93cdc455a3a868a66d4f79c9b6ef92bebb774505026d4b22015ce8cb440ff81bced8aa85875c77735e89fcfb9e815987b11eac46367ba9cf2aae1453eb415d006660d074fd7d42cce1e0b890c0a10cd9056f0601178499c083c07e0d3e9c243129ad6591cdf67dbd864a3023070659d8475ced56452bd8fd4a02548ca06b523dc3c54c3d78651692b593d1d88180f93c441b703b11430f2f93f53a0083c521000d7e56a11c030a4ff0099c1fba7ce8a67c12fc9427872357fe688177f9a9a15b0cadfa4f7546f6c58971d59fff82a8548cb47f64eef4e265721a10eeb06cb1a547bb15293a7998a345e6e9da19291ec26db135c5c17cfd66aaa876141354c959505bbcc728f52b2c0292f12fb3ab3f39f38c51d9040785c5994ae89100fe79710df5ab97cf09837d711465f5c338a63be9d2675980209c0649916e5e3834385567f345b5e0e3f13ac0ef68e11de5e57f128672019c1dba2a98206cefc4d4ab351773bea27c70511e675d06491a36643320dc900804c12c6f051400d273a6f0a2f3bfd954b3e55379ceacd3f459547e6c16dcb668a997f8c023636a6f8fef5275a4449c126075c887536a07fa988a7fc9ca084d38434fc1f5fca2fb25f0ef5a7505980e825afda0f823af5796a71da60ed1d1512617868abc29b4d8143ed85f304f624cc62a3b9a583784180df6cd0e357abc600bd20cda685333272c78308f17cf728add6cc946c2631a74bee2d29bb499e52434d20489d0d93c3033fa6a1978bf0c776787e7dc141c4b2dc2871b374a78e1ccfa7418fdee1ff294ec9c3acbbdf6daec48015d3c87bf541168cdd6a1f3209f30a5a7f08c752606f171cf9b7ef4ef964bd2b342cfe422b10afb2a3f74a21f3ca8d79f4becf877455248b2d3eb5b34d3f8011de62080ba664cd55e0549ab6bc3cc791039f345c09916c407b711dec8d54e84ec295ea5f5bdbd0c966c2cff390ba897b06188b12b37692626d76d930f93f0b6526d0c503514d6dcd827048852e22b146933d42ca932d8ba91aa4bbca8e0b9550eb713ac0eb78d3f60d4fe8f6a757dfb48c42684af361e98175cbf267eb045ea9c7625b09360fb818bbe94eb2c1de5ca9a0808945d677fc7549c3e598d3ec691223db2775241d0cc17838e8e2f16fca59e2b042cca6d268f76a44a6e3e104419b5097194169cbeaa7d5cae4ef6d01c34a5f07fa89f5919aa9024fab20a700e4868fa733fc5f5f1505a855b09855e96ca23e8930f6c487dc4cbfdc423d0fb7283b369ff6ac4403edd797de1e315e39625a7a35d8322577ff363c18adb2f407cd0e70dcde654cd49447e73f164bd6e225162238f259c17c3baaf3dc5426bd70aeab3a70a745a037123a467a8f9534709686e0c3fbb73769126931092217245b8569e3b9075e971a9a92ecba6d986c53f1bfb44de7ab9b8270eaebc0a9b343f5f3fe58add81925f095b3d59dcf0260dcc6f65958c20f640b17c1effe169387807fe963193f1dc15d2994b05e4d8d2dace921290f40e4d99d1c1115dbc507542a528b9fde550e44e67b33e2caf791e655c96ab8ff846d45864ca1f3ad9bcb55be95c6fcabbf936c83e7a53e4c8ed39edfe148f6581ce360a14b4dfc1133a3e872342bf4a44941599936c2b77d2198d10e4625e5b20cfc994d2ab39f98da91ed025bdf386278f25aa98ccb3575eebc096388479ae43578c052b234bf93ee600893bee2424daed283896fd5f8c65007c865a1b29f01a74979ea545a04994aed916d41d3f29e9ea91668cd72348361a196e9450eff24b9f727f2e5e455768e79378255faedd7787e8a29f991fe46af465c218cb51c061567b83dbb154f6d546fc1b9ca8339c912fcd987490af24a537197fe074e9f7c7742ec74b98e24148c7ef5fc7264ba5c2cd96b6c2b266b40f95f9b15fca07c46a62908cc2775dad0e5ca1cc55d11b86308a4fced4d25a3affd18a681125d183b5c52d50d190e88ea3542ddb2ca112e349adeff6099564f992a0734fd159de6b617538556a66bb07f2a63d6fbf889daf6ee093f90e9ae80ba52aa1cdbaee474d6d5ff601c51d37c88f681a1a883602894685b33fffb589f3da258319c9c9d0186c59bb2ae2ef4676742620aa1875228c24ab32f6394f13cb967dd5cca9b5adc3d25b491ac88d752e816fba88b2459b9f7d50c30f800ab8775c92465ca04e2aa81d77e8f2373bc86be2ce20313580383f2a217e9f136ca8ae21ded0dc195b89f189cbbca226ab79d178279d223ab129729da6b3280e1beea563a7eeecfb74d048836e9ef615e4394a4588a9dd227b6a793743dbb000b4ef1f8414ae7012cefd2aceeac16e507f34c309a69b828c4f8cdc46ac121ec939834c4cc09a36c85da453452afa49edb6d70145902780f82fe2004ff17fed180587dd8e7c8ec8da7a9bdc5e8d294544465ae5b2121e178906a4ee7db986b3f583b1cc612eaffe66000944fef03e1033c15928765b610546b95fe92c8ebdf812f3ec2a1a6f3597cb0e873544406b2fb9a444d444bff9acfced726c3a13f9dfc212ff3268ccef91c3af40c02c5de71c9ccab1a585e150d53653a56157fb491a7f577504152276fc88aaa76f9eff9eaf0fae75fdec8d5a03829bc209f42c79bf4d89d05afb052562f53de6624c0fb1ccf79d3dfaa2d5999edf7fdfa17b77e19d24d5f32597a6bd3285358acb9b92bd4d47cb206d480bf6de6de18cd1502bf2960495bd9f087940494f1d8af9d32c52b6f7a424654fdbaeb47214c7216ae0ef20a1c7fc67770aead9b0ef46c94f2ea319c37d052bcfa41b571493d823584dfe803db99591b57dd69899436c9fb4a5455b86115d83331364b32e293710440affb6cfdc1e9be20de2ff70ab43055c8d59b1b2ddfb826e269e28c21a10f5278bd35516fd6061afd18c8c164b820f4decf4203670a0671c56e09d995a57ac74aed79e2b3575963d700bd9b4a21ad539fa13d294b0bf51f126b930b2daf2e0c56ccdb51e633d18fddbc249e5954554448efe8917cd54a410ba777dd8a6d7f4f0771ca4f9857a14b9dcedbc6cae132d88bdc036b37338a470232605990305b586a5e8b4bb0913bdb43768dac40010b7c114c575bafacb55f8bf5ffa2014d21edb74f10338f38561f003cf3dd9af90602b8375d2de87b64fc09c86db10c4bf271397b832e872ba79f7d824510a2ff3dff3bdc19b6b004d7333413ef6add2a37a6288c625415d6d46e75570a87564e16cf133a869a50a0c76f160571250a599105897985e500f2f42ab34bea6c08fffb810e319f1d904657ba970e6c94058a5fcde823a4f0f731e22159822f3549dcc3091b38b98f8d74a09616183eef131232025c6d68f33ea296a10ee75f3ecf399aecc03ec156b3ac1ee19ab06b4be764988f6362a3180df668108a898854533dade4740f6e0215c57b3855ee9267c4dd0b0bbd83bc2f4351a6b88f0fadaeea12c3b49e1f33ddaca8821d9d07ff12069db75f1167f12385def1fc2cda8e6bb03cc85d8fc0bcb3b8cca4f62d59bb1feba7edc318d0d4f43bea93bf5f7c0c6a814e171f765b6c51c8c8a68fc241cd9d599610eec64d786a1f60f4f05f96a4537c9321ee3589ef0256aab8ea457ef3f701071842483215be1118ae4e4fc6860d0890c7eeddec5c16f9044c3c49331bbac4e7fb064b0f13af648420c5ccd4a5f1754fad249d79cbbd448a0ea127ab6de135f8df2241f85c4f29e3e103a2ae21aab5cb624a2399aa6133e5e78a7629aab4f7e7eb653dcd69c2b4cc44e035f591b1e1a93b4a9c8d549886315483383c87419e6d2b4fe8a98062b363de2f10a06108f6149622dad52b18482e6fa256963ee574879d183504aca6ae35adf4e0ca2a85021d0f6330253cabb391980284df5a13fcd7f188cd10a4fc542e9afea45461a18647f89764607ad20f7dc6088eb122e379f7e03af79eb0683becb3fa13573c2bd3f367be1491633ce697f671235dc768728ec0332a4b3c6763a9f2153220bc66fdf24dc3180e24c62be12ae9b9ab9a425f3dc1f9f56ad617030eb010a0459b844c5dd478382dbd7ebce9b79b2f6893bf84b8e4baadf88e37d3cf8780721e5eccdd1dd5f07042e4c3d1b66330755d0528d608469b7f3faf0ed8d7a81697e2b0b513516442e9d17ae39db829603e0026b5622cc3fa11a357be4f1114414827c7b33a8447b464bc158fcbae1fa8d489b5d06655e67e86e98945f834ab79f6aacefcb7db52ae3dc51807420ba55f982b4e91f09e26327bbfea1c01283284556d604a03a2551f6d867bf0046e4f19cdb2294d615ae3c676f47a854efd05c5dfbbb13d02ad473574b2e447dc791094aa9017924d9df1e33bba6bd877d8e2e36cd1fbe67d457a04938c204a8b66cd503389110d4b43a0ceec3050843a2e59937bb093c45c19b952181b95bd6603820a9aaa7fd0ea7c8ae7bf7036004b72d243e9d3cf7f4369fa2c4d78815bf034e63901cda516375dcbd3b76a1ad740689d267233fd8a690fab832283bc5ae38af3e2c6a314f51724cd40c66ac981d1037d4151e41fb69f1d98744e2cf7cc5abee2c354566e4eba3e766cd174c24571d58f68e434e25d53e13069974ece8306cc3397a36bfdd932af04d49cf6ee3e288fb16829e51a481dabf2376c041868d101365e13d1a213a59c37ad614f25b578abee97e6e50082627c31c42e6783bd37c71302e5eedc93b8b0104857c74b8bef25b6c9d3450722fec5f8e51ecb3146fcfab2052c3acac605cb50958d211fd6c1b75eb722da39bafb5ad8e3533f37414ed88de55b819245166769bd068dbdf8df8b8d97e59ed936b42db48d33f1078acc95fe4f7cf4e91a06dd162e269c2c77c887f0b00a604d445872e158f8332b2eb4c47ac13fc5ac1cfbaeda805f3b2ee4c10f80579ce6096317c4728d7ed587e4a37cee6073a51589634893b6a3e4818df11f78c163341d89c1e00e39b0d038c8d427308bf94c6e6999d25801a36750278812d7eed1c4168c680f25514a9ec5cb5ba8dbaa7aef23573eda064f47b8cdf0ecb4205f6685ca4065c6d241979ff317d420c1aa64386d36a2cd2a05399e480766cd64d4f428df38541c13ba8e4ab9206f3e672dd0fce90483681810d4d570e1034e47e6b7707b27bace817e3845ac669d726a8f5469a566055b03901c0a58e2186245cf94318c202a70b185ec50c36081089c51d6cc8f4970caac2837812549e52473713791482652f77a6a78089310db464680d6b68d94c3bea7e64ff55b756453471f2ed9f623be3ea43cdc7c96c83ef0c1c80812610cd8fc5d5a1dc7427d94df11433aabfb81db75279705f48df15961131669cf00921e952f3f699dc5838021fbd8e793e812ba51ccb863dca38ec27e90bc9f15375e2af66b59869b31bf57af1b15c693eaf73baa288ad55254603edd032c26284de76b9202b48b296904212c76ec1c0e033e9141f60372f5b9085ca634ecf27d8fbf654054c1e0d7b38753edf72a11c7e78e177ac2619a67ffb92d6ab6f12b3cdd4d9a12711e577ca8608f843dd0a1049013d3ba85291e6ff14e1347b8ae5504585d8adec96c20799b7d334056bfecc171ba7250a892735ecf134f2aaaedf64ba6493894ba3f7bc04c9c8810c86e30af766b99592a0f569b32627158d2c0dd5c6c4f6ad10297f13b8a51d55d2c39a3d3f74721251dcfbd51e4e680b2e75663de34f5ab99eb94de7ac53af908541dbbaefdfaf30412396d008f76fdca28d7573c8b4d43a1724457e746c2e84e3ad0ee6b47dd6538f295fe791c64972945240896344757f1ce0bd57e4087eb2c8fd6bca61d30ea9bd060ca042ff65ccabcd1343b4f8603c66538d3775dad08e7167a69311243156a6a03153feb45b8d81515f2be92ecc2831018f75ccbbf833c53f3b2a7b8867ab5accc2b31ad9ca0d91baa3e2f27d7f697e55e5cf77bc2eaed85f6e5ced935d5dbecffd9e20274e3a141dcae240364aa75dd879e49a3c3ab71d85ef9f9ce73d375d4a8aa76e0d844ffd13e0fccf1b1bc51c9d35595f776029c160163ed1f34616259ab8696e7c40ac953a9790e87e5f36769d30eb83f3932bb920f83aaa171f45d35f20ab9374e928a93b31f1b79046a4c7719d6369b533733afcbbf4b046c0618fdcd4662711410e14071afd527dc8d0db9b4713ee7f8d33709df0594518712c765a42d1e1cd5abc989c22c94e896aafe779a92a866fbf578d7d9fe97fbdb0e471a2bcf1458126ffa3cedf9d37dded076891e908c1f3a7a2c78a870a18376495bda714b96a0c0fbdeb8e2fe16eb3524df145d201bb3d7ec521a96e0681a1d2c59f3498e02b7057aabded07627fb2a87862696abff63f27a2a1707486f550a54781696b62d1797181e2bb7504c329155346851bfe9070315884af0582ac3c910ddf6906421f57a10e2f2c18ba595555539cc41f556628f1e75c843b50a03d843b5e56cf937c3b272339d9de15b05c120579b945aeb6c81d7b8199986387846ab76ad4ab7425c2b4042f677a9246fc6d4a75e509c6bfa23c103aa988b603d9bbffc535b87d5e40c898841b8ca89673e04a1153fc036616810225279c9addbe2893dcecb8f526d2ec0d8cf6f62b9f3f7019f3670f7f05214cf0b06a071ef5003ca66bd2a90d4da47fd052c3bcaff821e95a6ab46c8a61da8823a57ccb57e0c7e05a7b02006fed12df6ca01c7c204332caea5ff20b2742a00f85a637d077aaa61d169ce2dd50a2d411c1af5233234f05fa8dbaf5659273f40b889a466303bb67dae5e9a3a0a90369b95c55b42ad6e0161253522fcc5c9c94ebc924f689b1b9e13acc5505591734c872aa10ae08e7b3e9a0eb1216aa3d330cd4120f951a23d8541a021776acc64d2ca9fd114f0b6227deffd4f7155742f1f1c6ad7c948cc5500ed2a04b69491908701c875e4925fade265860db82c70001ef9b5ff6c5c6c6cbe8f353d201a935acb413f89b9a43b81358ed8f433c1f4041e36a7b1b98ea19b69cd84688d0cd395e819b84934112575f659e356fae831d0a26ecffc50874dc9f5e5a8daef259449028797b1f2d9e71b5a5e8175dab427bf92ebab156a33cd8a642909acc021109762e276e88720c44ec7891f2baca43ad3ec1c0723020bc8d9a2fe90a67d7fb83134d0def778e03f40cc2b0dee5aadc6a539234a0a575478996b95cddc7a6e52caa9069b1da3ec4024e611aaea2e0beb4c3b344a6adf4fed4ee326e05c162024bfec9405e1995cba5c1adf7d9d0461ac452826b7b70966d40ab22bd6dc13dd4dfba3b09dc2c355016412e1d9bdc2cc9ab3fc16f4153d2895ac015a2fa6f432206df7afdfc8249cd9eeb033c9dfdedcc15096975c29bd47d0922e9bbf0c80fd34a67a114642384e1e97be59fd4fbe13f84a514947be028d91320f920edbc543107572b74a2c298d73c78dabb5c220f2669130e23c7fffe2fae5066c8a842850a1a62433bfa58f242f1c384e374197693ed7db392cec3e31c4fe99aaa626fc3a96dd52e37af1633247b03d508c51bfcd4f99e414e3487a45fcaa4183ceef90a7d7b74f810184164b3616d5481172d5187390ae73f6693d03091c22666eb48b501a44e668cc71c7b790b8bd2b3295f0fdae1739b781a90998fa7c44443b7ee215c383a1d973600b66dcd81d666c30de7721926ecb81aaf90ab6cce5812fbee0f293381a8ed28bb8447068e95f0bf51009fc8842d96436c13087dcd441b71a3d339aeb75927e8fe36e9c23446777db413671f3447e5f7a974d8c7865c167b35a18bdc509c4910b000cf9d155b1a5978c0c698172027294fb0d52cb44c335a2cc99adb78768f00248e7f91c3e44f6d9820d61303715eed84cc05f36ed88c6ffaed9380fbc995a5fa080e0f751196b604285a439a8b62cbc0a23f2b364d38e33b91815394602863e803d783e50a5e7d38dc039f7ae2f759b22d8818d32fdbadf110a40616f34d68c229fd97a93ca50eaf811b2924c836c95a51c5f98a7502ae3fff9b99ac9ec72d8516ec6cd8cbf0f6dae6660d71e6c8af1bf06ece62f82ccb3b49bece8984456e390747d18f21efc163dcc1f8e67c8a08344827fe83b9378bf261d5cbc4c3771b73541f18469cc8d849272df9fc8d6d5051ab6a13b98bd519316ab633250420296902fbe48f20f2f91b3d7bc69b5a3f7d6cdae6b9dfd74a7bc88b8ed6407fc0113eec748f57d92cf2cb72439e5822a994cdda9c828a9c8877bec9c4dfea6d13ac54fc2ec6a346fe354ceaaa8c818f4e138d9dbee5c0f35a8e10d21b34a8ecc3768877cf466c33bb9e3ad22ad5208cfb84071056aa28dc1329a15799c22cf9a39f475b33e668bf65dd097ab00a0ef96109cc57fbe824dfa0c7d796d6450e3c2b1bc2563d6e2d8280e4a63a0942b6ff8d46c0a038513d9c48f8b56cff94730cc5d74718635929b3ac5d324bf36c72af3c0f91da3d529d99ef160d82e37dcee18ca920c223af46d91e1252d67a1e36f2c5e8904087458067cfe660f8a243736368f3e092d0fef2715cf2e5e285dbdd6a0b75b2ee4344e2cde18f52dbf9c880c35db086d7054aa7cbf599870fa2ac31dbc2f4e79100b73666cf0141181ab4e6b090bcc009a17add1d42d873202cdf361dd403fbd933b4113a7fb80ce565dcaa1e6223a248222b4d2da73215e03ca093b4625c88c41c74572b892256b9c46f69c135058841218dc4db8cd0213dd95fc2836bd42675868b7e70638b3c605a9a93ad0c3a97081e5f461ecd71eefa5335177f9c46ebccc3c1d1936fc68c8757e99cea5be8bba18f04a54197207d1520cdab29d8ba257e0a76ff6cdd7fe0aed50d5d16e659b0f95c027937d01d6c42b50e71544614a195a4cf21e17e8fe69191f2be4c29d8ccff659762f6cca605e7cc44432121b75150564732d51f8825bd1c9250d363e40b00679580c15cb245898072b3e956c685b18b1b5963df99214d9ade705e3d7699612c98930cf41da9e05c16b1948885788db6ece8bd7bea2603d3b2242f9a0a8d0d79b1a892e48a8abaf8d00f35746d4c92916771909ab7dd60999424fd0233e967a024a1f567db8606f3abced5fea37e3743e7c3815799d2f7c706739fecae00a0c59cc4ed03db108ffa591444327516b37d3da08649d524601e202378ee1235595c81348b6eff12d22d55c7059486b3956ad21ac04fe2fe04016007cbae5a96f637be62f6805b4c41141caf6902db4cac74ce0609e76da8edaa6a3cba5f7d446d1256c03687d0a411b6905848ff857eff29e1e3f0422b7d126304d98e5c38dedc0f9ee026ae07775af3957be071e9c9a7166b842486f88a62b8be108eff09ef24071ecc45b395b3a729a25bc3f596454d98bf618ce0800cee9134febb8d07ef5081414a6eb5c10c6954b459e9cdc8c82161d00d0b252fa6eaf7a750af3ca727b9c4d85e4f85cd498086a68d59d1503a16b74af7ae14352fc68f3cca77635010a249e2694aeef64b8dceaa7ef4aa8e0f643557247e9d66a570fb2c7e3b83c1b540188681654722e2050a511b0cdbd179185cb8a21f944bc379f6d0812a3b0c57bbb53b48b56746126170e8e462d87b38d00872df33f045250d609f57483620a700b9a723f8a4c4090f06e1480b6d3495b8cf42f2759b0086751404c1097ba7302f68dd57ac9905d12fc51ee5f338b4bf7197f118ef211c9d9805548dea2b856ca15f6ae5db1198957f13a2fb6fa486f5963bef3213e3fdc4dd22d9aa59e1a724ec8ee8c61a6ab9c73ae2f05a4aaabf60a50af82c05e4c746c3dd7d6b4cf79b9716026c8333fd003eeb487daf972750dce72d0895542a454fde6246a7db132062427bbf943215f681c13056523ea754ac31a369733f64b9da7fa333ec90890cc2ae7fea95cd372fd0919149569c66ee0ebff611f13f3d2454115208ecd3b1f04d906961ee6906d0068a777d2fe9df13717e7f5080967c8a66e9e66d74b54d838b080685c0afb468df84dec788d73d50b8512f311def128d06c0c37fd60b7d858a65e46174ed738355d6481670076051ae3bc42d3da1b8eadffbec1a286174a9697deff86d3c975478bec7a541f0df771780d1878376925a7dea0d262511176008ae0a284b9cd7dca2edca69812da80731ad87a0ecc448ef17ae5810458099e1d6c599fe726a4633d0bf74824b535b039078cdf719ede5d9aa95c5e4a9c0cc1f2e67884d118a6c9a6488a30031387e48f731c5aa75d362c59e3f83a029f5df75e741497780f3335811f5fa8cf7d420d82c78dfe1867b8ec5895f86f1afc9c11dd8c69c2b19b2bde3af90941597b6e034b101ce2ce33633ee6253a33e4780241c0080e8702822e385c040e9997f591d5b7812cda3988425ee8dc990a8680dbf43475372f7e7df35532b04c40408d235308f7d96827f2231a6c28bbdc0a252e577c15d042219ec3ecb6b80db77de138282bd55dd7959c4ec8cbef2bca7717ebfd5a21474b348e84077a4fda455c4b73d59c55c195b74295f7126ccdb8013441e651ac88e6d8dcede4c9b178fa967b2ca5a42cb56260213598ecd97e2f9c19ee4a304abf17fad446714514f3f3d9445c35fcf28c4ddf15d0173a1e704da6452fa7eb3ae0bb4e265c8fc7d99750da4b3bb49f681fff41aadfd6b2b260d36e1d96cd6e54371aefad4f7d833f51d30a31c6b3c35f3655c13d6aa24ab76bc0350b6309e7c2ffad5247e936765304ef174236c8d710abce35512a4b5acbfb0427d7c10f474585afa9f3c09b8f35a193be9c88426756a0b189ac399404d72eb84423972d85f035c36a47a75cdf3b052d9cba2e0e59b1d665aa7bf26ba8e49bafb80dafc1a197188fc5fe8e0a0ea4e0330e1cae1addefd94440ecdf03bd35a5f5b031e836ca48a2d001daa15bf5fbe17b21cbe9aa164403e9658015fc23c9ea16e343b06524933335d095e9830272c3f54102e99b8668256b17d7b78c807577458552b04e6cdc23c40c300f4d1db6a8eed395743d1465f93fffc279e0e5c8b826a287b815388de7a811e833c41e871a00c91ee46586a31530f2794e2eb07548a924cfdab03adb5d2aad1f82907cf37bcee6cf1131773034e246298a8c35163077722a3d43ff4ccedb2d73ebb2cfc395d39af6e42428295e9a351b31a517365d0e1b6f0d97ee10dd99f1aa953fd88171f09a2f26904906ed601f6cb8ef1470c246e8589b62fcd9ac2ec7f8faf75d063b5526e8ba56eed637d492fe3a7b96e9e2c90786e095ec1ac216f85ef77ab9c4a37aaa5eaee521f80811c0b5e4f25cd0aabf4c79e139c383cd3353cc16ba5d41a1c8144c65d7e0ca3fd38063bdacf49c0ccfc7c5fd2e9459aa52204045de18a491b95da932ce038481c8d7f83ae89e3c710de959e4ed2591486d14003ce1723cba0ed3d104b6c0d2aabf04dbd050e76b0136045bee67e2eab2bc9a3186045c4b7cd3d7a420e7e284fbd18b203ce3d1b605e24c284a3605d8a91b24d981fc935d3e1020c0f3caaefec2b518fb3ac7a3429e4c2a19073989ea9b3528436e39d1d01ccbcf67ae98af73de0d732712f949d54fc41fefd5cdfe5d5520beaaccad97d3e1273184bf936c05e55d921bd5c9ccbb613ba5ec6e44398b68b69addfa771ba9e10aa0827680c50b5cff6e0e8d62774853803c64782e7a34956516582da7b7fe84f83d8b6a0d0de3c82777da575cfee75bc171ffea5141c9b6180de454d1263a71a05ec2142cd1b3552a761c0f0c68924b10bf2198e8ae940304e7e79fcaf725dfe4c321a7b144040a5f50e4154a4994bb764a691b29e15313810b91a7b3af63b5dcdd3569c3c8004d436b8a48eccac0cdf8083c3da1f78930793dec73aafed0561a03d9cf986852013a104617bc086f59103d2427fe446d04e1a8b81a525e2ac0eb8f59852140807701aaef69b8de76c5975c4b87be22ad92198f35d1ff2eb4118f150aa4733b5617d7ab022d502b7e994ad77cee9492653c8e515bc04e949f5eb25d3c81a55ed6e9ae4192c40ce013cd2f5f2af664a2c922edc2e4f8d334f81b00e3a279f7fda658bc069c78a09571bb49a5acd99fa54c503b17afe6ad74a3a5aae2bd5f9f7937c13c321aee0905763809b98a9db88a38d983fa1f50d1dc8791dcc26d48bcf06e48a469be7ed95e0072713715630c4fd91f93814baa831960de462f456cdbc20dc9af125822f35b7c7b0ba8ccd030bedac16a1a97a3e758ebd5676468ad4efb1bf86da46eaa25de2882c280d38e582c98434beda84f927c9c41695b42f9a710a77c2449bcdd94c91c6379093a7e0b1e68f7caa04565d056a6bc52559e9d346f43cc1915a6298837132752f2f62f6854bb60cbb942988b899a4924c65f45d1262c18ff23d271a341df298b9d25b3ba6bfed0618dc5befd37826ab0aa13a6034245e4bc3ef75a7b961621ec7e707262ceec22cfcba793adc5b250a6be435d51037c4f19da13d19f9b7d71dea6237c54950c160538599e30992f5619678a6277615f282029a162aa75dfa5a626eddbbf4200ac82c7a6b76c90c551efb96cddeb3f9b93db774b0ba8094d7cc0a91c47cf283868e33640f40c671bf38d937dfc37670da9f34b029b632b2ceb79831543c802b209617421bfb458fae3838ef3945db843a6a2782eea846448e6d3f5be5cf5f2b348275b34e48e524ceca39d27355ae221fc61c698073bfcb2e61eb7dbb9bd2a8905f0bbe997dcb76deef7a9211dcdcee8b38d6c5f2e18f4380c69c4f2213bd41a764a7b5c1843b8f8841b1115156c4874d7dd6fc28e3254f4d598eed2cd9f1fa8518963d184380bd24bb1e7857c6547f98ae5e6534694d33fae4f0c8f6a0573f713807999579e8333d4cf42ee7c01c26538527c69880de54a77845eebe2292deca09aa414d105465946b0ea5fecc89a7fad417a308e736ed380a3eff3c7a22445cbac894ac62620213d0ba9ff5974991cdc3c3a16f00287c4f01ca7ce4c90d9159300ff87e0d2e4315585e36f4bd6a69e0663163b824ac9f7403d9a0ac5a7f1b390e62d6492271c666fb42852a5d392b1cbf1d845800eff2b4e609a8acdbe372111f67f17373fadc7234296b6d166bf555ca3d77fd6642be431566557c1db301815c40c27e30eb6587d9fca278f2815d0730b853ce15d179afd327e770881ade38ca0ce2ff1b373a6feef69d1b499c3a0357e924ea407f6a60a9584cb119def40508d98f039b5985cb155f93cbf0086cb05529cbd283d56656adc9bd1745666ef6c6490602923328936cb8d42fbed07f3db8c1b25a1e0f42538c7a0f850e242b4e2b495e9f30f354752460592f362886faa2c9a7081b7bf63cff2b8ea8e05408610e31ecfa20e03b3f5199c98ed34ae364b383d9c0ddc5a1cd0f582159c6d84a9235622342fe4afb93b6347b0a8a40748e5e165458a9e9bb16777c78020b0f4cadcf2785c5dc97ad738f7864938d3e78bcd76cf548c3fa8b11de0fe9b91ed37cf819aa4c42c99e3b72a0da76ce27c336348f0f9fd56793510949f740888c232520c699af1db0fc356308f6855d53fdd587f0bfda1c973b02007814e634f303787c0b18ff57049b8045a95af277cc0ca42454c61d9948ac5d70d86fd12d460e0bbad90ad457b8533d46911e62b625e596548167b86953515f8858c9c1682010bb5479f579152b68929f10bdb8080b2cc1da016b93ae4d811822b24fb0b7585c683b0b737338ed48ad136de149bc95e0317220fa304cdb02e50e3f772aedaf7442fbc404893e2440c3f021e994c89715056339fceaab880311aa5cfaa23e0a6e1ac4e01c520f7cf3b375b4691473ef02e88e9fd4bf9567421ca9ce05cdcba528b867d60091921460f66d9b355cc67bae9f6b403a0a81216a83b5772f1913cfe16afccafca73c86e296038c8ce6a5fac7d4bb0e2652abab8beef2093e66200dfc535cfb3d712a218030de90acb5bf437bf2bc66e5fcc62f96fa04e0436bf3106fb609aa29f738fc434ea4c5a70613cba106107cbcf22af3e5ffd45d66cb83ee2a83f4fb76b93f29a70d3867bb9b83a8506004ebd376dbf2b6d373ddc02563f71202054290f67ec90896a9ac88be6d4d867a9c060511e497c6fb9c5cf9ce4ed9defdb590f5604f4dc8a4194823618ea30e65166ef66736ca48e50e5dae5f0c77e42b7f33a31a360e7d442945bb53f8ade671997b9abb261c4d2768c0dc1fcb732ce202f36ec5bf0ffdfffcd588a486d38aa2d7730f8132d99edfbce25f1b081117b83e7f7f1a96096192d9891f4b8be9a2371bf37ba1ce61b5395b441264f81d99db6586b2b8daf2d95f970e315fac89c661a6b74f40fe4da6f36a78724bd31634e964a0870eb45913625b7998a3dc442cbf47a49bcdd5d8042f7bd570d3222feea32d7e6aa80cb750592b385fa050e86ed53772bb3796beb2c483ac1ebc2d0ba63adb3be87a8bcb5cce0f60800697dac39e5e87730d45cc6db3122171457c2be69003713832ea39eac2dfa940d993021d2cca7a0e566e3d9d29aad539b6c885f2d82e550a29412758b954b4daf4fd08085c3bcf872b9c93b385525fb7873a8a5be0754c5d2e3051c0c610d36758f954c9bc6174b2acd414b444eac96b5183b0df7a7cc74a23e6d931beef7c78329907c8755328062c4752227764d5ac21fcd8f668de96e8dccb035fc271ef1f9115cd13997477c5d362e7df46cbc66028316bda34faeac34c907c9cb748b674f6f85a0200d07dd95868b063f417bd73c080685b4590b96a6141351bf051832855bad6ba2f609d496b678247e0aebef32deec9ade16b33cb7ea116ce7842b88fb837d1e54d9e4ff3eacddeda6ce892e65447a3be6d6abc41e3281f7ec6548f7244c92a0284c2957295e3439a3371c8bc932693eef8e76ee55dcebe6835e7fb79972b4176c01ed411a466b4cf76152d7f3622af9da7be0ea4c7a86d4724ae625b2d85fa85a34e242ac76895b9baa65ac331956deb9b9e7c92f4ef2828496b356d6605d2fb298247469a0f33a3b10bc78d868b3a93460893b64fdfe6e90e74bfc1302497618151392a4e4095b59a5723f02b5905da9cb07da6113465b339eb96f1c4c5dd572769fc945095c9c8584c1ddee6d7d8dbdeb28f879efdaba365e30db7005dad0ef7baf15649ed3ec34aa2654bcdb4afd52a8b2bec5abdd66d43b8dc3372f414dba65ede4771266c17da7b7bd0c114ab4f8e4c6fdec912672e2a3a3e549ee8bdd741ce35863ad5d04d02fec11fbc6c6fab54eb69a5237104b861ed9820d34970b096c082f420d45d1346c43ac9d8a8d3ec2834d8cdcf5c8736102f9e6f03c134de5de72635d5cdd826e51e5c474def7e9981804a866bfca3cc0ec4a79e5e3ebac9e4a5f1b10463091e55e6b75ce0d899cc980d029fb017500b730832deeecbe393d5c1495b3270154ce5e0a2fd3f4188b7cafb3d26dc20c0746931ef3c6d0acfb0ed590cf620e9997f48d8f730c27b5f1a4d6259373cb4599bc01fc375c0869806af9ace25e4e4b90965d5aaff1cc82839fd1329c4dfdaaf6a1e975001ee412da68953a75e84489d4d0998347b9a5d2918b8770a8a2a3f684c7ad6f136df9085b1a34c6e03760097f2f4567ccb84f490b481e292ce68debb419ef73d393111121bc3faeffb3471976dd7a4806a68d3123c0e42ea14fefc0bb432112b7a18f6e95134769edb56c1a8c7bd65527bc81170c2efb293e25d61254ee87bdbed3ec0bd3fc51caa1c16a57574a94279e3ad6db26c287391df4a230f0c25608cc1b3f192a26dec3803b0377d2b88ebf973f295fe4e62de74023a2debe4041abd047843d3aeb0f53c89bcf285d5f23b3c66ba510eff22273967b3e5416c85da70eb38cb58cb9d1dd755e9cd4ea96324abbd7d089f39ec0a821066f20d353f5b25a327cea44954068dcabd09293fd4e46eac2ef74ffe74d7904f48ed87271b60028503ad22bb8940b15bd861fe54db16370b72dbc72c42f61d806d729c4db681ea9f263b24d5c0435ee41a01828dcd58cd4d3013f64f51faec12938fd99a5da76b44e1246c50828453b958ed34228a37d72659be0da58c1b702728e6e2f8021fef3662db2a1744c9201f05b451b1ffd099c0549373ea6c1d8abcc949f051ef313be03dd25fc5150c01d8a961e2b75ffc6a01ba65b12c5871b7556caa355e7fac86676c01366620bf3d103be0d717957a4f5451ffd5d8520b48579ff0ad36515a9eabbad6eb247261408377c4fd7d898bbc325250a172effeee8e93fa00951be8fdf9368b6aaa0df4c349a7dda3ec2c5d5b4be96bf95b14d6f8417bb7c9c8f2c11f9a007855999a5a441ba4d1bbc86fcc3813a9acab030f2323773e47f0096aca427f3989f4c4183a6e478bec4b08f8901f5ecb124bc45778984a8d8fe8c264a7a59ba84d7c1f764a5e5597ce3b8673c82745d75f96eff386d4ce362b67b1d0f03a0379f8e6c5f4e481daf8d938a706f9969bc0047fb8ea870ce01b5d6a7dff639cf8e5ae81960bf3389183184ff04a290e9fc6471ba15d02927fd254402f1c26f3859264362a8d938fa307a92f8f80104c401ab7e6b5eba3b86b4eebaf04f20912ff0b6bcbac9b7936245cf9fe27ff1385a48b08a3bfde596fcc0f71dc6b14423d1956d3478fde97cda9744a69069a5e5e419768c14bf9a851acb0e26c1057296bc0d50ecae961a274d43eff283088da3c4f8421ad9783f827c85f156453800c3c9aa5919684e6c705f626eea51d7465cb2bc7026d836f5624b5ca10a5910476aeb06132f712d1dc3a30f4828511a0a1375e05ab1e8d873a12d062c3d74345698fd389ec44bf1ea55f4f06736258d5b5b9d83b0ff8bbdbcbf163adc52085c050fcc81fe5ac3aa37203a5a2238af8fd9a450375bf235640cda7f0e2646e9d1fee3d591d265aa9da2b7fe3237c6759361a755d15164d27070ff18c718ee9803016d414d13afcb6f86fbd6649ee30e947417cfd3c2b8f7a5f6f8d528e6f4c2c363694b98f9c09d","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"7c30a004c1612ad96778050b16ccbba7"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
